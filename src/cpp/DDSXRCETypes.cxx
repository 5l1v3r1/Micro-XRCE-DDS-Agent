// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file dds_xrce_types.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "dds_xrce_types.h"

#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>


















dds::xrce::Time_t::Time_t()
{
    m_seconds = 0;
    m_nanoseconds = 0;
}

dds::xrce::Time_t::~Time_t()
{
}

dds::xrce::Time_t::Time_t(const Time_t &x)
{
    m_seconds = x.m_seconds;
    m_nanoseconds = x.m_nanoseconds;
}

dds::xrce::Time_t::Time_t(Time_t &&x)
{
    m_seconds = x.m_seconds;
    m_nanoseconds = x.m_nanoseconds;
}

dds::xrce::Time_t& dds::xrce::Time_t::operator=(const Time_t &x)
{
    m_seconds = x.m_seconds;
    m_nanoseconds = x.m_nanoseconds;
    
    return *this;
}

dds::xrce::Time_t& dds::xrce::Time_t::operator=(Time_t &&x)
{
    m_seconds = x.m_seconds;
    m_nanoseconds = x.m_nanoseconds;
    
    return *this;
}

size_t dds::xrce::Time_t::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t dds::xrce::Time_t::getCdrSerializedSize(const dds::xrce::Time_t& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void dds::xrce::Time_t::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_seconds;
    scdr << m_nanoseconds;
}

void dds::xrce::Time_t::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_seconds;
    dcdr >> m_nanoseconds;
}

size_t dds::xrce::Time_t::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool dds::xrce::Time_t::isKeyDefined()
{
    return false;
}

void dds::xrce::Time_t::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}







dds::xrce::OBJK_CLIENT_Representation::OBJK_CLIENT_Representation()
{





    m_session_id = 0;
}

dds::xrce::OBJK_CLIENT_Representation::~OBJK_CLIENT_Representation()
{
}

dds::xrce::OBJK_CLIENT_Representation::OBJK_CLIENT_Representation(const OBJK_CLIENT_Representation &x)
{
    m_xrce_cookie = x.m_xrce_cookie;
    m_xrce_version = x.m_xrce_version;
    m_xrce_vendor_id = x.m_xrce_vendor_id;
    m_client_timestamp = x.m_client_timestamp;
    m_client_key = x.m_client_key;
    m_session_id = x.m_session_id;
}

dds::xrce::OBJK_CLIENT_Representation::OBJK_CLIENT_Representation(OBJK_CLIENT_Representation &&x)
{
    m_xrce_cookie = std::move(x.m_xrce_cookie);
    m_xrce_version = std::move(x.m_xrce_version);
    m_xrce_vendor_id = std::move(x.m_xrce_vendor_id);
    m_client_timestamp = std::move(x.m_client_timestamp);
    m_client_key = std::move(x.m_client_key);
    m_session_id = x.m_session_id;
}

dds::xrce::OBJK_CLIENT_Representation& dds::xrce::OBJK_CLIENT_Representation::operator=(const OBJK_CLIENT_Representation &x)
{
    m_xrce_cookie = x.m_xrce_cookie;
    m_xrce_version = x.m_xrce_version;
    m_xrce_vendor_id = x.m_xrce_vendor_id;
    m_client_timestamp = x.m_client_timestamp;
    m_client_key = x.m_client_key;
    m_session_id = x.m_session_id;
    
    return *this;
}

dds::xrce::OBJK_CLIENT_Representation& dds::xrce::OBJK_CLIENT_Representation::operator=(OBJK_CLIENT_Representation &&x)
{
    m_xrce_cookie = std::move(x.m_xrce_cookie);
    m_xrce_version = std::move(x.m_xrce_version);
    m_xrce_vendor_id = std::move(x.m_xrce_vendor_id);
    m_client_timestamp = std::move(x.m_client_timestamp);
    m_client_key = std::move(x.m_client_key);
    m_session_id = x.m_session_id;
    
    return *this;
}

size_t dds::xrce::OBJK_CLIENT_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((4) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += dds::xrce::Time_t::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((4) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t dds::xrce::OBJK_CLIENT_Representation::getCdrSerializedSize(const dds::xrce::OBJK_CLIENT_Representation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((4) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += dds::xrce::Time_t::getCdrSerializedSize(data.client_timestamp(), current_alignment);
    current_alignment += ((4) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_CLIENT_Representation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_xrce_cookie;
    scdr << m_xrce_version;
    scdr << m_xrce_vendor_id;
    scdr << m_client_timestamp;
    scdr << m_client_key;
    scdr << m_session_id;
}

void dds::xrce::OBJK_CLIENT_Representation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_xrce_cookie;
    dcdr >> m_xrce_version;
    dcdr >> m_xrce_vendor_id;
    dcdr >> m_client_timestamp;
    dcdr >> m_client_key;
    dcdr >> m_session_id;
}

size_t dds::xrce::OBJK_CLIENT_Representation::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            







    return current_align;
}

bool dds::xrce::OBJK_CLIENT_Representation::isKeyDefined()
{
    return false;
}

void dds::xrce::OBJK_CLIENT_Representation::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
	 
	 
	 
	 
}




dds::xrce::OBJK_Representation3Formats::OBJK_Representation3Formats()
{
    m__d = REPRESENTATION_BY_REFERENCE;



}

dds::xrce::OBJK_Representation3Formats::~OBJK_Representation3Formats()
{
}

dds::xrce::OBJK_Representation3Formats::OBJK_Representation3Formats(const OBJK_Representation3Formats &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
        m_object_reference = x.m_object_reference;
        break;
        case REPRESENTATION_AS_XML_STRING:
        m_xml_string_representation = x.m_xml_string_representation;
        break;
        case REPRESENTATION_IN_BINARY:
        m_binary_representation = x.m_binary_representation;
        break;
        default:
        break;
    }
}

dds::xrce::OBJK_Representation3Formats::OBJK_Representation3Formats(OBJK_Representation3Formats &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
        m_object_reference = std::move(x.m_object_reference);
        break;
        case REPRESENTATION_AS_XML_STRING:
        m_xml_string_representation = std::move(x.m_xml_string_representation);
        break;
        case REPRESENTATION_IN_BINARY:
        m_binary_representation = std::move(x.m_binary_representation);
        break;
        default:
        break;
    }
}

dds::xrce::OBJK_Representation3Formats& dds::xrce::OBJK_Representation3Formats::operator=(const OBJK_Representation3Formats &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
        m_object_reference = x.m_object_reference;
        break;
        case REPRESENTATION_AS_XML_STRING:
        m_xml_string_representation = x.m_xml_string_representation;
        break;
        case REPRESENTATION_IN_BINARY:
        m_binary_representation = x.m_binary_representation;
        break;
        default:
        break;
    }
    
    return *this;
}

dds::xrce::OBJK_Representation3Formats& dds::xrce::OBJK_Representation3Formats::operator=(OBJK_Representation3Formats &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
        m_object_reference = std::move(x.m_object_reference);
        break;
        case REPRESENTATION_AS_XML_STRING:
        m_xml_string_representation = std::move(x.m_xml_string_representation);
        break;
        case REPRESENTATION_IN_BINARY:
        m_binary_representation = std::move(x.m_binary_representation);
        break;
        default:
        break;
    }
    
    return *this;
}

void dds::xrce::OBJK_Representation3Formats::_d(dds::xrce::RepresentationFormat __d)
{
    bool b = false;
    
    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
        switch(__d)
        {
            case REPRESENTATION_BY_REFERENCE:
            b = true;
            break;
            default:
            break;
        }
        break;
        case REPRESENTATION_AS_XML_STRING:
        switch(__d)
        {
            case REPRESENTATION_AS_XML_STRING:
            b = true;
            break;
            default:
            break;
        }
        break;
        case REPRESENTATION_IN_BINARY:
        switch(__d)
        {
            case REPRESENTATION_IN_BINARY:
            b = true;
            break;
            default:
            break;
        }
        break;
    }
    
    if(!b) throw BadParamException("Discriminator doesn't correspond with the selected union member");
    
    m__d = __d;
}

dds::xrce::RepresentationFormat dds::xrce::OBJK_Representation3Formats::_d() const
{
    return m__d;
}

dds::xrce::RepresentationFormat& dds::xrce::OBJK_Representation3Formats::_d()
{
    return m__d;
}

void dds::xrce::OBJK_Representation3Formats::object_reference(const std::string &_object_reference)
{
    m_object_reference = _object_reference;
    m__d = REPRESENTATION_BY_REFERENCE;
}

void dds::xrce::OBJK_Representation3Formats::object_reference(std::string &&_object_reference)
{
    m_object_reference = std::move(_object_reference);
    m__d = REPRESENTATION_BY_REFERENCE;
}

const std::string& dds::xrce::OBJK_Representation3Formats::object_reference() const
{
    bool b = false;
        
    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_object_reference;
}

std::string& dds::xrce::OBJK_Representation3Formats::object_reference()
{
    bool b = false;
        
    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_object_reference;
}
void dds::xrce::OBJK_Representation3Formats::xml_string_representation(const std::string &_xml_string_representation)
{
    m_xml_string_representation = _xml_string_representation;
    m__d = REPRESENTATION_AS_XML_STRING;
}

void dds::xrce::OBJK_Representation3Formats::xml_string_representation(std::string &&_xml_string_representation)
{
    m_xml_string_representation = std::move(_xml_string_representation);
    m__d = REPRESENTATION_AS_XML_STRING;
}

const std::string& dds::xrce::OBJK_Representation3Formats::xml_string_representation() const
{
    bool b = false;
        
    switch(m__d)
    {
        case REPRESENTATION_AS_XML_STRING:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_xml_string_representation;
}

std::string& dds::xrce::OBJK_Representation3Formats::xml_string_representation()
{
    bool b = false;
        
    switch(m__d)
    {
        case REPRESENTATION_AS_XML_STRING:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_xml_string_representation;
}
void dds::xrce::OBJK_Representation3Formats::binary_representation(const std::vector<uint8_t> &_binary_representation)
{
    m_binary_representation = _binary_representation;
    m__d = REPRESENTATION_IN_BINARY;
}

void dds::xrce::OBJK_Representation3Formats::binary_representation(std::vector<uint8_t> &&_binary_representation)
{
    m_binary_representation = std::move(_binary_representation);
    m__d = REPRESENTATION_IN_BINARY;
}

const std::vector<uint8_t>& dds::xrce::OBJK_Representation3Formats::binary_representation() const
{
    bool b = false;
        
    switch(m__d)
    {
        case REPRESENTATION_IN_BINARY:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_binary_representation;
}

std::vector<uint8_t>& dds::xrce::OBJK_Representation3Formats::binary_representation()
{
    bool b = false;
        
    switch(m__d)
    {
        case REPRESENTATION_IN_BINARY:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_binary_representation;
}

size_t dds::xrce::OBJK_Representation3Formats::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4) + 255 + 1;

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4) + 255 + 1;

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);
        reset_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(reset_alignment, 1);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        

    return union_max_size_serialized - initial_alignment;
}

// TODO(Ricardo) Review
size_t dds::xrce::OBJK_Representation3Formats::getCdrSerializedSize(const dds::xrce::OBJK_Representation3Formats& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(data.m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.object_reference().size() + 1;
        break;
        case REPRESENTATION_AS_XML_STRING:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.xml_string_representation().size() + 1;
        break;
        case REPRESENTATION_IN_BINARY:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
        current_alignment += (data.binary_representation().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_Representation3Formats::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
        scdr << m_object_reference;
        break;
        case REPRESENTATION_AS_XML_STRING:
        scdr << m_xml_string_representation;
        break;
        case REPRESENTATION_IN_BINARY:
        scdr << m_binary_representation;
        break;
        default:
        break;
    }
}

void dds::xrce::OBJK_Representation3Formats::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
        dcdr >> m_object_reference;
        break;
        case REPRESENTATION_AS_XML_STRING:
        dcdr >> m_xml_string_representation;
        break;
        case REPRESENTATION_IN_BINARY:
        dcdr >> m_binary_representation;
        break;
        default:
        break;
    }
}


dds::xrce::OBJK_Representation2Formats::OBJK_Representation2Formats()
{
    m__d = REPRESENTATION_BY_REFERENCE;


}

dds::xrce::OBJK_Representation2Formats::~OBJK_Representation2Formats()
{
}

dds::xrce::OBJK_Representation2Formats::OBJK_Representation2Formats(const OBJK_Representation2Formats &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
        m_object_name = x.m_object_name;
        break;
        case REPRESENTATION_AS_XML_STRING:
        m_string_representation = x.m_string_representation;
        break;
        default:
        break;
    }
}

dds::xrce::OBJK_Representation2Formats::OBJK_Representation2Formats(OBJK_Representation2Formats &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
        m_object_name = std::move(x.m_object_name);
        break;
        case REPRESENTATION_AS_XML_STRING:
        m_string_representation = std::move(x.m_string_representation);
        break;
        default:
        break;
    }
}

dds::xrce::OBJK_Representation2Formats& dds::xrce::OBJK_Representation2Formats::operator=(const OBJK_Representation2Formats &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
        m_object_name = x.m_object_name;
        break;
        case REPRESENTATION_AS_XML_STRING:
        m_string_representation = x.m_string_representation;
        break;
        default:
        break;
    }
    
    return *this;
}

dds::xrce::OBJK_Representation2Formats& dds::xrce::OBJK_Representation2Formats::operator=(OBJK_Representation2Formats &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
        m_object_name = std::move(x.m_object_name);
        break;
        case REPRESENTATION_AS_XML_STRING:
        m_string_representation = std::move(x.m_string_representation);
        break;
        default:
        break;
    }
    
    return *this;
}

void dds::xrce::OBJK_Representation2Formats::_d(dds::xrce::RepresentationFormat __d)
{
    bool b = false;
    
    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
        switch(__d)
        {
            case REPRESENTATION_BY_REFERENCE:
            b = true;
            break;
            default:
            break;
        }
        break;
        case REPRESENTATION_AS_XML_STRING:
        switch(__d)
        {
            case REPRESENTATION_AS_XML_STRING:
            b = true;
            break;
            default:
            break;
        }
        break;
    }
    
    if(!b) throw BadParamException("Discriminator doesn't correspond with the selected union member");
    
    m__d = __d;
}

dds::xrce::RepresentationFormat dds::xrce::OBJK_Representation2Formats::_d() const
{
    return m__d;
}

dds::xrce::RepresentationFormat& dds::xrce::OBJK_Representation2Formats::_d()
{
    return m__d;
}

void dds::xrce::OBJK_Representation2Formats::object_name(const std::string &_object_name)
{
    m_object_name = _object_name;
    m__d = REPRESENTATION_BY_REFERENCE;
}

void dds::xrce::OBJK_Representation2Formats::object_name(std::string &&_object_name)
{
    m_object_name = std::move(_object_name);
    m__d = REPRESENTATION_BY_REFERENCE;
}

const std::string& dds::xrce::OBJK_Representation2Formats::object_name() const
{
    bool b = false;
        
    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_object_name;
}

std::string& dds::xrce::OBJK_Representation2Formats::object_name()
{
    bool b = false;
        
    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_object_name;
}
void dds::xrce::OBJK_Representation2Formats::string_representation(const std::string &_string_representation)
{
    m_string_representation = _string_representation;
    m__d = REPRESENTATION_AS_XML_STRING;
}

void dds::xrce::OBJK_Representation2Formats::string_representation(std::string &&_string_representation)
{
    m_string_representation = std::move(_string_representation);
    m__d = REPRESENTATION_AS_XML_STRING;
}

const std::string& dds::xrce::OBJK_Representation2Formats::string_representation() const
{
    bool b = false;
        
    switch(m__d)
    {
        case REPRESENTATION_AS_XML_STRING:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_string_representation;
}

std::string& dds::xrce::OBJK_Representation2Formats::string_representation()
{
    bool b = false;
        
    switch(m__d)
    {
        case REPRESENTATION_AS_XML_STRING:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_string_representation;
}

size_t dds::xrce::OBJK_Representation2Formats::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4) + 255 + 1;

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4) + 255 + 1;

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        

    return union_max_size_serialized - initial_alignment;
}

// TODO(Ricardo) Review
size_t dds::xrce::OBJK_Representation2Formats::getCdrSerializedSize(const dds::xrce::OBJK_Representation2Formats& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(data.m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.object_name().size() + 1;
        break;
        case REPRESENTATION_AS_XML_STRING:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.string_representation().size() + 1;
        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_Representation2Formats::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
        scdr << m_object_name;
        break;
        case REPRESENTATION_AS_XML_STRING:
        scdr << m_string_representation;
        break;
        default:
        break;
    }
}

void dds::xrce::OBJK_Representation2Formats::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
        dcdr >> m_object_name;
        break;
        case REPRESENTATION_AS_XML_STRING:
        dcdr >> m_string_representation;
        break;
        default:
        break;
    }
}


dds::xrce::OBJK_Representation2_Base::OBJK_Representation2_Base()
{
}

dds::xrce::OBJK_Representation2_Base::~OBJK_Representation2_Base()
{
}

dds::xrce::OBJK_Representation2_Base::OBJK_Representation2_Base(const OBJK_Representation2_Base &x)
{
    m_representation = x.m_representation;
}

dds::xrce::OBJK_Representation2_Base::OBJK_Representation2_Base(OBJK_Representation2_Base &&x)
{
    m_representation = std::move(x.m_representation);
}

dds::xrce::OBJK_Representation2_Base& dds::xrce::OBJK_Representation2_Base::operator=(const OBJK_Representation2_Base &x)
{
    m_representation = x.m_representation;
    
    return *this;
}

dds::xrce::OBJK_Representation2_Base& dds::xrce::OBJK_Representation2_Base::operator=(OBJK_Representation2_Base &&x)
{
    m_representation = std::move(x.m_representation);
    
    return *this;
}

size_t dds::xrce::OBJK_Representation2_Base::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::OBJK_Representation2Formats::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t dds::xrce::OBJK_Representation2_Base::getCdrSerializedSize(const dds::xrce::OBJK_Representation2_Base& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::OBJK_Representation2Formats::getCdrSerializedSize(data.representation(), current_alignment);

    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_Representation2_Base::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_representation;
}

void dds::xrce::OBJK_Representation2_Base::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_representation;
}

size_t dds::xrce::OBJK_Representation2_Base::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

    return current_align;
}

bool dds::xrce::OBJK_Representation2_Base::isKeyDefined()
{
    return false;
}

void dds::xrce::OBJK_Representation2_Base::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
}
dds::xrce::OBJK_Representation3_Base::OBJK_Representation3_Base()
{
}

dds::xrce::OBJK_Representation3_Base::~OBJK_Representation3_Base()
{
}

dds::xrce::OBJK_Representation3_Base::OBJK_Representation3_Base(const OBJK_Representation3_Base &x)
{
    m_representation = x.m_representation;
}

dds::xrce::OBJK_Representation3_Base::OBJK_Representation3_Base(OBJK_Representation3_Base &&x)
{
    m_representation = std::move(x.m_representation);
}

dds::xrce::OBJK_Representation3_Base& dds::xrce::OBJK_Representation3_Base::operator=(const OBJK_Representation3_Base &x)
{
    m_representation = x.m_representation;
    
    return *this;
}

dds::xrce::OBJK_Representation3_Base& dds::xrce::OBJK_Representation3_Base::operator=(OBJK_Representation3_Base &&x)
{
    m_representation = std::move(x.m_representation);
    
    return *this;
}

size_t dds::xrce::OBJK_Representation3_Base::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::OBJK_Representation3Formats::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t dds::xrce::OBJK_Representation3_Base::getCdrSerializedSize(const dds::xrce::OBJK_Representation3_Base& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::OBJK_Representation3Formats::getCdrSerializedSize(data.representation(), current_alignment);

    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_Representation3_Base::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_representation;
}

void dds::xrce::OBJK_Representation3_Base::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_representation;
}

size_t dds::xrce::OBJK_Representation3_Base::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

    return current_align;
}

bool dds::xrce::OBJK_Representation3_Base::isKeyDefined()
{
    return false;
}

void dds::xrce::OBJK_Representation3_Base::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
}
dds::xrce::OBJK_QOSPROFILE_Representation::OBJK_QOSPROFILE_Representation()
{
}

dds::xrce::OBJK_QOSPROFILE_Representation::~OBJK_QOSPROFILE_Representation()
{
}

dds::xrce::OBJK_QOSPROFILE_Representation::OBJK_QOSPROFILE_Representation(const OBJK_QOSPROFILE_Representation &x)
{
    m_base_representation = x.m_base_representation;
}

dds::xrce::OBJK_QOSPROFILE_Representation::OBJK_QOSPROFILE_Representation(OBJK_QOSPROFILE_Representation &&x)
{
    m_base_representation = std::move(x.m_base_representation);
}

dds::xrce::OBJK_QOSPROFILE_Representation& dds::xrce::OBJK_QOSPROFILE_Representation::operator=(const OBJK_QOSPROFILE_Representation &x)
{
    m_base_representation = x.m_base_representation;
    
    return *this;
}

dds::xrce::OBJK_QOSPROFILE_Representation& dds::xrce::OBJK_QOSPROFILE_Representation::operator=(OBJK_QOSPROFILE_Representation &&x)
{
    m_base_representation = std::move(x.m_base_representation);
    
    return *this;
}

size_t dds::xrce::OBJK_QOSPROFILE_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::OBJK_Representation2_Base::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t dds::xrce::OBJK_QOSPROFILE_Representation::getCdrSerializedSize(const dds::xrce::OBJK_QOSPROFILE_Representation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::OBJK_Representation2_Base::getCdrSerializedSize(data.base_representation(), current_alignment);

    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_QOSPROFILE_Representation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_base_representation;
}

void dds::xrce::OBJK_QOSPROFILE_Representation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_base_representation;
}

size_t dds::xrce::OBJK_QOSPROFILE_Representation::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

    return current_align;
}

bool dds::xrce::OBJK_QOSPROFILE_Representation::isKeyDefined()
{
    return false;
}

void dds::xrce::OBJK_QOSPROFILE_Representation::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
}
dds::xrce::OBJK_APPLICATION_Representation::OBJK_APPLICATION_Representation()
{
}

dds::xrce::OBJK_APPLICATION_Representation::~OBJK_APPLICATION_Representation()
{
}

dds::xrce::OBJK_APPLICATION_Representation::OBJK_APPLICATION_Representation(const OBJK_APPLICATION_Representation &x)
{
    m_base_representation = x.m_base_representation;
}

dds::xrce::OBJK_APPLICATION_Representation::OBJK_APPLICATION_Representation(OBJK_APPLICATION_Representation &&x)
{
    m_base_representation = std::move(x.m_base_representation);
}

dds::xrce::OBJK_APPLICATION_Representation& dds::xrce::OBJK_APPLICATION_Representation::operator=(const OBJK_APPLICATION_Representation &x)
{
    m_base_representation = x.m_base_representation;
    
    return *this;
}

dds::xrce::OBJK_APPLICATION_Representation& dds::xrce::OBJK_APPLICATION_Representation::operator=(OBJK_APPLICATION_Representation &&x)
{
    m_base_representation = std::move(x.m_base_representation);
    
    return *this;
}

size_t dds::xrce::OBJK_APPLICATION_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::OBJK_Representation2_Base::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t dds::xrce::OBJK_APPLICATION_Representation::getCdrSerializedSize(const dds::xrce::OBJK_APPLICATION_Representation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::OBJK_Representation2_Base::getCdrSerializedSize(data.base_representation(), current_alignment);

    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_APPLICATION_Representation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_base_representation;
}

void dds::xrce::OBJK_APPLICATION_Representation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_base_representation;
}

size_t dds::xrce::OBJK_APPLICATION_Representation::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

    return current_align;
}

bool dds::xrce::OBJK_APPLICATION_Representation::isKeyDefined()
{
    return false;
}

void dds::xrce::OBJK_APPLICATION_Representation::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
}
dds::xrce::OBJK_PARTICIPANT_Representation::OBJK_PARTICIPANT_Representation()
{
}

dds::xrce::OBJK_PARTICIPANT_Representation::~OBJK_PARTICIPANT_Representation()
{
}

dds::xrce::OBJK_PARTICIPANT_Representation::OBJK_PARTICIPANT_Representation(const OBJK_PARTICIPANT_Representation &x)
{
    m_base_representation = x.m_base_representation;
}

dds::xrce::OBJK_PARTICIPANT_Representation::OBJK_PARTICIPANT_Representation(OBJK_PARTICIPANT_Representation &&x)
{
    m_base_representation = std::move(x.m_base_representation);
}

dds::xrce::OBJK_PARTICIPANT_Representation& dds::xrce::OBJK_PARTICIPANT_Representation::operator=(const OBJK_PARTICIPANT_Representation &x)
{
    m_base_representation = x.m_base_representation;
    
    return *this;
}

dds::xrce::OBJK_PARTICIPANT_Representation& dds::xrce::OBJK_PARTICIPANT_Representation::operator=(OBJK_PARTICIPANT_Representation &&x)
{
    m_base_representation = std::move(x.m_base_representation);
    
    return *this;
}

size_t dds::xrce::OBJK_PARTICIPANT_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::OBJK_Representation2_Base::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t dds::xrce::OBJK_PARTICIPANT_Representation::getCdrSerializedSize(const dds::xrce::OBJK_PARTICIPANT_Representation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::OBJK_Representation2_Base::getCdrSerializedSize(data.base_representation(), current_alignment);

    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_PARTICIPANT_Representation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_base_representation;
}

void dds::xrce::OBJK_PARTICIPANT_Representation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_base_representation;
}

size_t dds::xrce::OBJK_PARTICIPANT_Representation::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

    return current_align;
}

bool dds::xrce::OBJK_PARTICIPANT_Representation::isKeyDefined()
{
    return false;
}

void dds::xrce::OBJK_PARTICIPANT_Representation::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
}
dds::xrce::OBJK_TYPE_Representation::OBJK_TYPE_Representation()
{



}

dds::xrce::OBJK_TYPE_Representation::~OBJK_TYPE_Representation()
{
}

dds::xrce::OBJK_TYPE_Representation::OBJK_TYPE_Representation(const OBJK_TYPE_Representation &x)
{
    m_base_representation = x.m_base_representation;
    m_participant_id = x.m_participant_id;
    m_registered_type_name = x.m_registered_type_name;
}

dds::xrce::OBJK_TYPE_Representation::OBJK_TYPE_Representation(OBJK_TYPE_Representation &&x)
{
    m_base_representation = std::move(x.m_base_representation);
    m_participant_id = std::move(x.m_participant_id);
    m_registered_type_name = std::move(x.m_registered_type_name);
}

dds::xrce::OBJK_TYPE_Representation& dds::xrce::OBJK_TYPE_Representation::operator=(const OBJK_TYPE_Representation &x)
{
    m_base_representation = x.m_base_representation;
    m_participant_id = x.m_participant_id;
    m_registered_type_name = x.m_registered_type_name;
    
    return *this;
}

dds::xrce::OBJK_TYPE_Representation& dds::xrce::OBJK_TYPE_Representation::operator=(OBJK_TYPE_Representation &&x)
{
    m_base_representation = std::move(x.m_base_representation);
    m_participant_id = std::move(x.m_participant_id);
    m_registered_type_name = std::move(x.m_registered_type_name);
    
    return *this;
}

size_t dds::xrce::OBJK_TYPE_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::OBJK_Representation2_Base::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t dds::xrce::OBJK_TYPE_Representation::getCdrSerializedSize(const dds::xrce::OBJK_TYPE_Representation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::OBJK_Representation2_Base::getCdrSerializedSize(data.base_representation(), current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.registered_type_name().size() + 1;


    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_TYPE_Representation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_base_representation;
    scdr << m_participant_id;
    scdr << m_registered_type_name;
}

void dds::xrce::OBJK_TYPE_Representation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_base_representation;
    dcdr >> m_participant_id;
    dcdr >> m_registered_type_name;
}

size_t dds::xrce::OBJK_TYPE_Representation::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool dds::xrce::OBJK_TYPE_Representation::isKeyDefined()
{
    return false;
}

void dds::xrce::OBJK_TYPE_Representation::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
	 
}
dds::xrce::OBJK_TOPIC_Representation::OBJK_TOPIC_Representation()
{


}

dds::xrce::OBJK_TOPIC_Representation::~OBJK_TOPIC_Representation()
{
}

dds::xrce::OBJK_TOPIC_Representation::OBJK_TOPIC_Representation(const OBJK_TOPIC_Representation &x)
{
    m_base_representation = x.m_base_representation;
    m_participant_id = x.m_participant_id;
}

dds::xrce::OBJK_TOPIC_Representation::OBJK_TOPIC_Representation(OBJK_TOPIC_Representation &&x)
{
    m_base_representation = std::move(x.m_base_representation);
    m_participant_id = std::move(x.m_participant_id);
}

dds::xrce::OBJK_TOPIC_Representation& dds::xrce::OBJK_TOPIC_Representation::operator=(const OBJK_TOPIC_Representation &x)
{
    m_base_representation = x.m_base_representation;
    m_participant_id = x.m_participant_id;
    
    return *this;
}

dds::xrce::OBJK_TOPIC_Representation& dds::xrce::OBJK_TOPIC_Representation::operator=(OBJK_TOPIC_Representation &&x)
{
    m_base_representation = std::move(x.m_base_representation);
    m_participant_id = std::move(x.m_participant_id);
    
    return *this;
}

size_t dds::xrce::OBJK_TOPIC_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::OBJK_Representation3_Base::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t dds::xrce::OBJK_TOPIC_Representation::getCdrSerializedSize(const dds::xrce::OBJK_TOPIC_Representation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::OBJK_Representation3_Base::getCdrSerializedSize(data.base_representation(), current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_TOPIC_Representation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_base_representation;
    scdr << m_participant_id;
}

void dds::xrce::OBJK_TOPIC_Representation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_base_representation;
    dcdr >> m_participant_id;
}

size_t dds::xrce::OBJK_TOPIC_Representation::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool dds::xrce::OBJK_TOPIC_Representation::isKeyDefined()
{
    return false;
}

void dds::xrce::OBJK_TOPIC_Representation::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}
dds::xrce::OBJK_PUB_Representation::OBJK_PUB_Representation()
{


}

dds::xrce::OBJK_PUB_Representation::~OBJK_PUB_Representation()
{
}

dds::xrce::OBJK_PUB_Representation::OBJK_PUB_Representation(const OBJK_PUB_Representation &x)
{
    m_base_representation = x.m_base_representation;
    m_participant_id = x.m_participant_id;
}

dds::xrce::OBJK_PUB_Representation::OBJK_PUB_Representation(OBJK_PUB_Representation &&x)
{
    m_base_representation = std::move(x.m_base_representation);
    m_participant_id = std::move(x.m_participant_id);
}

dds::xrce::OBJK_PUB_Representation& dds::xrce::OBJK_PUB_Representation::operator=(const OBJK_PUB_Representation &x)
{
    m_base_representation = x.m_base_representation;
    m_participant_id = x.m_participant_id;
    
    return *this;
}

dds::xrce::OBJK_PUB_Representation& dds::xrce::OBJK_PUB_Representation::operator=(OBJK_PUB_Representation &&x)
{
    m_base_representation = std::move(x.m_base_representation);
    m_participant_id = std::move(x.m_participant_id);
    
    return *this;
}

size_t dds::xrce::OBJK_PUB_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::OBJK_Representation3_Base::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t dds::xrce::OBJK_PUB_Representation::getCdrSerializedSize(const dds::xrce::OBJK_PUB_Representation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::OBJK_Representation3_Base::getCdrSerializedSize(data.base_representation(), current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_PUB_Representation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_base_representation;
    scdr << m_participant_id;
}

void dds::xrce::OBJK_PUB_Representation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_base_representation;
    dcdr >> m_participant_id;
}

size_t dds::xrce::OBJK_PUB_Representation::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool dds::xrce::OBJK_PUB_Representation::isKeyDefined()
{
    return false;
}

void dds::xrce::OBJK_PUB_Representation::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}
dds::xrce::OBJK_SUB_Representation::OBJK_SUB_Representation()
{


}

dds::xrce::OBJK_SUB_Representation::~OBJK_SUB_Representation()
{
}

dds::xrce::OBJK_SUB_Representation::OBJK_SUB_Representation(const OBJK_SUB_Representation &x)
{
    m_base_representation = x.m_base_representation;
    m_participant_id = x.m_participant_id;
}

dds::xrce::OBJK_SUB_Representation::OBJK_SUB_Representation(OBJK_SUB_Representation &&x)
{
    m_base_representation = std::move(x.m_base_representation);
    m_participant_id = std::move(x.m_participant_id);
}

dds::xrce::OBJK_SUB_Representation& dds::xrce::OBJK_SUB_Representation::operator=(const OBJK_SUB_Representation &x)
{
    m_base_representation = x.m_base_representation;
    m_participant_id = x.m_participant_id;
    
    return *this;
}

dds::xrce::OBJK_SUB_Representation& dds::xrce::OBJK_SUB_Representation::operator=(OBJK_SUB_Representation &&x)
{
    m_base_representation = std::move(x.m_base_representation);
    m_participant_id = std::move(x.m_participant_id);
    
    return *this;
}

size_t dds::xrce::OBJK_SUB_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::OBJK_Representation3_Base::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t dds::xrce::OBJK_SUB_Representation::getCdrSerializedSize(const dds::xrce::OBJK_SUB_Representation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::OBJK_Representation3_Base::getCdrSerializedSize(data.base_representation(), current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_SUB_Representation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_base_representation;
    scdr << m_participant_id;
}

void dds::xrce::OBJK_SUB_Representation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_base_representation;
    dcdr >> m_participant_id;
}

size_t dds::xrce::OBJK_SUB_Representation::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool dds::xrce::OBJK_SUB_Representation::isKeyDefined()
{
    return false;
}

void dds::xrce::OBJK_SUB_Representation::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}
dds::xrce::OBJK_DW_Representation::OBJK_DW_Representation()
{



}

dds::xrce::OBJK_DW_Representation::~OBJK_DW_Representation()
{
}

dds::xrce::OBJK_DW_Representation::OBJK_DW_Representation(const OBJK_DW_Representation &x)
{
    m_base_representation = x.m_base_representation;
    m_participant_id = x.m_participant_id;
    m_publisher_id = x.m_publisher_id;
}

dds::xrce::OBJK_DW_Representation::OBJK_DW_Representation(OBJK_DW_Representation &&x)
{
    m_base_representation = std::move(x.m_base_representation);
    m_participant_id = std::move(x.m_participant_id);
    m_publisher_id = std::move(x.m_publisher_id);
}

dds::xrce::OBJK_DW_Representation& dds::xrce::OBJK_DW_Representation::operator=(const OBJK_DW_Representation &x)
{
    m_base_representation = x.m_base_representation;
    m_participant_id = x.m_participant_id;
    m_publisher_id = x.m_publisher_id;
    
    return *this;
}

dds::xrce::OBJK_DW_Representation& dds::xrce::OBJK_DW_Representation::operator=(OBJK_DW_Representation &&x)
{
    m_base_representation = std::move(x.m_base_representation);
    m_participant_id = std::move(x.m_participant_id);
    m_publisher_id = std::move(x.m_publisher_id);
    
    return *this;
}

size_t dds::xrce::OBJK_DW_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::OBJK_Representation3_Base::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t dds::xrce::OBJK_DW_Representation::getCdrSerializedSize(const dds::xrce::OBJK_DW_Representation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::OBJK_Representation3_Base::getCdrSerializedSize(data.base_representation(), current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_DW_Representation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_base_representation;
    scdr << m_participant_id;
    scdr << m_publisher_id;
}

void dds::xrce::OBJK_DW_Representation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_base_representation;
    dcdr >> m_participant_id;
    dcdr >> m_publisher_id;
}

size_t dds::xrce::OBJK_DW_Representation::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool dds::xrce::OBJK_DW_Representation::isKeyDefined()
{
    return false;
}

void dds::xrce::OBJK_DW_Representation::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
	 
}
dds::xrce::OBJK_DR_Representation::OBJK_DR_Representation()
{



}

dds::xrce::OBJK_DR_Representation::~OBJK_DR_Representation()
{
}

dds::xrce::OBJK_DR_Representation::OBJK_DR_Representation(const OBJK_DR_Representation &x)
{
    m_base_representation = x.m_base_representation;
    m_participant_id = x.m_participant_id;
    m_subscriber_id = x.m_subscriber_id;
}

dds::xrce::OBJK_DR_Representation::OBJK_DR_Representation(OBJK_DR_Representation &&x)
{
    m_base_representation = std::move(x.m_base_representation);
    m_participant_id = std::move(x.m_participant_id);
    m_subscriber_id = std::move(x.m_subscriber_id);
}

dds::xrce::OBJK_DR_Representation& dds::xrce::OBJK_DR_Representation::operator=(const OBJK_DR_Representation &x)
{
    m_base_representation = x.m_base_representation;
    m_participant_id = x.m_participant_id;
    m_subscriber_id = x.m_subscriber_id;
    
    return *this;
}

dds::xrce::OBJK_DR_Representation& dds::xrce::OBJK_DR_Representation::operator=(OBJK_DR_Representation &&x)
{
    m_base_representation = std::move(x.m_base_representation);
    m_participant_id = std::move(x.m_participant_id);
    m_subscriber_id = std::move(x.m_subscriber_id);
    
    return *this;
}

size_t dds::xrce::OBJK_DR_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::OBJK_Representation3_Base::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t dds::xrce::OBJK_DR_Representation::getCdrSerializedSize(const dds::xrce::OBJK_DR_Representation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::OBJK_Representation3_Base::getCdrSerializedSize(data.base_representation(), current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_DR_Representation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_base_representation;
    scdr << m_participant_id;
    scdr << m_subscriber_id;
}

void dds::xrce::OBJK_DR_Representation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_base_representation;
    dcdr >> m_participant_id;
    dcdr >> m_subscriber_id;
}

size_t dds::xrce::OBJK_DR_Representation::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool dds::xrce::OBJK_DR_Representation::isKeyDefined()
{
    return false;
}

void dds::xrce::OBJK_DR_Representation::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
	 
}
dds::xrce::OBJK_Type_Binary::OBJK_Type_Binary()
{
}

dds::xrce::OBJK_Type_Binary::~OBJK_Type_Binary()
{
}

dds::xrce::OBJK_Type_Binary::OBJK_Type_Binary(const OBJK_Type_Binary &x)
{
    m_type_name = x.m_type_name;
}

dds::xrce::OBJK_Type_Binary::OBJK_Type_Binary(OBJK_Type_Binary &&x)
{
    m_type_name = std::move(x.m_type_name);
}

dds::xrce::OBJK_Type_Binary& dds::xrce::OBJK_Type_Binary::operator=(const OBJK_Type_Binary &x)
{
    m_type_name = x.m_type_name;
    
    return *this;
}

dds::xrce::OBJK_Type_Binary& dds::xrce::OBJK_Type_Binary::operator=(OBJK_Type_Binary &&x)
{
    m_type_name = std::move(x.m_type_name);
    
    return *this;
}

size_t dds::xrce::OBJK_Type_Binary::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    return current_alignment - initial_alignment;
}

size_t dds::xrce::OBJK_Type_Binary::getCdrSerializedSize(const dds::xrce::OBJK_Type_Binary& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type_name().size() + 1;

    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_Type_Binary::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_type_name;
}

void dds::xrce::OBJK_Type_Binary::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_type_name;
}

size_t dds::xrce::OBJK_Type_Binary::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

    return current_align;
}

bool dds::xrce::OBJK_Type_Binary::isKeyDefined()
{
    return false;
}

void dds::xrce::OBJK_Type_Binary::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
}
dds::xrce::OBJK_Topic_QosBinary::OBJK_Topic_QosBinary()
{


}

dds::xrce::OBJK_Topic_QosBinary::~OBJK_Topic_QosBinary()
{
}

dds::xrce::OBJK_Topic_QosBinary::OBJK_Topic_QosBinary(const OBJK_Topic_QosBinary &x)
{
    m_topic_name = x.m_topic_name;
    m_type_name = x.m_type_name;
}

dds::xrce::OBJK_Topic_QosBinary::OBJK_Topic_QosBinary(OBJK_Topic_QosBinary &&x)
{
    m_topic_name = std::move(x.m_topic_name);
    m_type_name = std::move(x.m_type_name);
}

dds::xrce::OBJK_Topic_QosBinary& dds::xrce::OBJK_Topic_QosBinary::operator=(const OBJK_Topic_QosBinary &x)
{
    m_topic_name = x.m_topic_name;
    m_type_name = x.m_type_name;
    
    return *this;
}

dds::xrce::OBJK_Topic_QosBinary& dds::xrce::OBJK_Topic_QosBinary::operator=(OBJK_Topic_QosBinary &&x)
{
    m_topic_name = std::move(x.m_topic_name);
    m_type_name = std::move(x.m_type_name);
    
    return *this;
}

size_t dds::xrce::OBJK_Topic_QosBinary::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t dds::xrce::OBJK_Topic_QosBinary::getCdrSerializedSize(const dds::xrce::OBJK_Topic_QosBinary& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.topic_name().size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.type_name().size() + 1;


    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_Topic_QosBinary::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_topic_name;
    scdr << m_type_name;
}

void dds::xrce::OBJK_Topic_QosBinary::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_topic_name;
    dcdr >> m_type_name;
}

size_t dds::xrce::OBJK_Topic_QosBinary::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool dds::xrce::OBJK_Topic_QosBinary::isKeyDefined()
{
    return false;
}

void dds::xrce::OBJK_Topic_QosBinary::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}
dds::xrce::OBJK_PUB_QosBinary::OBJK_PUB_QosBinary()
{


}

dds::xrce::OBJK_PUB_QosBinary::~OBJK_PUB_QosBinary()
{
}

dds::xrce::OBJK_PUB_QosBinary::OBJK_PUB_QosBinary(const OBJK_PUB_QosBinary &x)
{
    m_partitions = x.m_partitions;
    m_group_data = x.m_group_data;
}

dds::xrce::OBJK_PUB_QosBinary::OBJK_PUB_QosBinary(OBJK_PUB_QosBinary &&x)
{
    m_partitions = std::move(x.m_partitions);
    m_group_data = std::move(x.m_group_data);
}

dds::xrce::OBJK_PUB_QosBinary& dds::xrce::OBJK_PUB_QosBinary::operator=(const OBJK_PUB_QosBinary &x)
{
    m_partitions = x.m_partitions;
    m_group_data = x.m_group_data;
    
    return *this;
}

dds::xrce::OBJK_PUB_QosBinary& dds::xrce::OBJK_PUB_QosBinary::operator=(OBJK_PUB_QosBinary &&x)
{
    m_partitions = std::move(x.m_partitions);
    m_group_data = std::move(x.m_group_data);
    
    return *this;
}

size_t dds::xrce::OBJK_PUB_QosBinary::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;
    }
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t dds::xrce::OBJK_PUB_QosBinary::getCdrSerializedSize(const dds::xrce::OBJK_PUB_QosBinary& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.partitions().size(); ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.partitions().at(a).size() + 1;
    }
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.group_data().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_PUB_QosBinary::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_partitions;
    scdr << m_group_data;
}

void dds::xrce::OBJK_PUB_QosBinary::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_partitions;
    dcdr >> m_group_data;
}

size_t dds::xrce::OBJK_PUB_QosBinary::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool dds::xrce::OBJK_PUB_QosBinary::isKeyDefined()
{
    return false;
}

void dds::xrce::OBJK_PUB_QosBinary::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}
dds::xrce::OBJK_SUB_QosBinary::OBJK_SUB_QosBinary()
{


}

dds::xrce::OBJK_SUB_QosBinary::~OBJK_SUB_QosBinary()
{
}

dds::xrce::OBJK_SUB_QosBinary::OBJK_SUB_QosBinary(const OBJK_SUB_QosBinary &x)
{
    m_partitions = x.m_partitions;
    m_group_data = x.m_group_data;
}

dds::xrce::OBJK_SUB_QosBinary::OBJK_SUB_QosBinary(OBJK_SUB_QosBinary &&x)
{
    m_partitions = std::move(x.m_partitions);
    m_group_data = std::move(x.m_group_data);
}

dds::xrce::OBJK_SUB_QosBinary& dds::xrce::OBJK_SUB_QosBinary::operator=(const OBJK_SUB_QosBinary &x)
{
    m_partitions = x.m_partitions;
    m_group_data = x.m_group_data;
    
    return *this;
}

dds::xrce::OBJK_SUB_QosBinary& dds::xrce::OBJK_SUB_QosBinary::operator=(OBJK_SUB_QosBinary &&x)
{
    m_partitions = std::move(x.m_partitions);
    m_group_data = std::move(x.m_group_data);
    
    return *this;
}

size_t dds::xrce::OBJK_SUB_QosBinary::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;
    }
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t dds::xrce::OBJK_SUB_QosBinary::getCdrSerializedSize(const dds::xrce::OBJK_SUB_QosBinary& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.partitions().size(); ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.partitions().at(a).size() + 1;
    }
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.group_data().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_SUB_QosBinary::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_partitions;
    scdr << m_group_data;
}

void dds::xrce::OBJK_SUB_QosBinary::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_partitions;
    dcdr >> m_group_data;
}

size_t dds::xrce::OBJK_SUB_QosBinary::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool dds::xrce::OBJK_SUB_QosBinary::isKeyDefined()
{
    return false;
}

void dds::xrce::OBJK_SUB_QosBinary::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}

dds::xrce::OBJK_Endpoint_QosBinary::OBJK_Endpoint_QosBinary()
{
    m_qos_flags = dds::xrce::is_reliable;
    m_history_depth = 0;
    m_deadline_msec = 0;
    m_lifespan_msec = 0;

}

dds::xrce::OBJK_Endpoint_QosBinary::~OBJK_Endpoint_QosBinary()
{
}

dds::xrce::OBJK_Endpoint_QosBinary::OBJK_Endpoint_QosBinary(const OBJK_Endpoint_QosBinary &x)
{
    m_qos_flags = x.m_qos_flags;
    m_history_depth = x.m_history_depth;
    m_deadline_msec = x.m_deadline_msec;
    m_lifespan_msec = x.m_lifespan_msec;
    m_user_data = x.m_user_data;
}

dds::xrce::OBJK_Endpoint_QosBinary::OBJK_Endpoint_QosBinary(OBJK_Endpoint_QosBinary &&x)
{
    m_qos_flags = x.m_qos_flags;
    m_history_depth = x.m_history_depth;
    m_deadline_msec = x.m_deadline_msec;
    m_lifespan_msec = x.m_lifespan_msec;
    m_user_data = std::move(x.m_user_data);
}

dds::xrce::OBJK_Endpoint_QosBinary& dds::xrce::OBJK_Endpoint_QosBinary::operator=(const OBJK_Endpoint_QosBinary &x)
{
    m_qos_flags = x.m_qos_flags;
    m_history_depth = x.m_history_depth;
    m_deadline_msec = x.m_deadline_msec;
    m_lifespan_msec = x.m_lifespan_msec;
    m_user_data = x.m_user_data;
    
    return *this;
}

dds::xrce::OBJK_Endpoint_QosBinary& dds::xrce::OBJK_Endpoint_QosBinary::operator=(OBJK_Endpoint_QosBinary &&x)
{
    m_qos_flags = x.m_qos_flags;
    m_history_depth = x.m_history_depth;
    m_deadline_msec = x.m_deadline_msec;
    m_lifespan_msec = x.m_lifespan_msec;
    m_user_data = std::move(x.m_user_data);
    
    return *this;
}

size_t dds::xrce::OBJK_Endpoint_QosBinary::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

size_t dds::xrce::OBJK_Endpoint_QosBinary::getCdrSerializedSize(const dds::xrce::OBJK_Endpoint_QosBinary& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.user_data().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);



    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_Endpoint_QosBinary::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << (uint32_t)m_qos_flags;
    scdr << m_history_depth;
    scdr << m_deadline_msec;
    scdr << m_lifespan_msec;
    scdr << m_user_data;
}

void dds::xrce::OBJK_Endpoint_QosBinary::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> (uint32_t&)m_qos_flags;
    dcdr >> m_history_depth;
    dcdr >> m_deadline_msec;
    dcdr >> m_lifespan_msec;
    dcdr >> m_user_data;
}

size_t dds::xrce::OBJK_Endpoint_QosBinary::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            






    return current_align;
}

bool dds::xrce::OBJK_Endpoint_QosBinary::isKeyDefined()
{
    return false;
}

void dds::xrce::OBJK_Endpoint_QosBinary::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
	 
	 
	 
}
dds::xrce::OBJK_DataReader_Binary::OBJK_DataReader_Binary()
{


    m_timebasedfilter_msec = 0;

}

dds::xrce::OBJK_DataReader_Binary::~OBJK_DataReader_Binary()
{
}

dds::xrce::OBJK_DataReader_Binary::OBJK_DataReader_Binary(const OBJK_DataReader_Binary &x)
{
    m_topic_name = x.m_topic_name;
    m_endpoint_qos = x.m_endpoint_qos;
    m_timebasedfilter_msec = x.m_timebasedfilter_msec;
    m_contentbased_filter = x.m_contentbased_filter;
}

dds::xrce::OBJK_DataReader_Binary::OBJK_DataReader_Binary(OBJK_DataReader_Binary &&x)
{
    m_topic_name = std::move(x.m_topic_name);
    m_endpoint_qos = std::move(x.m_endpoint_qos);
    m_timebasedfilter_msec = x.m_timebasedfilter_msec;
    m_contentbased_filter = std::move(x.m_contentbased_filter);
}

dds::xrce::OBJK_DataReader_Binary& dds::xrce::OBJK_DataReader_Binary::operator=(const OBJK_DataReader_Binary &x)
{
    m_topic_name = x.m_topic_name;
    m_endpoint_qos = x.m_endpoint_qos;
    m_timebasedfilter_msec = x.m_timebasedfilter_msec;
    m_contentbased_filter = x.m_contentbased_filter;
    
    return *this;
}

dds::xrce::OBJK_DataReader_Binary& dds::xrce::OBJK_DataReader_Binary::operator=(OBJK_DataReader_Binary &&x)
{
    m_topic_name = std::move(x.m_topic_name);
    m_endpoint_qos = std::move(x.m_endpoint_qos);
    m_timebasedfilter_msec = x.m_timebasedfilter_msec;
    m_contentbased_filter = std::move(x.m_contentbased_filter);
    
    return *this;
}

size_t dds::xrce::OBJK_DataReader_Binary::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += dds::xrce::OBJK_Endpoint_QosBinary::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t dds::xrce::OBJK_DataReader_Binary::getCdrSerializedSize(const dds::xrce::OBJK_DataReader_Binary& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.topic_name().size() + 1;

    current_alignment += dds::xrce::OBJK_Endpoint_QosBinary::getCdrSerializedSize(data.endpoint_qos(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.contentbased_filter().size() + 1;


    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_DataReader_Binary::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_topic_name;
    scdr << m_endpoint_qos;
    scdr << m_timebasedfilter_msec;
    scdr << m_contentbased_filter;
}

void dds::xrce::OBJK_DataReader_Binary::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_topic_name;
    dcdr >> m_endpoint_qos;
    dcdr >> m_timebasedfilter_msec;
    dcdr >> m_contentbased_filter;
}

size_t dds::xrce::OBJK_DataReader_Binary::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            





    return current_align;
}

bool dds::xrce::OBJK_DataReader_Binary::isKeyDefined()
{
    return false;
}

void dds::xrce::OBJK_DataReader_Binary::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
	 
	 
}
dds::xrce::OBJK_DataWriter_Binary::OBJK_DataWriter_Binary()
{


    m_ownership_strength = 0;
}

dds::xrce::OBJK_DataWriter_Binary::~OBJK_DataWriter_Binary()
{
}

dds::xrce::OBJK_DataWriter_Binary::OBJK_DataWriter_Binary(const OBJK_DataWriter_Binary &x)
{
    m_topic_name = x.m_topic_name;
    m_endpoint_qos = x.m_endpoint_qos;
    m_ownership_strength = x.m_ownership_strength;
}

dds::xrce::OBJK_DataWriter_Binary::OBJK_DataWriter_Binary(OBJK_DataWriter_Binary &&x)
{
    m_topic_name = std::move(x.m_topic_name);
    m_endpoint_qos = std::move(x.m_endpoint_qos);
    m_ownership_strength = x.m_ownership_strength;
}

dds::xrce::OBJK_DataWriter_Binary& dds::xrce::OBJK_DataWriter_Binary::operator=(const OBJK_DataWriter_Binary &x)
{
    m_topic_name = x.m_topic_name;
    m_endpoint_qos = x.m_endpoint_qos;
    m_ownership_strength = x.m_ownership_strength;
    
    return *this;
}

dds::xrce::OBJK_DataWriter_Binary& dds::xrce::OBJK_DataWriter_Binary::operator=(OBJK_DataWriter_Binary &&x)
{
    m_topic_name = std::move(x.m_topic_name);
    m_endpoint_qos = std::move(x.m_endpoint_qos);
    m_ownership_strength = x.m_ownership_strength;
    
    return *this;
}

size_t dds::xrce::OBJK_DataWriter_Binary::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += dds::xrce::OBJK_Endpoint_QosBinary::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t dds::xrce::OBJK_DataWriter_Binary::getCdrSerializedSize(const dds::xrce::OBJK_DataWriter_Binary& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.topic_name().size() + 1;

    current_alignment += dds::xrce::OBJK_Endpoint_QosBinary::getCdrSerializedSize(data.endpoint_qos(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_DataWriter_Binary::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_topic_name;
    scdr << m_endpoint_qos;
    scdr << m_ownership_strength;
}

void dds::xrce::OBJK_DataWriter_Binary::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_topic_name;
    dcdr >> m_endpoint_qos;
    dcdr >> m_ownership_strength;
}

size_t dds::xrce::OBJK_DataWriter_Binary::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool dds::xrce::OBJK_DataWriter_Binary::isKeyDefined()
{
    return false;
}

void dds::xrce::OBJK_DataWriter_Binary::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
	 
}
dds::xrce::ObjectVariant::ObjectVariant()
{
    m__d = OBJK_CLIENT;










}

dds::xrce::ObjectVariant::~ObjectVariant()
{
}

dds::xrce::ObjectVariant::ObjectVariant(const ObjectVariant &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case OBJK_CLIENT:
        m_client = x.m_client;
        break;
        case OBJK_APP:
        m_application = x.m_application;
        break;
        case OBJK_PARTICIPANT:
        m_participant = x.m_participant;
        break;
        case OBJK_QOSPROFILE:
        m_qos_profile = x.m_qos_profile;
        break;
        case OBJK_TYPE:
        m_type = x.m_type;
        break;
        case OBJK_TOPIC:
        m_topic = x.m_topic;
        break;
        case OBJK_PUBLISHER:
        m_publisher = x.m_publisher;
        break;
        case OBJK_SUBSCRIBER:
        m_subscriber = x.m_subscriber;
        break;
        case OBJK_DATAWRITER:
        m_data_writer = x.m_data_writer;
        break;
        case OBJK_DATAREADER:
        m_data_reader = x.m_data_reader;
        break;
        default:
        break;
    }
}

dds::xrce::ObjectVariant::ObjectVariant(ObjectVariant &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case OBJK_CLIENT:
        m_client = std::move(x.m_client);
        break;
        case OBJK_APP:
        m_application = std::move(x.m_application);
        break;
        case OBJK_PARTICIPANT:
        m_participant = std::move(x.m_participant);
        break;
        case OBJK_QOSPROFILE:
        m_qos_profile = std::move(x.m_qos_profile);
        break;
        case OBJK_TYPE:
        m_type = std::move(x.m_type);
        break;
        case OBJK_TOPIC:
        m_topic = std::move(x.m_topic);
        break;
        case OBJK_PUBLISHER:
        m_publisher = std::move(x.m_publisher);
        break;
        case OBJK_SUBSCRIBER:
        m_subscriber = std::move(x.m_subscriber);
        break;
        case OBJK_DATAWRITER:
        m_data_writer = std::move(x.m_data_writer);
        break;
        case OBJK_DATAREADER:
        m_data_reader = std::move(x.m_data_reader);
        break;
        default:
        break;
    }
}

dds::xrce::ObjectVariant& dds::xrce::ObjectVariant::operator=(const ObjectVariant &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case OBJK_CLIENT:
        m_client = x.m_client;
        break;
        case OBJK_APP:
        m_application = x.m_application;
        break;
        case OBJK_PARTICIPANT:
        m_participant = x.m_participant;
        break;
        case OBJK_QOSPROFILE:
        m_qos_profile = x.m_qos_profile;
        break;
        case OBJK_TYPE:
        m_type = x.m_type;
        break;
        case OBJK_TOPIC:
        m_topic = x.m_topic;
        break;
        case OBJK_PUBLISHER:
        m_publisher = x.m_publisher;
        break;
        case OBJK_SUBSCRIBER:
        m_subscriber = x.m_subscriber;
        break;
        case OBJK_DATAWRITER:
        m_data_writer = x.m_data_writer;
        break;
        case OBJK_DATAREADER:
        m_data_reader = x.m_data_reader;
        break;
        default:
        break;
    }
    
    return *this;
}

dds::xrce::ObjectVariant& dds::xrce::ObjectVariant::operator=(ObjectVariant &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case OBJK_CLIENT:
        m_client = std::move(x.m_client);
        break;
        case OBJK_APP:
        m_application = std::move(x.m_application);
        break;
        case OBJK_PARTICIPANT:
        m_participant = std::move(x.m_participant);
        break;
        case OBJK_QOSPROFILE:
        m_qos_profile = std::move(x.m_qos_profile);
        break;
        case OBJK_TYPE:
        m_type = std::move(x.m_type);
        break;
        case OBJK_TOPIC:
        m_topic = std::move(x.m_topic);
        break;
        case OBJK_PUBLISHER:
        m_publisher = std::move(x.m_publisher);
        break;
        case OBJK_SUBSCRIBER:
        m_subscriber = std::move(x.m_subscriber);
        break;
        case OBJK_DATAWRITER:
        m_data_writer = std::move(x.m_data_writer);
        break;
        case OBJK_DATAREADER:
        m_data_reader = std::move(x.m_data_reader);
        break;
        default:
        break;
    }
    
    return *this;
}

void dds::xrce::ObjectVariant::_d(dds::xrce::ObjectKind __d)
{
    bool b = false;
    
    switch(m__d)
    {
        case OBJK_CLIENT:
        switch(__d)
        {
            case OBJK_CLIENT:
            b = true;
            break;
            default:
            break;
        }
        break;
        case OBJK_APP:
        switch(__d)
        {
            case OBJK_APP:
            b = true;
            break;
            default:
            break;
        }
        break;
        case OBJK_PARTICIPANT:
        switch(__d)
        {
            case OBJK_PARTICIPANT:
            b = true;
            break;
            default:
            break;
        }
        break;
        case OBJK_QOSPROFILE:
        switch(__d)
        {
            case OBJK_QOSPROFILE:
            b = true;
            break;
            default:
            break;
        }
        break;
        case OBJK_TYPE:
        switch(__d)
        {
            case OBJK_TYPE:
            b = true;
            break;
            default:
            break;
        }
        break;
        case OBJK_TOPIC:
        switch(__d)
        {
            case OBJK_TOPIC:
            b = true;
            break;
            default:
            break;
        }
        break;
        case OBJK_PUBLISHER:
        switch(__d)
        {
            case OBJK_PUBLISHER:
            b = true;
            break;
            default:
            break;
        }
        break;
        case OBJK_SUBSCRIBER:
        switch(__d)
        {
            case OBJK_SUBSCRIBER:
            b = true;
            break;
            default:
            break;
        }
        break;
        case OBJK_DATAWRITER:
        switch(__d)
        {
            case OBJK_DATAWRITER:
            b = true;
            break;
            default:
            break;
        }
        break;
        case OBJK_DATAREADER:
        switch(__d)
        {
            case OBJK_DATAREADER:
            b = true;
            break;
            default:
            break;
        }
        break;
    }
    
    if(!b) throw BadParamException("Discriminator doesn't correspond with the selected union member");
    
    m__d = __d;
}

dds::xrce::ObjectKind dds::xrce::ObjectVariant::_d() const
{
    return m__d;
}

dds::xrce::ObjectKind& dds::xrce::ObjectVariant::_d()
{
    return m__d;
}

void dds::xrce::ObjectVariant::client(const dds::xrce::OBJK_CLIENT_Representation &_client)
{
    m_client = _client;
    m__d = OBJK_CLIENT;
}

void dds::xrce::ObjectVariant::client(dds::xrce::OBJK_CLIENT_Representation &&_client)
{
    m_client = std::move(_client);
    m__d = OBJK_CLIENT;
}

const dds::xrce::OBJK_CLIENT_Representation& dds::xrce::ObjectVariant::client() const
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_CLIENT:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_client;
}

dds::xrce::OBJK_CLIENT_Representation& dds::xrce::ObjectVariant::client()
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_CLIENT:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_client;
}
void dds::xrce::ObjectVariant::application(const dds::xrce::OBJK_APPLICATION_Representation &_application)
{
    m_application = _application;
    m__d = OBJK_APP;
}

void dds::xrce::ObjectVariant::application(dds::xrce::OBJK_APPLICATION_Representation &&_application)
{
    m_application = std::move(_application);
    m__d = OBJK_APP;
}

const dds::xrce::OBJK_APPLICATION_Representation& dds::xrce::ObjectVariant::application() const
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_APP:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_application;
}

dds::xrce::OBJK_APPLICATION_Representation& dds::xrce::ObjectVariant::application()
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_APP:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_application;
}
void dds::xrce::ObjectVariant::participant(const dds::xrce::OBJK_PARTICIPANT_Representation &_participant)
{
    m_participant = _participant;
    m__d = OBJK_PARTICIPANT;
}

void dds::xrce::ObjectVariant::participant(dds::xrce::OBJK_PARTICIPANT_Representation &&_participant)
{
    m_participant = std::move(_participant);
    m__d = OBJK_PARTICIPANT;
}

const dds::xrce::OBJK_PARTICIPANT_Representation& dds::xrce::ObjectVariant::participant() const
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_PARTICIPANT:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_participant;
}

dds::xrce::OBJK_PARTICIPANT_Representation& dds::xrce::ObjectVariant::participant()
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_PARTICIPANT:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_participant;
}
void dds::xrce::ObjectVariant::qos_profile(const dds::xrce::OBJK_QOSPROFILE_Representation &_qos_profile)
{
    m_qos_profile = _qos_profile;
    m__d = OBJK_QOSPROFILE;
}

void dds::xrce::ObjectVariant::qos_profile(dds::xrce::OBJK_QOSPROFILE_Representation &&_qos_profile)
{
    m_qos_profile = std::move(_qos_profile);
    m__d = OBJK_QOSPROFILE;
}

const dds::xrce::OBJK_QOSPROFILE_Representation& dds::xrce::ObjectVariant::qos_profile() const
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_QOSPROFILE:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_qos_profile;
}

dds::xrce::OBJK_QOSPROFILE_Representation& dds::xrce::ObjectVariant::qos_profile()
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_QOSPROFILE:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_qos_profile;
}
void dds::xrce::ObjectVariant::type(const dds::xrce::OBJK_TYPE_Representation &_type)
{
    m_type = _type;
    m__d = OBJK_TYPE;
}

void dds::xrce::ObjectVariant::type(dds::xrce::OBJK_TYPE_Representation &&_type)
{
    m_type = std::move(_type);
    m__d = OBJK_TYPE;
}

const dds::xrce::OBJK_TYPE_Representation& dds::xrce::ObjectVariant::type() const
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_TYPE:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_type;
}

dds::xrce::OBJK_TYPE_Representation& dds::xrce::ObjectVariant::type()
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_TYPE:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_type;
}
void dds::xrce::ObjectVariant::topic(const dds::xrce::OBJK_TOPIC_Representation &_topic)
{
    m_topic = _topic;
    m__d = OBJK_TOPIC;
}

void dds::xrce::ObjectVariant::topic(dds::xrce::OBJK_TOPIC_Representation &&_topic)
{
    m_topic = std::move(_topic);
    m__d = OBJK_TOPIC;
}

const dds::xrce::OBJK_TOPIC_Representation& dds::xrce::ObjectVariant::topic() const
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_TOPIC:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_topic;
}

dds::xrce::OBJK_TOPIC_Representation& dds::xrce::ObjectVariant::topic()
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_TOPIC:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_topic;
}
void dds::xrce::ObjectVariant::publisher(const dds::xrce::OBJK_PUB_Representation &_publisher)
{
    m_publisher = _publisher;
    m__d = OBJK_PUBLISHER;
}

void dds::xrce::ObjectVariant::publisher(dds::xrce::OBJK_PUB_Representation &&_publisher)
{
    m_publisher = std::move(_publisher);
    m__d = OBJK_PUBLISHER;
}

const dds::xrce::OBJK_PUB_Representation& dds::xrce::ObjectVariant::publisher() const
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_PUBLISHER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_publisher;
}

dds::xrce::OBJK_PUB_Representation& dds::xrce::ObjectVariant::publisher()
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_PUBLISHER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_publisher;
}
void dds::xrce::ObjectVariant::subscriber(const dds::xrce::OBJK_SUB_Representation &_subscriber)
{
    m_subscriber = _subscriber;
    m__d = OBJK_SUBSCRIBER;
}

void dds::xrce::ObjectVariant::subscriber(dds::xrce::OBJK_SUB_Representation &&_subscriber)
{
    m_subscriber = std::move(_subscriber);
    m__d = OBJK_SUBSCRIBER;
}

const dds::xrce::OBJK_SUB_Representation& dds::xrce::ObjectVariant::subscriber() const
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_SUBSCRIBER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_subscriber;
}

dds::xrce::OBJK_SUB_Representation& dds::xrce::ObjectVariant::subscriber()
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_SUBSCRIBER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_subscriber;
}
void dds::xrce::ObjectVariant::data_writer(const dds::xrce::OBJK_DW_Representation &_data_writer)
{
    m_data_writer = _data_writer;
    m__d = OBJK_DATAWRITER;
}

void dds::xrce::ObjectVariant::data_writer(dds::xrce::OBJK_DW_Representation &&_data_writer)
{
    m_data_writer = std::move(_data_writer);
    m__d = OBJK_DATAWRITER;
}

const dds::xrce::OBJK_DW_Representation& dds::xrce::ObjectVariant::data_writer() const
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_DATAWRITER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_data_writer;
}

dds::xrce::OBJK_DW_Representation& dds::xrce::ObjectVariant::data_writer()
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_DATAWRITER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_data_writer;
}
void dds::xrce::ObjectVariant::data_reader(const dds::xrce::OBJK_DR_Representation &_data_reader)
{
    m_data_reader = _data_reader;
    m__d = OBJK_DATAREADER;
}

void dds::xrce::ObjectVariant::data_reader(dds::xrce::OBJK_DR_Representation &&_data_reader)
{
    m_data_reader = std::move(_data_reader);
    m__d = OBJK_DATAREADER;
}

const dds::xrce::OBJK_DR_Representation& dds::xrce::ObjectVariant::data_reader() const
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_DATAREADER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_data_reader;
}

dds::xrce::OBJK_DR_Representation& dds::xrce::ObjectVariant::data_reader()
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_DATAREADER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_data_reader;
}

size_t dds::xrce::ObjectVariant::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


        reset_alignment = current_alignment;

        reset_alignment += dds::xrce::OBJK_CLIENT_Representation::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += dds::xrce::OBJK_APPLICATION_Representation::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += dds::xrce::OBJK_PARTICIPANT_Representation::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += dds::xrce::OBJK_QOSPROFILE_Representation::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += dds::xrce::OBJK_TYPE_Representation::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += dds::xrce::OBJK_TOPIC_Representation::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += dds::xrce::OBJK_PUB_Representation::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += dds::xrce::OBJK_SUB_Representation::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += dds::xrce::OBJK_DW_Representation::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += dds::xrce::OBJK_DR_Representation::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        

    return union_max_size_serialized - initial_alignment;
}

// TODO(Ricardo) Review
size_t dds::xrce::ObjectVariant::getCdrSerializedSize(const dds::xrce::ObjectVariant& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(data.m__d)
    {
        case OBJK_CLIENT:
        current_alignment += dds::xrce::OBJK_CLIENT_Representation::getCdrSerializedSize(data.client(), current_alignment);
        break;
        case OBJK_APP:
        current_alignment += dds::xrce::OBJK_APPLICATION_Representation::getCdrSerializedSize(data.application(), current_alignment);
        break;
        case OBJK_PARTICIPANT:
        current_alignment += dds::xrce::OBJK_PARTICIPANT_Representation::getCdrSerializedSize(data.participant(), current_alignment);
        break;
        case OBJK_QOSPROFILE:
        current_alignment += dds::xrce::OBJK_QOSPROFILE_Representation::getCdrSerializedSize(data.qos_profile(), current_alignment);
        break;
        case OBJK_TYPE:
        current_alignment += dds::xrce::OBJK_TYPE_Representation::getCdrSerializedSize(data.type(), current_alignment);
        break;
        case OBJK_TOPIC:
        current_alignment += dds::xrce::OBJK_TOPIC_Representation::getCdrSerializedSize(data.topic(), current_alignment);
        break;
        case OBJK_PUBLISHER:
        current_alignment += dds::xrce::OBJK_PUB_Representation::getCdrSerializedSize(data.publisher(), current_alignment);
        break;
        case OBJK_SUBSCRIBER:
        current_alignment += dds::xrce::OBJK_SUB_Representation::getCdrSerializedSize(data.subscriber(), current_alignment);
        break;
        case OBJK_DATAWRITER:
        current_alignment += dds::xrce::OBJK_DW_Representation::getCdrSerializedSize(data.data_writer(), current_alignment);
        break;
        case OBJK_DATAREADER:
        current_alignment += dds::xrce::OBJK_DR_Representation::getCdrSerializedSize(data.data_reader(), current_alignment);
        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void dds::xrce::ObjectVariant::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case OBJK_CLIENT:
        scdr << m_client;
        break;
        case OBJK_APP:
        scdr << m_application;
        break;
        case OBJK_PARTICIPANT:
        scdr << m_participant;
        break;
        case OBJK_QOSPROFILE:
        scdr << m_qos_profile;
        break;
        case OBJK_TYPE:
        scdr << m_type;
        break;
        case OBJK_TOPIC:
        scdr << m_topic;
        break;
        case OBJK_PUBLISHER:
        scdr << m_publisher;
        break;
        case OBJK_SUBSCRIBER:
        scdr << m_subscriber;
        break;
        case OBJK_DATAWRITER:
        scdr << m_data_writer;
        break;
        case OBJK_DATAREADER:
        scdr << m_data_reader;
        break;
        default:
        break;
    }
}

void dds::xrce::ObjectVariant::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case OBJK_CLIENT:
        dcdr >> m_client;
        break;
        case OBJK_APP:
        dcdr >> m_application;
        break;
        case OBJK_PARTICIPANT:
        dcdr >> m_participant;
        break;
        case OBJK_QOSPROFILE:
        dcdr >> m_qos_profile;
        break;
        case OBJK_TYPE:
        dcdr >> m_type;
        break;
        case OBJK_TOPIC:
        dcdr >> m_topic;
        break;
        case OBJK_PUBLISHER:
        dcdr >> m_publisher;
        break;
        case OBJK_SUBSCRIBER:
        dcdr >> m_subscriber;
        break;
        case OBJK_DATAWRITER:
        dcdr >> m_data_writer;
        break;
        case OBJK_DATAREADER:
        dcdr >> m_data_reader;
        break;
        default:
        break;
    }
}


dds::xrce::CreationMode::CreationMode()
{
    m_reuse = false;
    m_replace = false;
}

dds::xrce::CreationMode::~CreationMode()
{
}

dds::xrce::CreationMode::CreationMode(const CreationMode &x)
{
    m_reuse = x.m_reuse;
    m_replace = x.m_replace;
}

dds::xrce::CreationMode::CreationMode(CreationMode &&x)
{
    m_reuse = x.m_reuse;
    m_replace = x.m_replace;
}

dds::xrce::CreationMode& dds::xrce::CreationMode::operator=(const CreationMode &x)
{
    m_reuse = x.m_reuse;
    m_replace = x.m_replace;
    
    return *this;
}

dds::xrce::CreationMode& dds::xrce::CreationMode::operator=(CreationMode &&x)
{
    m_reuse = x.m_reuse;
    m_replace = x.m_replace;
    
    return *this;
}

size_t dds::xrce::CreationMode::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t dds::xrce::CreationMode::getCdrSerializedSize(const dds::xrce::CreationMode& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void dds::xrce::CreationMode::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_reuse;
    scdr << m_replace;
}

void dds::xrce::CreationMode::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_reuse;
    dcdr >> m_replace;
}

size_t dds::xrce::CreationMode::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool dds::xrce::CreationMode::isKeyDefined()
{
    return false;
}

void dds::xrce::CreationMode::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}

dds::xrce::ResultStatus::ResultStatus()
{

    m_status = 0;
    m_implementation_status = 0;
}

dds::xrce::ResultStatus::~ResultStatus()
{
}

dds::xrce::ResultStatus::ResultStatus(const ResultStatus &x)
{
    m_request_id = x.m_request_id;
    m_status = x.m_status;
    m_implementation_status = x.m_implementation_status;
}

dds::xrce::ResultStatus::ResultStatus(ResultStatus &&x)
{
    m_request_id = std::move(x.m_request_id);
    m_status = x.m_status;
    m_implementation_status = x.m_implementation_status;
}

dds::xrce::ResultStatus& dds::xrce::ResultStatus::operator=(const ResultStatus &x)
{
    m_request_id = x.m_request_id;
    m_status = x.m_status;
    m_implementation_status = x.m_implementation_status;
    
    return *this;
}

dds::xrce::ResultStatus& dds::xrce::ResultStatus::operator=(ResultStatus &&x)
{
    m_request_id = std::move(x.m_request_id);
    m_status = x.m_status;
    m_implementation_status = x.m_implementation_status;
    
    return *this;
}

size_t dds::xrce::ResultStatus::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t dds::xrce::ResultStatus::getCdrSerializedSize(const dds::xrce::ResultStatus& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void dds::xrce::ResultStatus::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_request_id;
    scdr << m_status;
    scdr << m_implementation_status;
}

void dds::xrce::ResultStatus::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_request_id;
    dcdr >> m_status;
    dcdr >> m_implementation_status;
}

size_t dds::xrce::ResultStatus::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool dds::xrce::ResultStatus::isKeyDefined()
{
    return false;
}

void dds::xrce::ResultStatus::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
	 
}


















dds::xrce::OBJK_DATAREADER_ActivityInfo::OBJK_DATAREADER_ActivityInfo()
{
    m_highest_acked_num = 0;
}

dds::xrce::OBJK_DATAREADER_ActivityInfo::~OBJK_DATAREADER_ActivityInfo()
{
}

dds::xrce::OBJK_DATAREADER_ActivityInfo::OBJK_DATAREADER_ActivityInfo(const OBJK_DATAREADER_ActivityInfo &x)
{
    m_highest_acked_num = x.m_highest_acked_num;
}

dds::xrce::OBJK_DATAREADER_ActivityInfo::OBJK_DATAREADER_ActivityInfo(OBJK_DATAREADER_ActivityInfo &&x)
{
    m_highest_acked_num = x.m_highest_acked_num;
}

dds::xrce::OBJK_DATAREADER_ActivityInfo& dds::xrce::OBJK_DATAREADER_ActivityInfo::operator=(const OBJK_DATAREADER_ActivityInfo &x)
{
    m_highest_acked_num = x.m_highest_acked_num;
    
    return *this;
}

dds::xrce::OBJK_DATAREADER_ActivityInfo& dds::xrce::OBJK_DATAREADER_ActivityInfo::operator=(OBJK_DATAREADER_ActivityInfo &&x)
{
    m_highest_acked_num = x.m_highest_acked_num;
    
    return *this;
}

size_t dds::xrce::OBJK_DATAREADER_ActivityInfo::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

size_t dds::xrce::OBJK_DATAREADER_ActivityInfo::getCdrSerializedSize(const dds::xrce::OBJK_DATAREADER_ActivityInfo& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_DATAREADER_ActivityInfo::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_highest_acked_num;
}

void dds::xrce::OBJK_DATAREADER_ActivityInfo::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_highest_acked_num;
}

size_t dds::xrce::OBJK_DATAREADER_ActivityInfo::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

    return current_align;
}

bool dds::xrce::OBJK_DATAREADER_ActivityInfo::isKeyDefined()
{
    return false;
}

void dds::xrce::OBJK_DATAREADER_ActivityInfo::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
}
dds::xrce::OBJK_DATAWRITER_ActivityInfo::OBJK_DATAWRITER_ActivityInfo()
{
    m_stream_seq_num = 0;
    m_sample_seq_num = 0;
}

dds::xrce::OBJK_DATAWRITER_ActivityInfo::~OBJK_DATAWRITER_ActivityInfo()
{
}

dds::xrce::OBJK_DATAWRITER_ActivityInfo::OBJK_DATAWRITER_ActivityInfo(const OBJK_DATAWRITER_ActivityInfo &x)
{
    m_stream_seq_num = x.m_stream_seq_num;
    m_sample_seq_num = x.m_sample_seq_num;
}

dds::xrce::OBJK_DATAWRITER_ActivityInfo::OBJK_DATAWRITER_ActivityInfo(OBJK_DATAWRITER_ActivityInfo &&x)
{
    m_stream_seq_num = x.m_stream_seq_num;
    m_sample_seq_num = x.m_sample_seq_num;
}

dds::xrce::OBJK_DATAWRITER_ActivityInfo& dds::xrce::OBJK_DATAWRITER_ActivityInfo::operator=(const OBJK_DATAWRITER_ActivityInfo &x)
{
    m_stream_seq_num = x.m_stream_seq_num;
    m_sample_seq_num = x.m_sample_seq_num;
    
    return *this;
}

dds::xrce::OBJK_DATAWRITER_ActivityInfo& dds::xrce::OBJK_DATAWRITER_ActivityInfo::operator=(OBJK_DATAWRITER_ActivityInfo &&x)
{
    m_stream_seq_num = x.m_stream_seq_num;
    m_sample_seq_num = x.m_sample_seq_num;
    
    return *this;
}

size_t dds::xrce::OBJK_DATAWRITER_ActivityInfo::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t dds::xrce::OBJK_DATAWRITER_ActivityInfo::getCdrSerializedSize(const dds::xrce::OBJK_DATAWRITER_ActivityInfo& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void dds::xrce::OBJK_DATAWRITER_ActivityInfo::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_stream_seq_num;
    scdr << m_sample_seq_num;
}

void dds::xrce::OBJK_DATAWRITER_ActivityInfo::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_stream_seq_num;
    dcdr >> m_sample_seq_num;
}

size_t dds::xrce::OBJK_DATAWRITER_ActivityInfo::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool dds::xrce::OBJK_DATAWRITER_ActivityInfo::isKeyDefined()
{
    return false;
}

void dds::xrce::OBJK_DATAWRITER_ActivityInfo::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}
dds::xrce::ActivityInfoVariant::ActivityInfoVariant()
{
    m__d = OBJK_DATAWRITER;


}

dds::xrce::ActivityInfoVariant::~ActivityInfoVariant()
{
}

dds::xrce::ActivityInfoVariant::ActivityInfoVariant(const ActivityInfoVariant &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case OBJK_DATAWRITER:
        m_data_writer = x.m_data_writer;
        break;
        case OBJK_DATAREADER:
        m_data_reader = x.m_data_reader;
        break;
        default:
        break;
    }
}

dds::xrce::ActivityInfoVariant::ActivityInfoVariant(ActivityInfoVariant &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case OBJK_DATAWRITER:
        m_data_writer = std::move(x.m_data_writer);
        break;
        case OBJK_DATAREADER:
        m_data_reader = std::move(x.m_data_reader);
        break;
        default:
        break;
    }
}

dds::xrce::ActivityInfoVariant& dds::xrce::ActivityInfoVariant::operator=(const ActivityInfoVariant &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case OBJK_DATAWRITER:
        m_data_writer = x.m_data_writer;
        break;
        case OBJK_DATAREADER:
        m_data_reader = x.m_data_reader;
        break;
        default:
        break;
    }
    
    return *this;
}

dds::xrce::ActivityInfoVariant& dds::xrce::ActivityInfoVariant::operator=(ActivityInfoVariant &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case OBJK_DATAWRITER:
        m_data_writer = std::move(x.m_data_writer);
        break;
        case OBJK_DATAREADER:
        m_data_reader = std::move(x.m_data_reader);
        break;
        default:
        break;
    }
    
    return *this;
}

void dds::xrce::ActivityInfoVariant::_d(dds::xrce::ObjectKind __d)
{
    bool b = false;
    
    switch(m__d)
    {
        case OBJK_DATAWRITER:
        switch(__d)
        {
            case OBJK_DATAWRITER:
            b = true;
            break;
            default:
            break;
        }
        break;
        case OBJK_DATAREADER:
        switch(__d)
        {
            case OBJK_DATAREADER:
            b = true;
            break;
            default:
            break;
        }
        break;
    }
    
    if(!b) throw BadParamException("Discriminator doesn't correspond with the selected union member");
    
    m__d = __d;
}

dds::xrce::ObjectKind dds::xrce::ActivityInfoVariant::_d() const
{
    return m__d;
}

dds::xrce::ObjectKind& dds::xrce::ActivityInfoVariant::_d()
{
    return m__d;
}

void dds::xrce::ActivityInfoVariant::data_writer(const dds::xrce::OBJK_DATAWRITER_ActivityInfo &_data_writer)
{
    m_data_writer = _data_writer;
    m__d = OBJK_DATAWRITER;
}

void dds::xrce::ActivityInfoVariant::data_writer(dds::xrce::OBJK_DATAWRITER_ActivityInfo &&_data_writer)
{
    m_data_writer = std::move(_data_writer);
    m__d = OBJK_DATAWRITER;
}

const dds::xrce::OBJK_DATAWRITER_ActivityInfo& dds::xrce::ActivityInfoVariant::data_writer() const
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_DATAWRITER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_data_writer;
}

dds::xrce::OBJK_DATAWRITER_ActivityInfo& dds::xrce::ActivityInfoVariant::data_writer()
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_DATAWRITER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_data_writer;
}
void dds::xrce::ActivityInfoVariant::data_reader(const dds::xrce::OBJK_DATAREADER_ActivityInfo &_data_reader)
{
    m_data_reader = _data_reader;
    m__d = OBJK_DATAREADER;
}

void dds::xrce::ActivityInfoVariant::data_reader(dds::xrce::OBJK_DATAREADER_ActivityInfo &&_data_reader)
{
    m_data_reader = std::move(_data_reader);
    m__d = OBJK_DATAREADER;
}

const dds::xrce::OBJK_DATAREADER_ActivityInfo& dds::xrce::ActivityInfoVariant::data_reader() const
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_DATAREADER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_data_reader;
}

dds::xrce::OBJK_DATAREADER_ActivityInfo& dds::xrce::ActivityInfoVariant::data_reader()
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_DATAREADER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_data_reader;
}

size_t dds::xrce::ActivityInfoVariant::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


        reset_alignment = current_alignment;

        reset_alignment += dds::xrce::OBJK_DATAWRITER_ActivityInfo::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += dds::xrce::OBJK_DATAREADER_ActivityInfo::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        

    return union_max_size_serialized - initial_alignment;
}

// TODO(Ricardo) Review
size_t dds::xrce::ActivityInfoVariant::getCdrSerializedSize(const dds::xrce::ActivityInfoVariant& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(data.m__d)
    {
        case OBJK_DATAWRITER:
        current_alignment += dds::xrce::OBJK_DATAWRITER_ActivityInfo::getCdrSerializedSize(data.data_writer(), current_alignment);
        break;
        case OBJK_DATAREADER:
        current_alignment += dds::xrce::OBJK_DATAREADER_ActivityInfo::getCdrSerializedSize(data.data_reader(), current_alignment);
        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void dds::xrce::ActivityInfoVariant::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case OBJK_DATAWRITER:
        scdr << m_data_writer;
        break;
        case OBJK_DATAREADER:
        scdr << m_data_reader;
        break;
        default:
        break;
    }
}

void dds::xrce::ActivityInfoVariant::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case OBJK_DATAWRITER:
        dcdr >> m_data_writer;
        break;
        case OBJK_DATAREADER:
        dcdr >> m_data_reader;
        break;
        default:
        break;
    }
}


dds::xrce::Info::Info()
{


}

dds::xrce::Info::~Info()
{
}

dds::xrce::Info::Info(const Info &x)
{
    m_config = x.m_config;
    m_activity = x.m_activity;
}

dds::xrce::Info::Info(Info &&x)
{
    m_config = std::move(x.m_config);
    m_activity = std::move(x.m_activity);
}

dds::xrce::Info& dds::xrce::Info::operator=(const Info &x)
{
    m_config = x.m_config;
    m_activity = x.m_activity;
    
    return *this;
}

dds::xrce::Info& dds::xrce::Info::operator=(Info &&x)
{
    m_config = std::move(x.m_config);
    m_activity = std::move(x.m_activity);
    
    return *this;
}

size_t dds::xrce::Info::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::ObjectVariant::getMaxCdrSerializedSize(current_alignment);
    current_alignment += dds::xrce::ActivityInfoVariant::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t dds::xrce::Info::getCdrSerializedSize(const dds::xrce::Info& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::ObjectVariant::getCdrSerializedSize(data.config(), current_alignment);
    current_alignment += dds::xrce::ActivityInfoVariant::getCdrSerializedSize(data.activity(), current_alignment);

    return current_alignment - initial_alignment;
}

void dds::xrce::Info::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_config;
    scdr << m_activity;
}

void dds::xrce::Info::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_config;
    dcdr >> m_activity;
}

size_t dds::xrce::Info::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool dds::xrce::Info::isKeyDefined()
{
    return false;
}

void dds::xrce::Info::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}
dds::xrce::BaseRequest::BaseRequest()
{


}

dds::xrce::BaseRequest::~BaseRequest()
{
}

dds::xrce::BaseRequest::BaseRequest(const BaseRequest &x)
{
    m_request_id = x.m_request_id;
    m_object_id = x.m_object_id;
}

dds::xrce::BaseRequest::BaseRequest(BaseRequest &&x)
{
    m_request_id = std::move(x.m_request_id);
    m_object_id = std::move(x.m_object_id);
}

dds::xrce::BaseRequest& dds::xrce::BaseRequest::operator=(const BaseRequest &x)
{
    m_request_id = x.m_request_id;
    m_object_id = x.m_object_id;
    
    return *this;
}

dds::xrce::BaseRequest& dds::xrce::BaseRequest::operator=(BaseRequest &&x)
{
    m_request_id = std::move(x.m_request_id);
    m_object_id = std::move(x.m_object_id);
    
    return *this;
}

size_t dds::xrce::BaseRequest::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t dds::xrce::BaseRequest::getCdrSerializedSize(const dds::xrce::BaseRequest& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void dds::xrce::BaseRequest::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_request_id;
    scdr << m_object_id;
}

void dds::xrce::BaseRequest::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_request_id;
    dcdr >> m_object_id;
}

size_t dds::xrce::BaseRequest::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool dds::xrce::BaseRequest::isKeyDefined()
{
    return false;
}

void dds::xrce::BaseRequest::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}
dds::xrce::BaseObjectRequest::BaseObjectRequest()
{


}

dds::xrce::BaseObjectRequest::~BaseObjectRequest()
{
}

dds::xrce::BaseObjectRequest::BaseObjectRequest(const BaseObjectRequest &x)
{
    m_base_request = x.m_base_request;
    m_object_id = x.m_object_id;
}

dds::xrce::BaseObjectRequest::BaseObjectRequest(BaseObjectRequest &&x)
{
    m_base_request = std::move(x.m_base_request);
    m_object_id = std::move(x.m_object_id);
}

dds::xrce::BaseObjectRequest& dds::xrce::BaseObjectRequest::operator=(const BaseObjectRequest &x)
{
    m_base_request = x.m_base_request;
    m_object_id = x.m_object_id;
    
    return *this;
}

dds::xrce::BaseObjectRequest& dds::xrce::BaseObjectRequest::operator=(BaseObjectRequest &&x)
{
    m_base_request = std::move(x.m_base_request);
    m_object_id = std::move(x.m_object_id);
    
    return *this;
}

size_t dds::xrce::BaseObjectRequest::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::BaseRequest::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t dds::xrce::BaseObjectRequest::getCdrSerializedSize(const dds::xrce::BaseObjectRequest& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::BaseRequest::getCdrSerializedSize(data.base_request(), current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void dds::xrce::BaseObjectRequest::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_base_request;
    scdr << m_object_id;
}

void dds::xrce::BaseObjectRequest::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_base_request;
    dcdr >> m_object_id;
}

size_t dds::xrce::BaseObjectRequest::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool dds::xrce::BaseObjectRequest::isKeyDefined()
{
    return false;
}

void dds::xrce::BaseObjectRequest::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}
dds::xrce::BaseReply::BaseReply()
{


}

dds::xrce::BaseReply::~BaseReply()
{
}

dds::xrce::BaseReply::BaseReply(const BaseReply &x)
{
    m_result = x.m_result;
    m_request_id = x.m_request_id;
}

dds::xrce::BaseReply::BaseReply(BaseReply &&x)
{
    m_result = std::move(x.m_result);
    m_request_id = std::move(x.m_request_id);
}

dds::xrce::BaseReply& dds::xrce::BaseReply::operator=(const BaseReply &x)
{
    m_result = x.m_result;
    m_request_id = x.m_request_id;
    
    return *this;
}

dds::xrce::BaseReply& dds::xrce::BaseReply::operator=(BaseReply &&x)
{
    m_result = std::move(x.m_result);
    m_request_id = std::move(x.m_request_id);
    
    return *this;
}

size_t dds::xrce::BaseReply::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::ResultStatus::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t dds::xrce::BaseReply::getCdrSerializedSize(const dds::xrce::BaseReply& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::ResultStatus::getCdrSerializedSize(data.result(), current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void dds::xrce::BaseReply::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_result;
    scdr << m_request_id;
}

void dds::xrce::BaseReply::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_result;
    dcdr >> m_request_id;
}

size_t dds::xrce::BaseReply::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool dds::xrce::BaseReply::isKeyDefined()
{
    return false;
}

void dds::xrce::BaseReply::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}
dds::xrce::BaseObjectReply::BaseObjectReply()
{


}

dds::xrce::BaseObjectReply::~BaseObjectReply()
{
}

dds::xrce::BaseObjectReply::BaseObjectReply(const BaseObjectReply &x)
{
    m_base_reply = x.m_base_reply;
    m_object_id = x.m_object_id;
}

dds::xrce::BaseObjectReply::BaseObjectReply(BaseObjectReply &&x)
{
    m_base_reply = std::move(x.m_base_reply);
    m_object_id = std::move(x.m_object_id);
}

dds::xrce::BaseObjectReply& dds::xrce::BaseObjectReply::operator=(const BaseObjectReply &x)
{
    m_base_reply = x.m_base_reply;
    m_object_id = x.m_object_id;
    
    return *this;
}

dds::xrce::BaseObjectReply& dds::xrce::BaseObjectReply::operator=(BaseObjectReply &&x)
{
    m_base_reply = std::move(x.m_base_reply);
    m_object_id = std::move(x.m_object_id);
    
    return *this;
}

size_t dds::xrce::BaseObjectReply::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::BaseReply::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t dds::xrce::BaseObjectReply::getCdrSerializedSize(const dds::xrce::BaseObjectReply& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::BaseReply::getCdrSerializedSize(data.base_reply(), current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void dds::xrce::BaseObjectReply::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_base_reply;
    scdr << m_object_id;
}

void dds::xrce::BaseObjectReply::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_base_reply;
    dcdr >> m_object_id;
}

size_t dds::xrce::BaseObjectReply::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool dds::xrce::BaseObjectReply::isKeyDefined()
{
    return false;
}

void dds::xrce::BaseObjectReply::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}
dds::xrce::InfoReply::InfoReply()
{


}

dds::xrce::InfoReply::~InfoReply()
{
}

dds::xrce::InfoReply::InfoReply(const InfoReply &x)
{
    m_base_object_reply = x.m_base_object_reply;
    m_info = x.m_info;
}

dds::xrce::InfoReply::InfoReply(InfoReply &&x)
{
    m_base_object_reply = std::move(x.m_base_object_reply);
    m_info = std::move(x.m_info);
}

dds::xrce::InfoReply& dds::xrce::InfoReply::operator=(const InfoReply &x)
{
    m_base_object_reply = x.m_base_object_reply;
    m_info = x.m_info;
    
    return *this;
}

dds::xrce::InfoReply& dds::xrce::InfoReply::operator=(InfoReply &&x)
{
    m_base_object_reply = std::move(x.m_base_object_reply);
    m_info = std::move(x.m_info);
    
    return *this;
}

size_t dds::xrce::InfoReply::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::BaseObjectReply::getMaxCdrSerializedSize(current_alignment);
    current_alignment += dds::xrce::ObjectVariant::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t dds::xrce::InfoReply::getCdrSerializedSize(const dds::xrce::InfoReply& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::BaseObjectReply::getCdrSerializedSize(data.base_object_reply(), current_alignment);
    current_alignment += dds::xrce::ObjectVariant::getCdrSerializedSize(data.info(), current_alignment);

    return current_alignment - initial_alignment;
}

void dds::xrce::InfoReply::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_base_object_reply;
    scdr << m_info;
}

void dds::xrce::InfoReply::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_base_object_reply;
    dcdr >> m_info;
}

size_t dds::xrce::InfoReply::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool dds::xrce::InfoReply::isKeyDefined()
{
    return false;
}

void dds::xrce::InfoReply::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}






dds::xrce::DataDeliveryControl::DataDeliveryControl()
{
    m_max_samples = 0;
    m_max_elapsed_time = 0;
    m_max_rate = 0;
}

dds::xrce::DataDeliveryControl::~DataDeliveryControl()
{
}

dds::xrce::DataDeliveryControl::DataDeliveryControl(const DataDeliveryControl &x)
{
    m_max_samples = x.m_max_samples;
    m_max_elapsed_time = x.m_max_elapsed_time;
    m_max_rate = x.m_max_rate;
}

dds::xrce::DataDeliveryControl::DataDeliveryControl(DataDeliveryControl &&x)
{
    m_max_samples = x.m_max_samples;
    m_max_elapsed_time = x.m_max_elapsed_time;
    m_max_rate = x.m_max_rate;
}

dds::xrce::DataDeliveryControl& dds::xrce::DataDeliveryControl::operator=(const DataDeliveryControl &x)
{
    m_max_samples = x.m_max_samples;
    m_max_elapsed_time = x.m_max_elapsed_time;
    m_max_rate = x.m_max_rate;
    
    return *this;
}

dds::xrce::DataDeliveryControl& dds::xrce::DataDeliveryControl::operator=(DataDeliveryControl &&x)
{
    m_max_samples = x.m_max_samples;
    m_max_elapsed_time = x.m_max_elapsed_time;
    m_max_rate = x.m_max_rate;
    
    return *this;
}

size_t dds::xrce::DataDeliveryControl::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t dds::xrce::DataDeliveryControl::getCdrSerializedSize(const dds::xrce::DataDeliveryControl& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void dds::xrce::DataDeliveryControl::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_max_samples;
    scdr << m_max_elapsed_time;
    scdr << m_max_rate;
}

void dds::xrce::DataDeliveryControl::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_max_samples;
    dcdr >> m_max_elapsed_time;
    dcdr >> m_max_rate;
}

size_t dds::xrce::DataDeliveryControl::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool dds::xrce::DataDeliveryControl::isKeyDefined()
{
    return false;
}

void dds::xrce::DataDeliveryControl::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
	 
}
dds::xrce::DataDeliveryConfig::DataDeliveryConfig()
{
    m__d = FORMAT_DATA_SEQ;

    m_dummy = 0;
}

dds::xrce::DataDeliveryConfig::~DataDeliveryConfig()
{
}

dds::xrce::DataDeliveryConfig::DataDeliveryConfig(const DataDeliveryConfig &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
        case FORMAT_SAMPLE_SEQ:
        case FORMAT_PACKED_SAMPLES:
        m_delivey_control = x.m_delivey_control;
        break;
        case FORMAT_DATA:
        case FORMAT_SAMPLE:
        m_dummy = x.m_dummy;
        break;
        default:
        break;
    }
}

dds::xrce::DataDeliveryConfig::DataDeliveryConfig(DataDeliveryConfig &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
        case FORMAT_SAMPLE_SEQ:
        case FORMAT_PACKED_SAMPLES:
        m_delivey_control = std::move(x.m_delivey_control);
        break;
        case FORMAT_DATA:
        case FORMAT_SAMPLE:
        m_dummy = x.m_dummy;
        break;
        default:
        break;
    }
}

dds::xrce::DataDeliveryConfig& dds::xrce::DataDeliveryConfig::operator=(const DataDeliveryConfig &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
        case FORMAT_SAMPLE_SEQ:
        case FORMAT_PACKED_SAMPLES:
        m_delivey_control = x.m_delivey_control;
        break;
        case FORMAT_DATA:
        case FORMAT_SAMPLE:
        m_dummy = x.m_dummy;
        break;
        default:
        break;
    }
    
    return *this;
}

dds::xrce::DataDeliveryConfig& dds::xrce::DataDeliveryConfig::operator=(DataDeliveryConfig &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
        case FORMAT_SAMPLE_SEQ:
        case FORMAT_PACKED_SAMPLES:
        m_delivey_control = std::move(x.m_delivey_control);
        break;
        case FORMAT_DATA:
        case FORMAT_SAMPLE:
        m_dummy = x.m_dummy;
        break;
        default:
        break;
    }
    
    return *this;
}

void dds::xrce::DataDeliveryConfig::_d(dds::xrce::DataFormat __d)
{
    bool b = false;
    
    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
        case FORMAT_SAMPLE_SEQ:
        case FORMAT_PACKED_SAMPLES:
        switch(__d)
        {
            case FORMAT_DATA_SEQ:
            case FORMAT_SAMPLE_SEQ:
            case FORMAT_PACKED_SAMPLES:
            b = true;
            break;
            default:
            break;
        }
        break;
        case FORMAT_DATA:
        case FORMAT_SAMPLE:
        switch(__d)
        {
            case FORMAT_DATA:
            case FORMAT_SAMPLE:
            b = true;
            break;
            default:
            break;
        }
        break;
    }
    
    if(!b) throw BadParamException("Discriminator doesn't correspond with the selected union member");
    
    m__d = __d;
}

dds::xrce::DataFormat dds::xrce::DataDeliveryConfig::_d() const
{
    return m__d;
}

dds::xrce::DataFormat& dds::xrce::DataDeliveryConfig::_d()
{
    return m__d;
}

void dds::xrce::DataDeliveryConfig::delivey_control(const dds::xrce::DataDeliveryControl &_delivey_control)
{
    m_delivey_control = _delivey_control;
    m__d = FORMAT_DATA_SEQ;
}

void dds::xrce::DataDeliveryConfig::delivey_control(dds::xrce::DataDeliveryControl &&_delivey_control)
{
    m_delivey_control = std::move(_delivey_control);
    m__d = FORMAT_DATA_SEQ;
}

const dds::xrce::DataDeliveryControl& dds::xrce::DataDeliveryConfig::delivey_control() const
{
    bool b = false;
        
    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
        case FORMAT_SAMPLE_SEQ:
        case FORMAT_PACKED_SAMPLES:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_delivey_control;
}

dds::xrce::DataDeliveryControl& dds::xrce::DataDeliveryConfig::delivey_control()
{
    bool b = false;
        
    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
        case FORMAT_SAMPLE_SEQ:
        case FORMAT_PACKED_SAMPLES:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_delivey_control;
}
void dds::xrce::DataDeliveryConfig::dummy(uint8_t _dummy)
{
    m_dummy = _dummy;
    m__d = FORMAT_DATA;
}

uint8_t dds::xrce::DataDeliveryConfig::dummy() const
{
    bool b = false;
        
    switch(m__d)
    {
        case FORMAT_DATA:
        case FORMAT_SAMPLE:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_dummy;
}

uint8_t& dds::xrce::DataDeliveryConfig::dummy()
{
    bool b = false;
        
    switch(m__d)
    {
        case FORMAT_DATA:
        case FORMAT_SAMPLE:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_dummy;
}

size_t dds::xrce::DataDeliveryConfig::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


        reset_alignment = current_alignment;

        reset_alignment += dds::xrce::DataDeliveryControl::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += 1 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 1);


        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        

    return union_max_size_serialized - initial_alignment;
}

// TODO(Ricardo) Review
size_t dds::xrce::DataDeliveryConfig::getCdrSerializedSize(const dds::xrce::DataDeliveryConfig& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(data.m__d)
    {
        case FORMAT_DATA_SEQ:
        case FORMAT_SAMPLE_SEQ:
        case FORMAT_PACKED_SAMPLES:
        current_alignment += dds::xrce::DataDeliveryControl::getCdrSerializedSize(data.delivey_control(), current_alignment);
        break;
        case FORMAT_DATA:
        case FORMAT_SAMPLE:
        current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void dds::xrce::DataDeliveryConfig::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
        case FORMAT_SAMPLE_SEQ:
        case FORMAT_PACKED_SAMPLES:
        scdr << m_delivey_control;
        break;
        case FORMAT_DATA:
        case FORMAT_SAMPLE:
        scdr << m_dummy;
        break;
        default:
        break;
    }
}

void dds::xrce::DataDeliveryConfig::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
        case FORMAT_SAMPLE_SEQ:
        case FORMAT_PACKED_SAMPLES:
        dcdr >> m_delivey_control;
        break;
        case FORMAT_DATA:
        case FORMAT_SAMPLE:
        dcdr >> m_dummy;
        break;
        default:
        break;
    }
}


dds::xrce::ReadSpecification::ReadSpecification()
{


}

dds::xrce::ReadSpecification::~ReadSpecification()
{
}

dds::xrce::ReadSpecification::ReadSpecification(const ReadSpecification &x)
{
    m_content_filter_expression = x.m_content_filter_expression;
    m_delivery_config = x.m_delivery_config;
}

dds::xrce::ReadSpecification::ReadSpecification(ReadSpecification &&x)
{
    m_content_filter_expression = std::move(x.m_content_filter_expression);
    m_delivery_config = std::move(x.m_delivery_config);
}

dds::xrce::ReadSpecification& dds::xrce::ReadSpecification::operator=(const ReadSpecification &x)
{
    m_content_filter_expression = x.m_content_filter_expression;
    m_delivery_config = x.m_delivery_config;
    
    return *this;
}

dds::xrce::ReadSpecification& dds::xrce::ReadSpecification::operator=(ReadSpecification &&x)
{
    m_content_filter_expression = std::move(x.m_content_filter_expression);
    m_delivery_config = std::move(x.m_delivery_config);
    
    return *this;
}

size_t dds::xrce::ReadSpecification::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += dds::xrce::DataDeliveryConfig::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t dds::xrce::ReadSpecification::getCdrSerializedSize(const dds::xrce::ReadSpecification& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.content_filter_expression().size() + 1;

    current_alignment += dds::xrce::DataDeliveryConfig::getCdrSerializedSize(data.delivery_config(), current_alignment);

    return current_alignment - initial_alignment;
}

void dds::xrce::ReadSpecification::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_content_filter_expression;
    scdr << m_delivery_config;
}

void dds::xrce::ReadSpecification::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_content_filter_expression;
    dcdr >> m_delivery_config;
}

size_t dds::xrce::ReadSpecification::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool dds::xrce::ReadSpecification::isKeyDefined()
{
    return false;
}

void dds::xrce::ReadSpecification::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}
dds::xrce::SampleInfo::SampleInfo()
{
    m_state = 0;
    m_sequence_number = 0;
    m_session_time_offset = 0;
}

dds::xrce::SampleInfo::~SampleInfo()
{
}

dds::xrce::SampleInfo::SampleInfo(const SampleInfo &x)
{
    m_state = x.m_state;
    m_sequence_number = x.m_sequence_number;
    m_session_time_offset = x.m_session_time_offset;
}

dds::xrce::SampleInfo::SampleInfo(SampleInfo &&x)
{
    m_state = x.m_state;
    m_sequence_number = x.m_sequence_number;
    m_session_time_offset = x.m_session_time_offset;
}

dds::xrce::SampleInfo& dds::xrce::SampleInfo::operator=(const SampleInfo &x)
{
    m_state = x.m_state;
    m_sequence_number = x.m_sequence_number;
    m_session_time_offset = x.m_session_time_offset;
    
    return *this;
}

dds::xrce::SampleInfo& dds::xrce::SampleInfo::operator=(SampleInfo &&x)
{
    m_state = x.m_state;
    m_sequence_number = x.m_sequence_number;
    m_session_time_offset = x.m_session_time_offset;
    
    return *this;
}

size_t dds::xrce::SampleInfo::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t dds::xrce::SampleInfo::getCdrSerializedSize(const dds::xrce::SampleInfo& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void dds::xrce::SampleInfo::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_state;
    scdr << m_sequence_number;
    scdr << m_session_time_offset;
}

void dds::xrce::SampleInfo::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_state;
    dcdr >> m_sequence_number;
    dcdr >> m_session_time_offset;
}

size_t dds::xrce::SampleInfo::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool dds::xrce::SampleInfo::isKeyDefined()
{
    return false;
}

void dds::xrce::SampleInfo::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
	 
}
dds::xrce::SampleInfoDelta::SampleInfoDelta()
{
    m_state = 0;
    m_seq_number_delta = 0;
    m_timestamp_delta = 0;
}

dds::xrce::SampleInfoDelta::~SampleInfoDelta()
{
}

dds::xrce::SampleInfoDelta::SampleInfoDelta(const SampleInfoDelta &x)
{
    m_state = x.m_state;
    m_seq_number_delta = x.m_seq_number_delta;
    m_timestamp_delta = x.m_timestamp_delta;
}

dds::xrce::SampleInfoDelta::SampleInfoDelta(SampleInfoDelta &&x)
{
    m_state = x.m_state;
    m_seq_number_delta = x.m_seq_number_delta;
    m_timestamp_delta = x.m_timestamp_delta;
}

dds::xrce::SampleInfoDelta& dds::xrce::SampleInfoDelta::operator=(const SampleInfoDelta &x)
{
    m_state = x.m_state;
    m_seq_number_delta = x.m_seq_number_delta;
    m_timestamp_delta = x.m_timestamp_delta;
    
    return *this;
}

dds::xrce::SampleInfoDelta& dds::xrce::SampleInfoDelta::operator=(SampleInfoDelta &&x)
{
    m_state = x.m_state;
    m_seq_number_delta = x.m_seq_number_delta;
    m_timestamp_delta = x.m_timestamp_delta;
    
    return *this;
}

size_t dds::xrce::SampleInfoDelta::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

size_t dds::xrce::SampleInfoDelta::getCdrSerializedSize(const dds::xrce::SampleInfoDelta& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void dds::xrce::SampleInfoDelta::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_state;
    scdr << m_seq_number_delta;
    scdr << m_timestamp_delta;
}

void dds::xrce::SampleInfoDelta::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_state;
    dcdr >> m_seq_number_delta;
    dcdr >> m_timestamp_delta;
}

size_t dds::xrce::SampleInfoDelta::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool dds::xrce::SampleInfoDelta::isKeyDefined()
{
    return false;
}

void dds::xrce::SampleInfoDelta::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
	 
}
dds::xrce::SampleData::SampleData()
{
}

dds::xrce::SampleData::~SampleData()
{
}

dds::xrce::SampleData::SampleData(const SampleData &x)
{
    m_serialized_data = x.m_serialized_data;
}

dds::xrce::SampleData::SampleData(SampleData &&x)
{
    m_serialized_data = std::move(x.m_serialized_data);
}

dds::xrce::SampleData& dds::xrce::SampleData::operator=(const SampleData &x)
{
    m_serialized_data = x.m_serialized_data;
    
    return *this;
}

dds::xrce::SampleData& dds::xrce::SampleData::operator=(SampleData &&x)
{
    m_serialized_data = std::move(x.m_serialized_data);
    
    return *this;
}

size_t dds::xrce::SampleData::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t dds::xrce::SampleData::getCdrSerializedSize(const dds::xrce::SampleData& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.serialized_data().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void dds::xrce::SampleData::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_serialized_data;
}

void dds::xrce::SampleData::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_serialized_data;
}

size_t dds::xrce::SampleData::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

    return current_align;
}

bool dds::xrce::SampleData::isKeyDefined()
{
    return false;
}

void dds::xrce::SampleData::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
}

dds::xrce::Sample::Sample()
{


}

dds::xrce::Sample::~Sample()
{
}

dds::xrce::Sample::Sample(const Sample &x)
{
    m_info = x.m_info;
    m_data = x.m_data;
}

dds::xrce::Sample::Sample(Sample &&x)
{
    m_info = std::move(x.m_info);
    m_data = std::move(x.m_data);
}

dds::xrce::Sample& dds::xrce::Sample::operator=(const Sample &x)
{
    m_info = x.m_info;
    m_data = x.m_data;
    
    return *this;
}

dds::xrce::Sample& dds::xrce::Sample::operator=(Sample &&x)
{
    m_info = std::move(x.m_info);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t dds::xrce::Sample::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::SampleInfo::getMaxCdrSerializedSize(current_alignment);
    current_alignment += dds::xrce::SampleData::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t dds::xrce::Sample::getCdrSerializedSize(const dds::xrce::Sample& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::SampleInfo::getCdrSerializedSize(data.info(), current_alignment);
    current_alignment += dds::xrce::SampleData::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void dds::xrce::Sample::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_info;
    scdr << m_data;
}

void dds::xrce::Sample::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_info;
    dcdr >> m_data;
}

size_t dds::xrce::Sample::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool dds::xrce::Sample::isKeyDefined()
{
    return false;
}

void dds::xrce::Sample::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}

dds::xrce::SampleDelta::SampleDelta()
{


}

dds::xrce::SampleDelta::~SampleDelta()
{
}

dds::xrce::SampleDelta::SampleDelta(const SampleDelta &x)
{
    m_info_delta = x.m_info_delta;
    m_data = x.m_data;
}

dds::xrce::SampleDelta::SampleDelta(SampleDelta &&x)
{
    m_info_delta = std::move(x.m_info_delta);
    m_data = std::move(x.m_data);
}

dds::xrce::SampleDelta& dds::xrce::SampleDelta::operator=(const SampleDelta &x)
{
    m_info_delta = x.m_info_delta;
    m_data = x.m_data;
    
    return *this;
}

dds::xrce::SampleDelta& dds::xrce::SampleDelta::operator=(SampleDelta &&x)
{
    m_info_delta = std::move(x.m_info_delta);
    m_data = std::move(x.m_data);
    
    return *this;
}

size_t dds::xrce::SampleDelta::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::SampleInfoDelta::getMaxCdrSerializedSize(current_alignment);
    current_alignment += dds::xrce::SampleData::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t dds::xrce::SampleDelta::getCdrSerializedSize(const dds::xrce::SampleDelta& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::SampleInfoDelta::getCdrSerializedSize(data.info_delta(), current_alignment);
    current_alignment += dds::xrce::SampleData::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void dds::xrce::SampleDelta::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_info_delta;
    scdr << m_data;
}

void dds::xrce::SampleDelta::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_info_delta;
    dcdr >> m_data;
}

size_t dds::xrce::SampleDelta::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool dds::xrce::SampleDelta::isKeyDefined()
{
    return false;
}

void dds::xrce::SampleDelta::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}
dds::xrce::PackedSamples::PackedSamples()
{


}

dds::xrce::PackedSamples::~PackedSamples()
{
}

dds::xrce::PackedSamples::PackedSamples(const PackedSamples &x)
{
    m_info_base = x.m_info_base;
    m_sample_delta_seq = x.m_sample_delta_seq;
}

dds::xrce::PackedSamples::PackedSamples(PackedSamples &&x)
{
    m_info_base = std::move(x.m_info_base);
    m_sample_delta_seq = std::move(x.m_sample_delta_seq);
}

dds::xrce::PackedSamples& dds::xrce::PackedSamples::operator=(const PackedSamples &x)
{
    m_info_base = x.m_info_base;
    m_sample_delta_seq = x.m_sample_delta_seq;
    
    return *this;
}

dds::xrce::PackedSamples& dds::xrce::PackedSamples::operator=(PackedSamples &&x)
{
    m_info_base = std::move(x.m_info_base);
    m_sample_delta_seq = std::move(x.m_sample_delta_seq);
    
    return *this;
}

size_t dds::xrce::PackedSamples::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::SampleInfo::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += dds::xrce::SampleDelta::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t dds::xrce::PackedSamples::getCdrSerializedSize(const dds::xrce::PackedSamples& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += dds::xrce::SampleInfo::getCdrSerializedSize(data.info_base(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.sample_delta_seq().size(); ++a)
    {
        current_alignment += dds::xrce::SampleDelta::getCdrSerializedSize(data.sample_delta_seq().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void dds::xrce::PackedSamples::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_info_base;
    scdr << m_sample_delta_seq;
}

void dds::xrce::PackedSamples::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_info_base;
    dcdr >> m_sample_delta_seq;
}

size_t dds::xrce::PackedSamples::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool dds::xrce::PackedSamples::isKeyDefined()
{
    return false;
}

void dds::xrce::PackedSamples::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}

dds::xrce::DataRepresentation::DataRepresentation()
{
    m__d = FORMAT_DATA;





}

dds::xrce::DataRepresentation::~DataRepresentation()
{
}

dds::xrce::DataRepresentation::DataRepresentation(const DataRepresentation &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case FORMAT_DATA:
        m_data = x.m_data;
        break;
        case FORMAT_DATA_SEQ:
        m_data_seq = x.m_data_seq;
        break;
        case FORMAT_SAMPLE:
        m_sample = x.m_sample;
        break;
        case FORMAT_SAMPLE_SEQ:
        m_sample_seq = x.m_sample_seq;
        break;
        case FORMAT_PACKED_SAMPLES:
        m_packed_samples = x.m_packed_samples;
        break;
        default:
        break;
    }
}

dds::xrce::DataRepresentation::DataRepresentation(DataRepresentation &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case FORMAT_DATA:
        m_data = std::move(x.m_data);
        break;
        case FORMAT_DATA_SEQ:
        m_data_seq = std::move(x.m_data_seq);
        break;
        case FORMAT_SAMPLE:
        m_sample = std::move(x.m_sample);
        break;
        case FORMAT_SAMPLE_SEQ:
        m_sample_seq = std::move(x.m_sample_seq);
        break;
        case FORMAT_PACKED_SAMPLES:
        m_packed_samples = std::move(x.m_packed_samples);
        break;
        default:
        break;
    }
}

dds::xrce::DataRepresentation& dds::xrce::DataRepresentation::operator=(const DataRepresentation &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case FORMAT_DATA:
        m_data = x.m_data;
        break;
        case FORMAT_DATA_SEQ:
        m_data_seq = x.m_data_seq;
        break;
        case FORMAT_SAMPLE:
        m_sample = x.m_sample;
        break;
        case FORMAT_SAMPLE_SEQ:
        m_sample_seq = x.m_sample_seq;
        break;
        case FORMAT_PACKED_SAMPLES:
        m_packed_samples = x.m_packed_samples;
        break;
        default:
        break;
    }
    
    return *this;
}

dds::xrce::DataRepresentation& dds::xrce::DataRepresentation::operator=(DataRepresentation &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case FORMAT_DATA:
        m_data = std::move(x.m_data);
        break;
        case FORMAT_DATA_SEQ:
        m_data_seq = std::move(x.m_data_seq);
        break;
        case FORMAT_SAMPLE:
        m_sample = std::move(x.m_sample);
        break;
        case FORMAT_SAMPLE_SEQ:
        m_sample_seq = std::move(x.m_sample_seq);
        break;
        case FORMAT_PACKED_SAMPLES:
        m_packed_samples = std::move(x.m_packed_samples);
        break;
        default:
        break;
    }
    
    return *this;
}

void dds::xrce::DataRepresentation::_d(dds::xrce::DataFormat __d)
{
    bool b = false;
    
    switch(m__d)
    {
        case FORMAT_DATA:
        switch(__d)
        {
            case FORMAT_DATA:
            b = true;
            break;
            default:
            break;
        }
        break;
        case FORMAT_DATA_SEQ:
        switch(__d)
        {
            case FORMAT_DATA_SEQ:
            b = true;
            break;
            default:
            break;
        }
        break;
        case FORMAT_SAMPLE:
        switch(__d)
        {
            case FORMAT_SAMPLE:
            b = true;
            break;
            default:
            break;
        }
        break;
        case FORMAT_SAMPLE_SEQ:
        switch(__d)
        {
            case FORMAT_SAMPLE_SEQ:
            b = true;
            break;
            default:
            break;
        }
        break;
        case FORMAT_PACKED_SAMPLES:
        switch(__d)
        {
            case FORMAT_PACKED_SAMPLES:
            b = true;
            break;
            default:
            break;
        }
        break;
    }
    
    if(!b) throw BadParamException("Discriminator doesn't correspond with the selected union member");
    
    m__d = __d;
}

dds::xrce::DataFormat dds::xrce::DataRepresentation::_d() const
{
    return m__d;
}

dds::xrce::DataFormat& dds::xrce::DataRepresentation::_d()
{
    return m__d;
}

void dds::xrce::DataRepresentation::data(const dds::xrce::SampleData &_data)
{
    m_data = _data;
    m__d = FORMAT_DATA;
}

void dds::xrce::DataRepresentation::data(dds::xrce::SampleData &&_data)
{
    m_data = std::move(_data);
    m__d = FORMAT_DATA;
}

const dds::xrce::SampleData& dds::xrce::DataRepresentation::data() const
{
    bool b = false;
        
    switch(m__d)
    {
        case FORMAT_DATA:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_data;
}

dds::xrce::SampleData& dds::xrce::DataRepresentation::data()
{
    bool b = false;
        
    switch(m__d)
    {
        case FORMAT_DATA:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_data;
}
void dds::xrce::DataRepresentation::data_seq(const dds::xrce::SampleDataSeq &_data_seq)
{
    m_data_seq = _data_seq;
    m__d = FORMAT_DATA_SEQ;
}

void dds::xrce::DataRepresentation::data_seq(dds::xrce::SampleDataSeq &&_data_seq)
{
    m_data_seq = std::move(_data_seq);
    m__d = FORMAT_DATA_SEQ;
}

const dds::xrce::SampleDataSeq& dds::xrce::DataRepresentation::data_seq() const
{
    bool b = false;
        
    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_data_seq;
}

dds::xrce::SampleDataSeq& dds::xrce::DataRepresentation::data_seq()
{
    bool b = false;
        
    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_data_seq;
}
void dds::xrce::DataRepresentation::sample(const dds::xrce::Sample &_sample)
{
    m_sample = _sample;
    m__d = FORMAT_SAMPLE;
}

void dds::xrce::DataRepresentation::sample(dds::xrce::Sample &&_sample)
{
    m_sample = std::move(_sample);
    m__d = FORMAT_SAMPLE;
}

const dds::xrce::Sample& dds::xrce::DataRepresentation::sample() const
{
    bool b = false;
        
    switch(m__d)
    {
        case FORMAT_SAMPLE:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_sample;
}

dds::xrce::Sample& dds::xrce::DataRepresentation::sample()
{
    bool b = false;
        
    switch(m__d)
    {
        case FORMAT_SAMPLE:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_sample;
}
void dds::xrce::DataRepresentation::sample_seq(const dds::xrce::SampleSeq &_sample_seq)
{
    m_sample_seq = _sample_seq;
    m__d = FORMAT_SAMPLE_SEQ;
}

void dds::xrce::DataRepresentation::sample_seq(dds::xrce::SampleSeq &&_sample_seq)
{
    m_sample_seq = std::move(_sample_seq);
    m__d = FORMAT_SAMPLE_SEQ;
}

const dds::xrce::SampleSeq& dds::xrce::DataRepresentation::sample_seq() const
{
    bool b = false;
        
    switch(m__d)
    {
        case FORMAT_SAMPLE_SEQ:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_sample_seq;
}

dds::xrce::SampleSeq& dds::xrce::DataRepresentation::sample_seq()
{
    bool b = false;
        
    switch(m__d)
    {
        case FORMAT_SAMPLE_SEQ:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_sample_seq;
}
void dds::xrce::DataRepresentation::packed_samples(const dds::xrce::PackedSamples &_packed_samples)
{
    m_packed_samples = _packed_samples;
    m__d = FORMAT_PACKED_SAMPLES;
}

void dds::xrce::DataRepresentation::packed_samples(dds::xrce::PackedSamples &&_packed_samples)
{
    m_packed_samples = std::move(_packed_samples);
    m__d = FORMAT_PACKED_SAMPLES;
}

const dds::xrce::PackedSamples& dds::xrce::DataRepresentation::packed_samples() const
{
    bool b = false;
        
    switch(m__d)
    {
        case FORMAT_PACKED_SAMPLES:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_packed_samples;
}

dds::xrce::PackedSamples& dds::xrce::DataRepresentation::packed_samples()
{
    bool b = false;
        
    switch(m__d)
    {
        case FORMAT_PACKED_SAMPLES:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_packed_samples;
}

size_t dds::xrce::DataRepresentation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


        reset_alignment = current_alignment;

        reset_alignment += dds::xrce::SampleData::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);
        for(size_t a = 0; a < 100; ++a)
        {
            reset_alignment += dds::xrce::SampleData::getMaxCdrSerializedSize(reset_alignment);}

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += dds::xrce::Sample::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);
        for(size_t a = 0; a < 100; ++a)
        {
            reset_alignment += dds::xrce::Sample::getMaxCdrSerializedSize(reset_alignment);}

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += dds::xrce::PackedSamples::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        

    return union_max_size_serialized - initial_alignment;
}

// TODO(Ricardo) Review
size_t dds::xrce::DataRepresentation::getCdrSerializedSize(const dds::xrce::DataRepresentation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(data.m__d)
    {
        case FORMAT_DATA:
        current_alignment += dds::xrce::SampleData::getCdrSerializedSize(data.data(), current_alignment);
        break;
        case FORMAT_DATA_SEQ:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
        for(size_t a = 0; a < data.data_seq().size(); ++a)
        {
            current_alignment += dds::xrce::SampleData::getCdrSerializedSize(data.data_seq().at(a), current_alignment);}
        break;
        case FORMAT_SAMPLE:
        current_alignment += dds::xrce::Sample::getCdrSerializedSize(data.sample(), current_alignment);
        break;
        case FORMAT_SAMPLE_SEQ:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
        for(size_t a = 0; a < data.sample_seq().size(); ++a)
        {
            current_alignment += dds::xrce::Sample::getCdrSerializedSize(data.sample_seq().at(a), current_alignment);}
        break;
        case FORMAT_PACKED_SAMPLES:
        current_alignment += dds::xrce::PackedSamples::getCdrSerializedSize(data.packed_samples(), current_alignment);
        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void dds::xrce::DataRepresentation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case FORMAT_DATA:
        scdr << m_data;
        break;
        case FORMAT_DATA_SEQ:
        scdr << m_data_seq;
        break;
        case FORMAT_SAMPLE:
        scdr << m_sample;
        break;
        case FORMAT_SAMPLE_SEQ:
        scdr << m_sample_seq;
        break;
        case FORMAT_PACKED_SAMPLES:
        scdr << m_packed_samples;
        break;
        default:
        break;
    }
}

void dds::xrce::DataRepresentation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case FORMAT_DATA:
        dcdr >> m_data;
        break;
        case FORMAT_DATA_SEQ:
        dcdr >> m_data_seq;
        break;
        case FORMAT_SAMPLE:
        dcdr >> m_sample;
        break;
        case FORMAT_SAMPLE_SEQ:
        dcdr >> m_sample_seq;
        break;
        case FORMAT_PACKED_SAMPLES:
        dcdr >> m_packed_samples;
        break;
        default:
        break;
    }
}




