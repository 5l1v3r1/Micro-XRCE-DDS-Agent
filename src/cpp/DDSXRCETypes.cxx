// Copyright 2017 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*!
 * @file DDSXRCETypes.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace {
char dummy;
}
#endif

#include "DDSXRCETypes.h"

#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

eprosima::micrortps::Time_t::Time_t()
{
    m_seconds     = 0;
    m_nanoseconds = 0;
}

eprosima::micrortps::Time_t::~Time_t()
{
}

eprosima::micrortps::Time_t::Time_t(const Time_t& x)
{
    m_seconds     = x.m_seconds;
    m_nanoseconds = x.m_nanoseconds;
}

eprosima::micrortps::Time_t::Time_t(Time_t&& x)
{
    m_seconds     = x.m_seconds;
    m_nanoseconds = x.m_nanoseconds;
}

eprosima::micrortps::Time_t& eprosima::micrortps::Time_t::operator=(const Time_t& x)
{
    m_seconds     = x.m_seconds;
    m_nanoseconds = x.m_nanoseconds;

    return *this;
}

eprosima::micrortps::Time_t& eprosima::micrortps::Time_t::operator=(Time_t&& x)
{
    m_seconds     = x.m_seconds;
    m_nanoseconds = x.m_nanoseconds;

    return *this;
}

size_t eprosima::micrortps::Time_t::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::Time_t::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::Time_t::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_seconds;
    scdr << m_nanoseconds;
}

void eprosima::micrortps::Time_t::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_seconds;
    dcdr >> m_nanoseconds;
}

eprosima::micrortps::OBJK_CLIENT_Representation::OBJK_CLIENT_Representation()
{
    m_session_id = 0;
}

eprosima::micrortps::OBJK_CLIENT_Representation::~OBJK_CLIENT_Representation()
{
}

eprosima::micrortps::OBJK_CLIENT_Representation::OBJK_CLIENT_Representation(const OBJK_CLIENT_Representation& x)
{
    m_xrce_cookie      = x.m_xrce_cookie;
    m_xrce_version     = x.m_xrce_version;
    m_xrce_vendor_id   = x.m_xrce_vendor_id;
    m_client_timestamp = x.m_client_timestamp;
    m_client_key       = x.m_client_key;
    m_session_id       = x.m_session_id;
}

eprosima::micrortps::OBJK_CLIENT_Representation::OBJK_CLIENT_Representation(OBJK_CLIENT_Representation&& x)
{
    m_xrce_cookie      = std::move(x.m_xrce_cookie);
    m_xrce_version     = std::move(x.m_xrce_version);
    m_xrce_vendor_id   = std::move(x.m_xrce_vendor_id);
    m_client_timestamp = std::move(x.m_client_timestamp);
    m_client_key       = std::move(x.m_client_key);
    m_session_id       = x.m_session_id;
}

eprosima::micrortps::OBJK_CLIENT_Representation& eprosima::micrortps::OBJK_CLIENT_Representation::
operator=(const OBJK_CLIENT_Representation& x)
{
    m_xrce_cookie      = x.m_xrce_cookie;
    m_xrce_version     = x.m_xrce_version;
    m_xrce_vendor_id   = x.m_xrce_vendor_id;
    m_client_timestamp = x.m_client_timestamp;
    m_client_key       = x.m_client_key;
    m_session_id       = x.m_session_id;

    return *this;
}

eprosima::micrortps::OBJK_CLIENT_Representation& eprosima::micrortps::OBJK_CLIENT_Representation::
operator=(OBJK_CLIENT_Representation&& x)
{
    m_xrce_cookie      = std::move(x.m_xrce_cookie);
    m_xrce_version     = std::move(x.m_xrce_version);
    m_xrce_vendor_id   = std::move(x.m_xrce_vendor_id);
    m_client_timestamp = std::move(x.m_client_timestamp);
    m_client_key       = std::move(x.m_client_key);
    m_session_id       = x.m_session_id;

    return *this;
}

size_t eprosima::micrortps::OBJK_CLIENT_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += ((4) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += eprosima::micrortps::Time_t::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((4) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::OBJK_CLIENT_Representation::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += ((4) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += m_client_timestamp.getCdrSerializedSize(current_alignment);
    current_alignment += ((4) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_CLIENT_Representation::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_xrce_cookie;
    scdr << m_xrce_version;
    scdr << m_xrce_vendor_id;
    scdr << m_client_timestamp;
    scdr << m_client_key;
    scdr << m_session_id;
}

void eprosima::micrortps::OBJK_CLIENT_Representation::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_xrce_cookie;
    dcdr >> m_xrce_version;
    dcdr >> m_xrce_vendor_id;
    dcdr >> m_client_timestamp;
    dcdr >> m_client_key;
    dcdr >> m_session_id;
}

eprosima::micrortps::OBJK_Representation3Formats::OBJK_Representation3Formats()
{
    m__d = eprosima::micrortps::REPRESENTATION_BY_REFERENCE;
}

eprosima::micrortps::OBJK_Representation3Formats::~OBJK_Representation3Formats()
{
}

eprosima::micrortps::OBJK_Representation3Formats::OBJK_Representation3Formats(const OBJK_Representation3Formats& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case eprosima::micrortps::REPRESENTATION_BY_REFERENCE:
            m_object_reference = x.m_object_reference;
            break;
        case eprosima::micrortps::REPRESENTATION_AS_XML_STRING:
            m_xml_string_representation = x.m_xml_string_representation;
            break;
        case eprosima::micrortps::REPRESENTATION_IN_BINARY:
            m_binary_representation = x.m_binary_representation;
            break;
        default:
            break;
    }
}

eprosima::micrortps::OBJK_Representation3Formats::OBJK_Representation3Formats(OBJK_Representation3Formats&& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case eprosima::micrortps::REPRESENTATION_BY_REFERENCE:
            m_object_reference = std::move(x.m_object_reference);
            break;
        case eprosima::micrortps::REPRESENTATION_AS_XML_STRING:
            m_xml_string_representation = std::move(x.m_xml_string_representation);
            break;
        case REPRESENTATION_IN_BINARY:
            m_binary_representation = std::move(x.m_binary_representation);
            break;
        default:
            break;
    }
}

eprosima::micrortps::OBJK_Representation3Formats& eprosima::micrortps::OBJK_Representation3Formats::
operator=(const OBJK_Representation3Formats& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
            m_object_reference = x.m_object_reference;
            break;
        case REPRESENTATION_AS_XML_STRING:
            m_xml_string_representation = x.m_xml_string_representation;
            break;
        case REPRESENTATION_IN_BINARY:
            m_binary_representation = x.m_binary_representation;
            break;
        default:
            break;
    }

    return *this;
}

eprosima::micrortps::OBJK_Representation3Formats& eprosima::micrortps::OBJK_Representation3Formats::
operator=(OBJK_Representation3Formats&& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
            m_object_reference = std::move(x.m_object_reference);
            break;
        case REPRESENTATION_AS_XML_STRING:
            m_xml_string_representation = std::move(x.m_xml_string_representation);
            break;
        case REPRESENTATION_IN_BINARY:
            m_binary_representation = std::move(x.m_binary_representation);
            break;
        default:
            break;
    }

    return *this;
}

void eprosima::micrortps::OBJK_Representation3Formats::_d(eprosima::micrortps::RepresentationFormat __d)
{
    bool b = false;

    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
            switch(__d)
            {
                case REPRESENTATION_BY_REFERENCE:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
        case REPRESENTATION_AS_XML_STRING:
            switch(__d)
            {
                case REPRESENTATION_AS_XML_STRING:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
        case REPRESENTATION_IN_BINARY:
            switch(__d)
            {
                case REPRESENTATION_IN_BINARY:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
    }

    if(!b)
        throw BadParamException("Discriminator doesn't correspond with the selected union member");

    m__d = __d;
}

eprosima::micrortps::RepresentationFormat eprosima::micrortps::OBJK_Representation3Formats::_d() const
{
    return m__d;
}

eprosima::micrortps::RepresentationFormat& eprosima::micrortps::OBJK_Representation3Formats::_d()
{
    return m__d;
}

void eprosima::micrortps::OBJK_Representation3Formats::object_reference(const std::string& _object_reference)
{
    m_object_reference = _object_reference;
    m__d               = REPRESENTATION_BY_REFERENCE;
}

void eprosima::micrortps::OBJK_Representation3Formats::object_reference(std::string&& _object_reference)
{
    m_object_reference = std::move(_object_reference);
    m__d               = REPRESENTATION_BY_REFERENCE;
}

const std::string& eprosima::micrortps::OBJK_Representation3Formats::object_reference() const
{
    bool b = false;

    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_object_reference;
}

std::string& eprosima::micrortps::OBJK_Representation3Formats::object_reference()
{
    bool b = false;

    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_object_reference;
}
void eprosima::micrortps::OBJK_Representation3Formats::xml_string_representation(
    const std::string& _xml_string_representation)
{
    m_xml_string_representation = _xml_string_representation;
    m__d                        = REPRESENTATION_AS_XML_STRING;
}

void eprosima::micrortps::OBJK_Representation3Formats::xml_string_representation(
    std::string&& _xml_string_representation)
{
    m_xml_string_representation = std::move(_xml_string_representation);
    m__d                        = REPRESENTATION_AS_XML_STRING;
}

const std::string& eprosima::micrortps::OBJK_Representation3Formats::xml_string_representation() const
{
    bool b = false;

    switch(m__d)
    {
        case REPRESENTATION_AS_XML_STRING:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_xml_string_representation;
}

std::string& eprosima::micrortps::OBJK_Representation3Formats::xml_string_representation()
{
    bool b = false;

    switch(m__d)
    {
        case REPRESENTATION_AS_XML_STRING:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_xml_string_representation;
}
void eprosima::micrortps::OBJK_Representation3Formats::binary_representation(
    const std::vector<uint8_t>& _binary_representation)
{
    m_binary_representation = _binary_representation;
    m__d                    = REPRESENTATION_IN_BINARY;
}

void eprosima::micrortps::OBJK_Representation3Formats::binary_representation(
    std::vector<uint8_t>&& _binary_representation)
{
    m_binary_representation = std::move(_binary_representation);
    m__d                    = REPRESENTATION_IN_BINARY;
}

const std::vector<uint8_t>& eprosima::micrortps::OBJK_Representation3Formats::binary_representation() const
{
    bool b = false;

    switch(m__d)
    {
        case REPRESENTATION_IN_BINARY:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_binary_representation;
}

std::vector<uint8_t>& eprosima::micrortps::OBJK_Representation3Formats::binary_representation()
{
    bool b = false;

    switch(m__d)
    {
        case REPRESENTATION_IN_BINARY:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_binary_representation;
}

size_t eprosima::micrortps::OBJK_Representation3Formats::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment         = current_alignment;
    size_t reset_alignment           = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    reset_alignment = current_alignment;

    reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4) + 255 + 1;

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4) + 255 + 1;

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);
    reset_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(reset_alignment, 1);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    return union_max_size_serialized - initial_alignment;
}

// TODO(Ricardo) Review
size_t eprosima::micrortps::OBJK_Representation3Formats::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
            current_alignment +=
                4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + m_object_reference.size() + 1;
            break;
        case REPRESENTATION_AS_XML_STRING:
            current_alignment +=
                4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + m_xml_string_representation.size() + 1;
            break;
        case REPRESENTATION_IN_BINARY:
            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
            current_alignment +=
                (m_binary_representation.size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

            break;
        default:
            break;
    }

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_Representation3Formats::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
            scdr << m_object_reference;
            break;
        case REPRESENTATION_AS_XML_STRING:
            scdr << m_xml_string_representation;
            break;
        case REPRESENTATION_IN_BINARY:
            scdr << m_binary_representation;
            break;
        default:
            break;
    }
}

void eprosima::micrortps::OBJK_Representation3Formats::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
            dcdr >> m_object_reference;
            break;
        case REPRESENTATION_AS_XML_STRING:
            dcdr >> m_xml_string_representation;
            break;
        case REPRESENTATION_IN_BINARY:
            dcdr >> m_binary_representation;
            break;
        default:
            break;
    }
}

eprosima::micrortps::OBJK_Representation2Formats::OBJK_Representation2Formats()
{
    m__d = REPRESENTATION_BY_REFERENCE;
}

eprosima::micrortps::OBJK_Representation2Formats::~OBJK_Representation2Formats()
{
}

eprosima::micrortps::OBJK_Representation2Formats::OBJK_Representation2Formats(const OBJK_Representation2Formats& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
            m_object_name = x.m_object_name;
            break;
        case REPRESENTATION_AS_XML_STRING:
            m_string_representation = x.m_string_representation;
            break;
        default:
            break;
    }
}

eprosima::micrortps::OBJK_Representation2Formats::OBJK_Representation2Formats(OBJK_Representation2Formats&& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
            m_object_name = std::move(x.m_object_name);
            break;
        case REPRESENTATION_AS_XML_STRING:
            m_string_representation = std::move(x.m_string_representation);
            break;
        default:
            break;
    }
}

eprosima::micrortps::OBJK_Representation2Formats& eprosima::micrortps::OBJK_Representation2Formats::
operator=(const OBJK_Representation2Formats& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
            m_object_name = x.m_object_name;
            break;
        case REPRESENTATION_AS_XML_STRING:
            m_string_representation = x.m_string_representation;
            break;
        default:
            break;
    }

    return *this;
}

eprosima::micrortps::OBJK_Representation2Formats& eprosima::micrortps::OBJK_Representation2Formats::
operator=(OBJK_Representation2Formats&& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
            m_object_name = std::move(x.m_object_name);
            break;
        case REPRESENTATION_AS_XML_STRING:
            m_string_representation = std::move(x.m_string_representation);
            break;
        default:
            break;
    }

    return *this;
}

void eprosima::micrortps::OBJK_Representation2Formats::_d(eprosima::micrortps::RepresentationFormat __d)
{
    bool b = false;

    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
            switch(__d)
            {
                case REPRESENTATION_BY_REFERENCE:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
        case REPRESENTATION_AS_XML_STRING:
            switch(__d)
            {
                case REPRESENTATION_AS_XML_STRING:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
    }

    if(!b)
        throw BadParamException("Discriminator doesn't correspond with the selected union member");

    m__d = __d;
}

eprosima::micrortps::RepresentationFormat eprosima::micrortps::OBJK_Representation2Formats::_d() const
{
    return m__d;
}

eprosima::micrortps::RepresentationFormat& eprosima::micrortps::OBJK_Representation2Formats::_d()
{
    return m__d;
}

void eprosima::micrortps::OBJK_Representation2Formats::object_name(const std::string& _object_name)
{
    m_object_name = _object_name;
    m__d          = REPRESENTATION_BY_REFERENCE;
}

void eprosima::micrortps::OBJK_Representation2Formats::object_name(std::string&& _object_name)
{
    m_object_name = std::move(_object_name);
    m__d          = REPRESENTATION_BY_REFERENCE;
}

const std::string& eprosima::micrortps::OBJK_Representation2Formats::object_name() const
{
    bool b = false;

    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_object_name;
}

std::string& eprosima::micrortps::OBJK_Representation2Formats::object_name()
{
    bool b = false;

    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_object_name;
}
void eprosima::micrortps::OBJK_Representation2Formats::string_representation(const std::string& _string_representation)
{
    m_string_representation = _string_representation;
    m__d                    = REPRESENTATION_AS_XML_STRING;
}

void eprosima::micrortps::OBJK_Representation2Formats::string_representation(std::string&& _string_representation)
{
    m_string_representation = std::move(_string_representation);
    m__d                    = REPRESENTATION_AS_XML_STRING;
}

const std::string& eprosima::micrortps::OBJK_Representation2Formats::string_representation() const
{
    bool b = false;

    switch(m__d)
    {
        case REPRESENTATION_AS_XML_STRING:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_string_representation;
}

std::string& eprosima::micrortps::OBJK_Representation2Formats::string_representation()
{
    bool b = false;

    switch(m__d)
    {
        case REPRESENTATION_AS_XML_STRING:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_string_representation;
}

size_t eprosima::micrortps::OBJK_Representation2Formats::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment         = current_alignment;
    size_t reset_alignment           = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    reset_alignment = current_alignment;

    reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4) + 255 + 1;

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4) + 255 + 1;

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    return union_max_size_serialized - initial_alignment;
}

// TODO(Ricardo) Review
size_t eprosima::micrortps::OBJK_Representation2Formats::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + m_object_name.size() + 1;
            break;
        case REPRESENTATION_AS_XML_STRING:
            current_alignment +=
                4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + m_string_representation.size() + 1;
            break;
        default:
            break;
    }

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_Representation2Formats::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
            scdr << m_object_name;
            break;
        case REPRESENTATION_AS_XML_STRING:
            scdr << m_string_representation;
            break;
        default:
            break;
    }
}

void eprosima::micrortps::OBJK_Representation2Formats::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case REPRESENTATION_BY_REFERENCE:
            dcdr >> m_object_name;
            break;
        case REPRESENTATION_AS_XML_STRING:
            dcdr >> m_string_representation;
            break;
        default:
            break;
    }
}

eprosima::micrortps::OBJK_Representation2_Base::OBJK_Representation2_Base()
{
}

eprosima::micrortps::OBJK_Representation2_Base::~OBJK_Representation2_Base()
{
}

eprosima::micrortps::OBJK_Representation2_Base::OBJK_Representation2_Base(const OBJK_Representation2_Base& x)
{
    m_representation = x.m_representation;
}

eprosima::micrortps::OBJK_Representation2_Base::OBJK_Representation2_Base(OBJK_Representation2_Base&& x)
{
    m_representation = std::move(x.m_representation);
}

eprosima::micrortps::OBJK_Representation2_Base& eprosima::micrortps::OBJK_Representation2_Base::
operator=(const OBJK_Representation2_Base& x)
{
    m_representation = x.m_representation;

    return *this;
}

eprosima::micrortps::OBJK_Representation2_Base& eprosima::micrortps::OBJK_Representation2_Base::
operator=(OBJK_Representation2_Base&& x)
{
    m_representation = std::move(x.m_representation);

    return *this;
}

size_t eprosima::micrortps::OBJK_Representation2_Base::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::OBJK_Representation2Formats::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::OBJK_Representation2_Base::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += m_representation.getCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_Representation2_Base::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_representation;
}

void eprosima::micrortps::OBJK_Representation2_Base::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_representation;
}

eprosima::micrortps::OBJK_Representation3_Base::OBJK_Representation3_Base()
{
}

eprosima::micrortps::OBJK_Representation3_Base::~OBJK_Representation3_Base()
{
}

eprosima::micrortps::OBJK_Representation3_Base::OBJK_Representation3_Base(const OBJK_Representation3_Base& x)
{
    m_representation = x.m_representation;
}

eprosima::micrortps::OBJK_Representation3_Base::OBJK_Representation3_Base(OBJK_Representation3_Base&& x)
{
    m_representation = std::move(x.m_representation);
}

eprosima::micrortps::OBJK_Representation3_Base& eprosima::micrortps::OBJK_Representation3_Base::
operator=(const OBJK_Representation3_Base& x)
{
    m_representation = x.m_representation;

    return *this;
}

eprosima::micrortps::OBJK_Representation3_Base& eprosima::micrortps::OBJK_Representation3_Base::
operator=(OBJK_Representation3_Base&& x)
{
    m_representation = std::move(x.m_representation);

    return *this;
}

size_t eprosima::micrortps::OBJK_Representation3_Base::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::OBJK_Representation3Formats::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::OBJK_Representation3_Base::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += m_representation.getCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_Representation3_Base::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_representation;
}

void eprosima::micrortps::OBJK_Representation3_Base::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_representation;
}

eprosima::micrortps::OBJK_QOSPROFILE_Representation::OBJK_QOSPROFILE_Representation()
{
}

eprosima::micrortps::OBJK_QOSPROFILE_Representation::~OBJK_QOSPROFILE_Representation()
{
}

eprosima::micrortps::OBJK_QOSPROFILE_Representation::OBJK_QOSPROFILE_Representation(
    const OBJK_QOSPROFILE_Representation& x)
    : OBJK_Representation2_Base(x)
{
}

eprosima::micrortps::OBJK_QOSPROFILE_Representation::OBJK_QOSPROFILE_Representation(OBJK_QOSPROFILE_Representation&& x)
    : OBJK_Representation2_Base(x)
{
}

eprosima::micrortps::OBJK_QOSPROFILE_Representation& eprosima::micrortps::OBJK_QOSPROFILE_Representation::
operator=(const OBJK_QOSPROFILE_Representation& x)
{
    OBJK_Representation2_Base::operator=(x);
    return *this;
}

eprosima::micrortps::OBJK_QOSPROFILE_Representation& eprosima::micrortps::OBJK_QOSPROFILE_Representation::
operator=(OBJK_QOSPROFILE_Representation&& x)
{
    OBJK_Representation2_Base::operator=(x);
    return *this;
}

size_t eprosima::micrortps::OBJK_QOSPROFILE_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::OBJK_Representation2_Base::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::OBJK_QOSPROFILE_Representation::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::OBJK_Representation2_Base::getCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_QOSPROFILE_Representation::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::micrortps::OBJK_Representation2_Base::serialize(scdr);
}

void eprosima::micrortps::OBJK_QOSPROFILE_Representation::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    eprosima::micrortps::OBJK_Representation2_Base::deserialize(dcdr);
}

eprosima::micrortps::OBJK_APPLICATION_Representation::OBJK_APPLICATION_Representation()
{
}

eprosima::micrortps::OBJK_APPLICATION_Representation::~OBJK_APPLICATION_Representation()

{
}

eprosima::micrortps::OBJK_APPLICATION_Representation::OBJK_APPLICATION_Representation(
    const OBJK_APPLICATION_Representation& x)
    : OBJK_Representation2_Base(x)
{
}

eprosima::micrortps::OBJK_APPLICATION_Representation::OBJK_APPLICATION_Representation(
    OBJK_APPLICATION_Representation&& x)
    : OBJK_Representation2_Base(x)
{
}

eprosima::micrortps::OBJK_APPLICATION_Representation& eprosima::micrortps::OBJK_APPLICATION_Representation::
operator=(const OBJK_APPLICATION_Representation& x)
{
    OBJK_Representation2_Base::operator=(x);

    return *this;
}

eprosima::micrortps::OBJK_APPLICATION_Representation& eprosima::micrortps::OBJK_APPLICATION_Representation::
operator=(OBJK_APPLICATION_Representation&& x)
{
    OBJK_Representation2_Base::operator=(x);

    return *this;
}

size_t eprosima::micrortps::OBJK_APPLICATION_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::OBJK_Representation2_Base::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::OBJK_APPLICATION_Representation::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::OBJK_Representation2_Base::getCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_APPLICATION_Representation::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::micrortps::OBJK_Representation2_Base::serialize(scdr);
}

void eprosima::micrortps::OBJK_APPLICATION_Representation::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    eprosima::micrortps::OBJK_Representation2_Base::deserialize(dcdr);
}

eprosima::micrortps::OBJK_PARTICIPANT_Representation::OBJK_PARTICIPANT_Representation()
{
}

eprosima::micrortps::OBJK_PARTICIPANT_Representation::~OBJK_PARTICIPANT_Representation()
{
}

eprosima::micrortps::OBJK_PARTICIPANT_Representation::OBJK_PARTICIPANT_Representation(
    const OBJK_PARTICIPANT_Representation& x)
    : OBJK_Representation2_Base(x)
{
}

eprosima::micrortps::OBJK_PARTICIPANT_Representation::OBJK_PARTICIPANT_Representation(
    OBJK_PARTICIPANT_Representation&& x)
    : OBJK_Representation2_Base(x)
{
}

eprosima::micrortps::OBJK_PARTICIPANT_Representation& eprosima::micrortps::OBJK_PARTICIPANT_Representation::
operator=(const OBJK_PARTICIPANT_Representation& x)
{
    OBJK_Representation2_Base::operator=(x);

    return *this;
}

eprosima::micrortps::OBJK_PARTICIPANT_Representation& eprosima::micrortps::OBJK_PARTICIPANT_Representation::
operator=(OBJK_PARTICIPANT_Representation&& x)
{
    OBJK_Representation2_Base::operator=(x);

    return *this;
}

size_t eprosima::micrortps::OBJK_PARTICIPANT_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::OBJK_Representation2_Base::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::OBJK_PARTICIPANT_Representation::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::OBJK_Representation2_Base::getCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_PARTICIPANT_Representation::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    OBJK_Representation2_Base::serialize(scdr);
}

void eprosima::micrortps::OBJK_PARTICIPANT_Representation::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    OBJK_Representation2_Base::deserialize(dcdr);
}

eprosima::micrortps::OBJK_TYPE_Representation::OBJK_TYPE_Representation()
{
}

eprosima::micrortps::OBJK_TYPE_Representation::~OBJK_TYPE_Representation()
{
}

eprosima::micrortps::OBJK_TYPE_Representation::OBJK_TYPE_Representation(const OBJK_TYPE_Representation& x)
    : OBJK_Representation3_Base(x)
{
    m_participant_id       = x.m_participant_id;
    m_registered_type_name = x.m_registered_type_name;
}

eprosima::micrortps::OBJK_TYPE_Representation::OBJK_TYPE_Representation(OBJK_TYPE_Representation&& x)
    : OBJK_Representation3_Base(x)
{
    m_participant_id       = std::move(x.m_participant_id);
    m_registered_type_name = std::move(x.m_registered_type_name);
}

eprosima::micrortps::OBJK_TYPE_Representation& eprosima::micrortps::OBJK_TYPE_Representation::
operator=(const OBJK_TYPE_Representation& x)
{
    OBJK_Representation3_Base::operator=(x);
    m_participant_id                   = x.m_participant_id;
    m_registered_type_name             = x.m_registered_type_name;

    return *this;
}

eprosima::micrortps::OBJK_TYPE_Representation& eprosima::micrortps::OBJK_TYPE_Representation::
operator=(OBJK_TYPE_Representation&& x)
{
    OBJK_Representation3_Base::operator=(x);
    m_participant_id                   = std::move(x.m_participant_id);
    m_registered_type_name             = std::move(x.m_registered_type_name);

    return *this;
}

size_t eprosima::micrortps::OBJK_TYPE_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::OBJK_Representation3_Base::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::OBJK_TYPE_Representation::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::OBJK_Representation3_Base::getCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment +=
        4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + m_registered_type_name.size() + 1;

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_TYPE_Representation::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    eprosima::micrortps::OBJK_Representation3_Base::serialize(scdr);
    scdr << m_participant_id;
    scdr << m_registered_type_name;
}

void eprosima::micrortps::OBJK_TYPE_Representation::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    eprosima::micrortps::OBJK_Representation3_Base::deserialize(dcdr);
    dcdr >> m_participant_id;
    dcdr >> m_registered_type_name;
}
eprosima::micrortps::OBJK_TOPIC_Representation::OBJK_TOPIC_Representation()
{
}

eprosima::micrortps::OBJK_TOPIC_Representation::~OBJK_TOPIC_Representation()
{
}

eprosima::micrortps::OBJK_TOPIC_Representation::OBJK_TOPIC_Representation(const OBJK_TOPIC_Representation& x)
    : OBJK_Representation3_Base(x)
{
    m_participant_id = x.m_participant_id;
}

eprosima::micrortps::OBJK_TOPIC_Representation::OBJK_TOPIC_Representation(OBJK_TOPIC_Representation&& x)
    : OBJK_Representation3_Base(x)
{
    m_participant_id = std::move(x.m_participant_id);
}

eprosima::micrortps::OBJK_TOPIC_Representation& eprosima::micrortps::OBJK_TOPIC_Representation::
operator=(const OBJK_TOPIC_Representation& x)
{
    OBJK_Representation3_Base::operator=(x);
    m_participant_id                   = x.m_participant_id;

    return *this;
}

eprosima::micrortps::OBJK_TOPIC_Representation& eprosima::micrortps::OBJK_TOPIC_Representation::
operator=(OBJK_TOPIC_Representation&& x)
{
    OBJK_Representation3_Base::operator=(x);
    m_participant_id                   = std::move(x.m_participant_id);

    return *this;
}

size_t eprosima::micrortps::OBJK_TOPIC_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::OBJK_Representation3_Base::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::OBJK_TOPIC_Representation::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::OBJK_Representation3_Base::getCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_TOPIC_Representation::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    OBJK_Representation3_Base::serialize(scdr);
    scdr << m_participant_id;
}

void eprosima::micrortps::OBJK_TOPIC_Representation::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    OBJK_Representation3_Base::deserialize(dcdr);
    dcdr >> m_participant_id;
}

eprosima::micrortps::OBJK_PUBLISHER_Representation::OBJK_PUBLISHER_Representation()
{
}

eprosima::micrortps::OBJK_PUBLISHER_Representation::~OBJK_PUBLISHER_Representation()
{
}

eprosima::micrortps::OBJK_PUBLISHER_Representation::OBJK_PUBLISHER_Representation(
    const OBJK_PUBLISHER_Representation& x)
    : OBJK_Representation3_Base(x)
{
    m_participant_id = x.m_participant_id;
}

eprosima::micrortps::OBJK_PUBLISHER_Representation::OBJK_PUBLISHER_Representation(OBJK_PUBLISHER_Representation&& x)
    : OBJK_Representation3_Base(x)
{
    m_participant_id = std::move(x.m_participant_id);
}

eprosima::micrortps::OBJK_PUBLISHER_Representation& eprosima::micrortps::OBJK_PUBLISHER_Representation::
operator=(const OBJK_PUBLISHER_Representation& x)
{
    OBJK_Representation3_Base::operator=(x);
    m_participant_id                   = x.m_participant_id;

    return *this;
}

eprosima::micrortps::OBJK_PUBLISHER_Representation& eprosima::micrortps::OBJK_PUBLISHER_Representation::
operator=(OBJK_PUBLISHER_Representation&& x)
{
    OBJK_Representation3_Base::operator=(x);
    m_participant_id                   = std::move(x.m_participant_id);

    return *this;
}

size_t eprosima::micrortps::OBJK_PUBLISHER_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::OBJK_Representation3_Base::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::OBJK_PUBLISHER_Representation::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::OBJK_Representation3_Base::getCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_PUBLISHER_Representation::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    OBJK_Representation3_Base::serialize(scdr);
    scdr << m_participant_id;
}

void eprosima::micrortps::OBJK_PUBLISHER_Representation::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    OBJK_Representation3_Base::deserialize(dcdr);
    dcdr >> m_participant_id;
}

eprosima::micrortps::OBJK_SUBSCRIBER_Representation::OBJK_SUBSCRIBER_Representation()
{
}

eprosima::micrortps::OBJK_SUBSCRIBER_Representation::~OBJK_SUBSCRIBER_Representation()
{
}

eprosima::micrortps::OBJK_SUBSCRIBER_Representation::OBJK_SUBSCRIBER_Representation(
    const OBJK_SUBSCRIBER_Representation& x)
    : OBJK_Representation3_Base(x)
{
    m_participant_id = x.m_participant_id;
}

eprosima::micrortps::OBJK_SUBSCRIBER_Representation::OBJK_SUBSCRIBER_Representation(OBJK_SUBSCRIBER_Representation&& x)
    : OBJK_Representation3_Base(x)
{
    m_participant_id = std::move(x.m_participant_id);
}

eprosima::micrortps::OBJK_SUBSCRIBER_Representation& eprosima::micrortps::OBJK_SUBSCRIBER_Representation::
operator=(const OBJK_SUBSCRIBER_Representation& x)
{
    OBJK_Representation3_Base::operator=(x);
    m_participant_id                   = x.m_participant_id;

    return *this;
}

eprosima::micrortps::OBJK_SUBSCRIBER_Representation& eprosima::micrortps::OBJK_SUBSCRIBER_Representation::
operator=(OBJK_SUBSCRIBER_Representation&& x)
{
    OBJK_Representation3_Base::operator=(x);
    m_participant_id                   = std::move(x.m_participant_id);

    return *this;
}

size_t eprosima::micrortps::OBJK_SUBSCRIBER_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::OBJK_Representation3_Base::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::OBJK_SUBSCRIBER_Representation::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::OBJK_Representation3_Base::getCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_SUBSCRIBER_Representation::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    OBJK_Representation3_Base::serialize(scdr);
    scdr << m_participant_id;
}

void eprosima::micrortps::OBJK_SUBSCRIBER_Representation::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    OBJK_Representation3_Base::deserialize(dcdr);
    dcdr >> m_participant_id;
}

eprosima::micrortps::OBJK_DATA_WRITER_Representation::OBJK_DATA_WRITER_Representation()
{
}

eprosima::micrortps::OBJK_DATA_WRITER_Representation::~OBJK_DATA_WRITER_Representation()
{
}

eprosima::micrortps::OBJK_DATA_WRITER_Representation::OBJK_DATA_WRITER_Representation(
    const OBJK_DATA_WRITER_Representation& x)
    : OBJK_Representation3_Base(x)
{
    m_participant_id = x.m_participant_id;
    m_publisher_id   = x.m_publisher_id;
}

eprosima::micrortps::OBJK_DATA_WRITER_Representation::OBJK_DATA_WRITER_Representation(
    OBJK_DATA_WRITER_Representation&& x)
    : OBJK_Representation3_Base(x)
{
    m_participant_id = std::move(x.m_participant_id);
    m_publisher_id   = std::move(x.m_publisher_id);
}

eprosima::micrortps::OBJK_DATA_WRITER_Representation& eprosima::micrortps::OBJK_DATA_WRITER_Representation::
operator=(const OBJK_DATA_WRITER_Representation& x)
{
    OBJK_Representation3_Base::operator=(x);
    m_participant_id                   = x.m_participant_id;
    m_publisher_id                     = x.m_publisher_id;

    return *this;
}

eprosima::micrortps::OBJK_DATA_WRITER_Representation& eprosima::micrortps::OBJK_DATA_WRITER_Representation::
operator=(OBJK_DATA_WRITER_Representation&& x)
{
    OBJK_Representation3_Base::operator=(x);
    m_participant_id                   = std::move(x.m_participant_id);
    m_publisher_id                     = std::move(x.m_publisher_id);

    return *this;
}

size_t eprosima::micrortps::OBJK_DATA_WRITER_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::OBJK_Representation3_Base::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::OBJK_DATA_WRITER_Representation::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::OBJK_Representation3_Base::getCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_DATA_WRITER_Representation::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    OBJK_Representation3_Base::serialize(scdr);
    scdr << m_participant_id;
    scdr << m_publisher_id;
}

void eprosima::micrortps::OBJK_DATA_WRITER_Representation::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    OBJK_Representation3_Base::deserialize(dcdr);
    dcdr >> m_participant_id;
    dcdr >> m_publisher_id;
}

eprosima::micrortps::OBJK_DATA_READER_Representation::OBJK_DATA_READER_Representation()
{
}

eprosima::micrortps::OBJK_DATA_READER_Representation::~OBJK_DATA_READER_Representation()
{
}

eprosima::micrortps::OBJK_DATA_READER_Representation::OBJK_DATA_READER_Representation(
    const OBJK_DATA_READER_Representation& x)
    : OBJK_Representation3_Base(x)
{
    m_participant_id = x.m_participant_id;
    m_subscriber_id  = x.m_subscriber_id;
}

eprosima::micrortps::OBJK_DATA_READER_Representation::OBJK_DATA_READER_Representation(
    OBJK_DATA_READER_Representation&& x)
    : OBJK_Representation3_Base(x)
{
    m_participant_id = std::move(x.m_participant_id);
    m_subscriber_id  = std::move(x.m_subscriber_id);
}

eprosima::micrortps::OBJK_DATA_READER_Representation& eprosima::micrortps::OBJK_DATA_READER_Representation::
operator=(const OBJK_DATA_READER_Representation& x)
{
    OBJK_Representation3_Base::operator=(x);
    m_participant_id                   = x.m_participant_id;
    m_subscriber_id                    = x.m_subscriber_id;

    return *this;
}

eprosima::micrortps::OBJK_DATA_READER_Representation& eprosima::micrortps::OBJK_DATA_READER_Representation::
operator=(OBJK_DATA_READER_Representation&& x)
{
    OBJK_Representation3_Base::operator=(x);
    m_participant_id                   = std::move(x.m_participant_id);
    m_subscriber_id                    = std::move(x.m_subscriber_id);

    return *this;
}

size_t eprosima::micrortps::OBJK_DATA_READER_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::OBJK_Representation3_Base::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::OBJK_DATA_READER_Representation::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::OBJK_Representation3_Base::getCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_DATA_READER_Representation::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    OBJK_Representation3_Base::serialize(scdr);
    scdr << m_participant_id;
    scdr << m_subscriber_id;
}

void eprosima::micrortps::OBJK_DATA_READER_Representation::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    OBJK_Representation3_Base::deserialize(dcdr);
    dcdr >> m_participant_id;
    dcdr >> m_subscriber_id;
}

eprosima::micrortps::OBJK_Type_Binary::OBJK_Type_Binary()
{
}

eprosima::micrortps::OBJK_Type_Binary::~OBJK_Type_Binary()
{
}

eprosima::micrortps::OBJK_Type_Binary::OBJK_Type_Binary(const OBJK_Type_Binary& x)
{
    m_type_name = x.m_type_name;
}

eprosima::micrortps::OBJK_Type_Binary::OBJK_Type_Binary(OBJK_Type_Binary&& x)
{
    m_type_name = std::move(x.m_type_name);
}

eprosima::micrortps::OBJK_Type_Binary& eprosima::micrortps::OBJK_Type_Binary::operator=(const OBJK_Type_Binary& x)
{
    m_type_name = x.m_type_name;

    return *this;
}

eprosima::micrortps::OBJK_Type_Binary& eprosima::micrortps::OBJK_Type_Binary::operator=(OBJK_Type_Binary&& x)
{
    m_type_name = std::move(x.m_type_name);

    return *this;
}

size_t eprosima::micrortps::OBJK_Type_Binary::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::OBJK_Type_Binary::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + m_type_name.size() + 1;

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_Type_Binary::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_type_name;
}

void eprosima::micrortps::OBJK_Type_Binary::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_type_name;
}

eprosima::micrortps::OBJK_Topic_QosBinary::OBJK_Topic_QosBinary()
{
}

eprosima::micrortps::OBJK_Topic_QosBinary::~OBJK_Topic_QosBinary()
{
}

eprosima::micrortps::OBJK_Topic_QosBinary::OBJK_Topic_QosBinary(const OBJK_Topic_QosBinary& x)
{
    m_topic_name = x.m_topic_name;
    m_type_name  = x.m_type_name;
}

eprosima::micrortps::OBJK_Topic_QosBinary::OBJK_Topic_QosBinary(OBJK_Topic_QosBinary&& x)
{
    m_topic_name = std::move(x.m_topic_name);
    m_type_name  = std::move(x.m_type_name);
}

eprosima::micrortps::OBJK_Topic_QosBinary& eprosima::micrortps::OBJK_Topic_QosBinary::
operator=(const OBJK_Topic_QosBinary& x)
{
    m_topic_name = x.m_topic_name;
    m_type_name  = x.m_type_name;

    return *this;
}

eprosima::micrortps::OBJK_Topic_QosBinary& eprosima::micrortps::OBJK_Topic_QosBinary::
operator=(OBJK_Topic_QosBinary&& x)
{
    m_topic_name = std::move(x.m_topic_name);
    m_type_name  = std::move(x.m_type_name);

    return *this;
}

size_t eprosima::micrortps::OBJK_Topic_QosBinary::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::OBJK_Topic_QosBinary::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + m_topic_name.size() + 1;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + m_type_name.size() + 1;

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_Topic_QosBinary::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_topic_name;
    scdr << m_type_name;
}

void eprosima::micrortps::OBJK_Topic_QosBinary::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_topic_name;
    dcdr >> m_type_name;
}

eprosima::micrortps::OBJK_PUB_QosBinary::OBJK_PUB_QosBinary()
{
}

eprosima::micrortps::OBJK_PUB_QosBinary::~OBJK_PUB_QosBinary()
{
}

eprosima::micrortps::OBJK_PUB_QosBinary::OBJK_PUB_QosBinary(const OBJK_PUB_QosBinary& x)
{
    m_partitions = x.m_partitions;
    m_group_data = x.m_group_data;
}

eprosima::micrortps::OBJK_PUB_QosBinary::OBJK_PUB_QosBinary(OBJK_PUB_QosBinary&& x)
{
    m_partitions = std::move(x.m_partitions);
    m_group_data = std::move(x.m_group_data);
}

eprosima::micrortps::OBJK_PUB_QosBinary& eprosima::micrortps::OBJK_PUB_QosBinary::operator=(const OBJK_PUB_QosBinary& x)
{
    m_partitions = x.m_partitions;
    m_group_data = x.m_group_data;

    return *this;
}

eprosima::micrortps::OBJK_PUB_QosBinary& eprosima::micrortps::OBJK_PUB_QosBinary::operator=(OBJK_PUB_QosBinary&& x)
{
    m_partitions = std::move(x.m_partitions);
    m_group_data = std::move(x.m_group_data);

    return *this;
}

size_t eprosima::micrortps::OBJK_PUB_QosBinary::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;
    }
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::OBJK_PUB_QosBinary::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < m_partitions.size(); ++a)
    {
        current_alignment +=
            4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + m_partitions.at(a).size() + 1;
    }
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (m_group_data.size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_PUB_QosBinary::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_partitions;
    scdr << m_group_data;
}

void eprosima::micrortps::OBJK_PUB_QosBinary::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_partitions;
    dcdr >> m_group_data;
}

eprosima::micrortps::OBJK_SUB_QosBinary::OBJK_SUB_QosBinary()
{
}

eprosima::micrortps::OBJK_SUB_QosBinary::~OBJK_SUB_QosBinary()
{
}

eprosima::micrortps::OBJK_SUB_QosBinary::OBJK_SUB_QosBinary(const OBJK_SUB_QosBinary& x)
{
    m_partitions = x.m_partitions;
    m_group_data = x.m_group_data;
}

eprosima::micrortps::OBJK_SUB_QosBinary::OBJK_SUB_QosBinary(OBJK_SUB_QosBinary&& x)
{
    m_partitions = std::move(x.m_partitions);
    m_group_data = std::move(x.m_group_data);
}

eprosima::micrortps::OBJK_SUB_QosBinary& eprosima::micrortps::OBJK_SUB_QosBinary::operator=(const OBJK_SUB_QosBinary& x)
{
    m_partitions = x.m_partitions;
    m_group_data = x.m_group_data;

    return *this;
}

eprosima::micrortps::OBJK_SUB_QosBinary& eprosima::micrortps::OBJK_SUB_QosBinary::operator=(OBJK_SUB_QosBinary&& x)
{
    m_partitions = std::move(x.m_partitions);
    m_group_data = std::move(x.m_group_data);

    return *this;
}

size_t eprosima::micrortps::OBJK_SUB_QosBinary::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;
    }
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::OBJK_SUB_QosBinary::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < m_partitions.size(); ++a)
    {
        current_alignment +=
            4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + m_partitions.at(a).size() + 1;
    }
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (m_group_data.size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_SUB_QosBinary::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_partitions;
    scdr << m_group_data;
}

void eprosima::micrortps::OBJK_SUB_QosBinary::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_partitions;
    dcdr >> m_group_data;
}

eprosima::micrortps::OBJK_Endpoint_QosBinary::OBJK_Endpoint_QosBinary()
{
    m_qos_flags     = eprosima::micrortps::is_reliable;
    m_history_depth = 0;
    m_deadline_msec = 0;
    m_lifespan_msec = 0;
}

eprosima::micrortps::OBJK_Endpoint_QosBinary::~OBJK_Endpoint_QosBinary()
{
}

eprosima::micrortps::OBJK_Endpoint_QosBinary::OBJK_Endpoint_QosBinary(const OBJK_Endpoint_QosBinary& x)
{
    m_qos_flags     = x.m_qos_flags;
    m_history_depth = x.m_history_depth;
    m_deadline_msec = x.m_deadline_msec;
    m_lifespan_msec = x.m_lifespan_msec;
    m_user_data     = x.m_user_data;
}

eprosima::micrortps::OBJK_Endpoint_QosBinary::OBJK_Endpoint_QosBinary(OBJK_Endpoint_QosBinary&& x)
{
    m_qos_flags     = x.m_qos_flags;
    m_history_depth = x.m_history_depth;
    m_deadline_msec = x.m_deadline_msec;
    m_lifespan_msec = x.m_lifespan_msec;
    m_user_data     = std::move(x.m_user_data);
}

eprosima::micrortps::OBJK_Endpoint_QosBinary& eprosima::micrortps::OBJK_Endpoint_QosBinary::
operator=(const OBJK_Endpoint_QosBinary& x)
{
    m_qos_flags     = x.m_qos_flags;
    m_history_depth = x.m_history_depth;
    m_deadline_msec = x.m_deadline_msec;
    m_lifespan_msec = x.m_lifespan_msec;
    m_user_data     = x.m_user_data;

    return *this;
}

eprosima::micrortps::OBJK_Endpoint_QosBinary& eprosima::micrortps::OBJK_Endpoint_QosBinary::
operator=(OBJK_Endpoint_QosBinary&& x)
{
    m_qos_flags     = x.m_qos_flags;
    m_history_depth = x.m_history_depth;
    m_deadline_msec = x.m_deadline_msec;
    m_lifespan_msec = x.m_lifespan_msec;
    m_user_data     = std::move(x.m_user_data);

    return *this;
}

size_t eprosima::micrortps::OBJK_Endpoint_QosBinary::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::OBJK_Endpoint_QosBinary::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (m_user_data.size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_Endpoint_QosBinary::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << (uint32_t)m_qos_flags;
    scdr << m_history_depth;
    scdr << m_deadline_msec;
    scdr << m_lifespan_msec;
    scdr << m_user_data;
}

void eprosima::micrortps::OBJK_Endpoint_QosBinary::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> (uint32_t&)m_qos_flags;
    dcdr >> m_history_depth;
    dcdr >> m_deadline_msec;
    dcdr >> m_lifespan_msec;
    dcdr >> m_user_data;
}

eprosima::micrortps::OBJK_DataReader_Binary::OBJK_DataReader_Binary()
{

    m_timebasedfilter_msec = 0;
}

eprosima::micrortps::OBJK_DataReader_Binary::~OBJK_DataReader_Binary()
{
}

eprosima::micrortps::OBJK_DataReader_Binary::OBJK_DataReader_Binary(const OBJK_DataReader_Binary& x)
{
    m_topic_name           = x.m_topic_name;
    m_endpoint_qos         = x.m_endpoint_qos;
    m_timebasedfilter_msec = x.m_timebasedfilter_msec;
    m_contentbased_filter  = x.m_contentbased_filter;
}

eprosima::micrortps::OBJK_DataReader_Binary::OBJK_DataReader_Binary(OBJK_DataReader_Binary&& x)
{
    m_topic_name           = std::move(x.m_topic_name);
    m_endpoint_qos         = std::move(x.m_endpoint_qos);
    m_timebasedfilter_msec = x.m_timebasedfilter_msec;
    m_contentbased_filter  = std::move(x.m_contentbased_filter);
}

eprosima::micrortps::OBJK_DataReader_Binary& eprosima::micrortps::OBJK_DataReader_Binary::
operator=(const OBJK_DataReader_Binary& x)
{
    m_topic_name           = x.m_topic_name;
    m_endpoint_qos         = x.m_endpoint_qos;
    m_timebasedfilter_msec = x.m_timebasedfilter_msec;
    m_contentbased_filter  = x.m_contentbased_filter;

    return *this;
}

eprosima::micrortps::OBJK_DataReader_Binary& eprosima::micrortps::OBJK_DataReader_Binary::
operator=(OBJK_DataReader_Binary&& x)
{
    m_topic_name           = std::move(x.m_topic_name);
    m_endpoint_qos         = std::move(x.m_endpoint_qos);
    m_timebasedfilter_msec = x.m_timebasedfilter_msec;
    m_contentbased_filter  = std::move(x.m_contentbased_filter);

    return *this;
}

size_t eprosima::micrortps::OBJK_DataReader_Binary::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += eprosima::micrortps::OBJK_Endpoint_QosBinary::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::OBJK_DataReader_Binary::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + m_topic_name.size() + 1;

    current_alignment += m_endpoint_qos.getCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + m_contentbased_filter.size() + 1;

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_DataReader_Binary::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_topic_name;
    scdr << m_endpoint_qos;
    scdr << m_timebasedfilter_msec;
    scdr << m_contentbased_filter;
}

void eprosima::micrortps::OBJK_DataReader_Binary::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_topic_name;
    dcdr >> m_endpoint_qos;
    dcdr >> m_timebasedfilter_msec;
    dcdr >> m_contentbased_filter;
}

eprosima::micrortps::OBJK_DataWriter_Binary::OBJK_DataWriter_Binary()
{

    m_ownership_strength = 0;
}

eprosima::micrortps::OBJK_DataWriter_Binary::~OBJK_DataWriter_Binary()
{
}

eprosima::micrortps::OBJK_DataWriter_Binary::OBJK_DataWriter_Binary(const OBJK_DataWriter_Binary& x)
{
    m_topic_name         = x.m_topic_name;
    m_endpoint_qos       = x.m_endpoint_qos;
    m_ownership_strength = x.m_ownership_strength;
}

eprosima::micrortps::OBJK_DataWriter_Binary::OBJK_DataWriter_Binary(OBJK_DataWriter_Binary&& x)
{
    m_topic_name         = std::move(x.m_topic_name);
    m_endpoint_qos       = std::move(x.m_endpoint_qos);
    m_ownership_strength = x.m_ownership_strength;
}

eprosima::micrortps::OBJK_DataWriter_Binary& eprosima::micrortps::OBJK_DataWriter_Binary::
operator=(const OBJK_DataWriter_Binary& x)
{
    m_topic_name         = x.m_topic_name;
    m_endpoint_qos       = x.m_endpoint_qos;
    m_ownership_strength = x.m_ownership_strength;

    return *this;
}

eprosima::micrortps::OBJK_DataWriter_Binary& eprosima::micrortps::OBJK_DataWriter_Binary::
operator=(OBJK_DataWriter_Binary&& x)
{
    m_topic_name         = std::move(x.m_topic_name);
    m_endpoint_qos       = std::move(x.m_endpoint_qos);
    m_ownership_strength = x.m_ownership_strength;

    return *this;
}

size_t eprosima::micrortps::OBJK_DataWriter_Binary::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    current_alignment += eprosima::micrortps::OBJK_Endpoint_QosBinary::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::OBJK_DataWriter_Binary::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + m_topic_name.size() + 1;

    current_alignment += m_endpoint_qos.getCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_DataWriter_Binary::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_topic_name;
    scdr << m_endpoint_qos;
    scdr << m_ownership_strength;
}

void eprosima::micrortps::OBJK_DataWriter_Binary::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_topic_name;
    dcdr >> m_endpoint_qos;
    dcdr >> m_ownership_strength;
}

eprosima::micrortps::ObjectVariant::ObjectVariant()
{
    m__d = OBJK_INVALID;
}

eprosima::micrortps::ObjectVariant::~ObjectVariant()
{
}

eprosima::micrortps::ObjectVariant::ObjectVariant(const ObjectVariant& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case OBJK_CLIENT:
            m_client = x.m_client;
            break;
        case OBJK_APPLICATION:
            m_application = x.m_application;
            break;
        case OBJK_PARTICIPANT:
            m_participant = x.m_participant;
            break;
        case OBJK_QOSPROFILE:
            m_qos_profile = x.m_qos_profile;
            break;
        case OBJK_TYPE:
            m_type = x.m_type;
            break;
        case OBJK_TOPIC:
            m_topic = x.m_topic;
            break;
        case OBJK_PUBLISHER:
            m_publisher = x.m_publisher;
            break;
        case OBJK_SUBSCRIBER:
            m_subscriber = x.m_subscriber;
            break;
        case OBJK_DATAWRITER:
            m_data_writer = x.m_data_writer;
            break;
        case OBJK_DATAREADER:
            m_data_reader = x.m_data_reader;
            break;
        default:
            break;
    }
}

eprosima::micrortps::ObjectVariant::ObjectVariant(ObjectVariant&& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case OBJK_CLIENT:
            m_client = std::move(x.m_client);
            break;
        case OBJK_APPLICATION:
            m_application = std::move(x.m_application);
            break;
        case OBJK_PARTICIPANT:
            m_participant = std::move(x.m_participant);
            break;
        case OBJK_QOSPROFILE:
            m_qos_profile = std::move(x.m_qos_profile);
            break;
        case OBJK_TYPE:
            m_type = std::move(x.m_type);
            break;
        case OBJK_TOPIC:
            m_topic = std::move(x.m_topic);
            break;
        case OBJK_PUBLISHER:
            m_publisher = std::move(x.m_publisher);
            break;
        case OBJK_SUBSCRIBER:
            m_subscriber = std::move(x.m_subscriber);
            break;
        case OBJK_DATAWRITER:
            m_data_writer = std::move(x.m_data_writer);
            break;
        case OBJK_DATAREADER:
            m_data_reader = std::move(x.m_data_reader);
            break;
        default:
            break;
    }
}

eprosima::micrortps::ObjectVariant& eprosima::micrortps::ObjectVariant::operator=(const ObjectVariant& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case OBJK_CLIENT:
            m_client = x.m_client;
            break;
        case OBJK_APPLICATION:
            m_application = x.m_application;
            break;
        case OBJK_PARTICIPANT:
            m_participant = x.m_participant;
            break;
        case OBJK_QOSPROFILE:
            m_qos_profile = x.m_qos_profile;
            break;
        case OBJK_TYPE:
            m_type = x.m_type;
            break;
        case OBJK_TOPIC:
            m_topic = x.m_topic;
            break;
        case OBJK_PUBLISHER:
            m_publisher = x.m_publisher;
            break;
        case OBJK_SUBSCRIBER:
            m_subscriber = x.m_subscriber;
            break;
        case OBJK_DATAWRITER:
            m_data_writer = x.m_data_writer;
            break;
        case OBJK_DATAREADER:
            m_data_reader = x.m_data_reader;
            break;
        default:
            break;
    }

    return *this;
}

eprosima::micrortps::ObjectVariant& eprosima::micrortps::ObjectVariant::operator=(ObjectVariant&& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case OBJK_CLIENT:
            m_client = std::move(x.m_client);
            break;
        case OBJK_APPLICATION:
            m_application = std::move(x.m_application);
            break;
        case OBJK_PARTICIPANT:
            m_participant = std::move(x.m_participant);
            break;
        case OBJK_QOSPROFILE:
            m_qos_profile = std::move(x.m_qos_profile);
            break;
        case OBJK_TYPE:
            m_type = std::move(x.m_type);
            break;
        case OBJK_TOPIC:
            m_topic = std::move(x.m_topic);
            break;
        case OBJK_PUBLISHER:
            m_publisher = std::move(x.m_publisher);
            break;
        case OBJK_SUBSCRIBER:
            m_subscriber = std::move(x.m_subscriber);
            break;
        case OBJK_DATAWRITER:
            m_data_writer = std::move(x.m_data_writer);
            break;
        case OBJK_DATAREADER:
            m_data_reader = std::move(x.m_data_reader);
            break;
        default:
            break;
    }

    return *this;
}

void eprosima::micrortps::ObjectVariant::_d(eprosima::micrortps::ObjectKind __d)
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_INVALID:
            switch(__d)
            {
                case OBJK_INVALID:
                    b = true;
                    break;
                default:
                    break;
            }
        case OBJK_CLIENT:
            switch(__d)
            {
                case OBJK_CLIENT:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
        case OBJK_APPLICATION:
            switch(__d)
            {
                case OBJK_APPLICATION:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
        case OBJK_PARTICIPANT:
            switch(__d)
            {
                case OBJK_PARTICIPANT:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
        case OBJK_QOSPROFILE:
            switch(__d)
            {
                case OBJK_QOSPROFILE:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
        case OBJK_TYPE:
            switch(__d)
            {
                case OBJK_TYPE:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
        case OBJK_TOPIC:
            switch(__d)
            {
                case OBJK_TOPIC:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
        case OBJK_PUBLISHER:
            switch(__d)
            {
                case OBJK_PUBLISHER:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
        case OBJK_SUBSCRIBER:
            switch(__d)
            {
                case OBJK_SUBSCRIBER:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
        case OBJK_DATAWRITER:
            switch(__d)
            {
                case OBJK_DATAWRITER:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
        case OBJK_DATAREADER:
            switch(__d)
            {
                case OBJK_DATAREADER:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
    }

    if(!b)
        throw BadParamException("Discriminator doesn't correspond with the selected union member");

    m__d = __d;
}

eprosima::micrortps::ObjectKind eprosima::micrortps::ObjectVariant::_d() const
{
    return m__d;
}

eprosima::micrortps::ObjectKind& eprosima::micrortps::ObjectVariant::_d()
{
    return m__d;
}

void eprosima::micrortps::ObjectVariant::client(const eprosima::micrortps::OBJK_CLIENT_Representation& _client)
{
    m_client = _client;
    m__d     = OBJK_CLIENT;
}

void eprosima::micrortps::ObjectVariant::client(eprosima::micrortps::OBJK_CLIENT_Representation&& _client)
{
    m_client = std::move(_client);
    m__d     = OBJK_CLIENT;
}

const eprosima::micrortps::OBJK_CLIENT_Representation& eprosima::micrortps::ObjectVariant::client() const
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_CLIENT:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_client;
}

eprosima::micrortps::OBJK_CLIENT_Representation& eprosima::micrortps::ObjectVariant::client()
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_CLIENT:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_client;
}
void eprosima::micrortps::ObjectVariant::application(
    const eprosima::micrortps::OBJK_APPLICATION_Representation& _application)
{
    m_application = _application;
    m__d          = OBJK_APPLICATION;
}

void eprosima::micrortps::ObjectVariant::application(
    eprosima::micrortps::OBJK_APPLICATION_Representation&& _application)
{
    m_application = std::move(_application);
    m__d          = OBJK_APPLICATION;
}

const eprosima::micrortps::OBJK_APPLICATION_Representation& eprosima::micrortps::ObjectVariant::application() const
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_APPLICATION:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_application;
}

eprosima::micrortps::OBJK_APPLICATION_Representation& eprosima::micrortps::ObjectVariant::application()
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_APPLICATION:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_application;
}
void eprosima::micrortps::ObjectVariant::participant(
    const eprosima::micrortps::OBJK_PARTICIPANT_Representation& _participant)
{
    m_participant = _participant;
    m__d          = OBJK_PARTICIPANT;
}

void eprosima::micrortps::ObjectVariant::participant(
    eprosima::micrortps::OBJK_PARTICIPANT_Representation&& _participant)
{
    m_participant = std::move(_participant);
    m__d          = OBJK_PARTICIPANT;
}

const eprosima::micrortps::OBJK_PARTICIPANT_Representation& eprosima::micrortps::ObjectVariant::participant() const
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_PARTICIPANT:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_participant;
}

eprosima::micrortps::OBJK_PARTICIPANT_Representation& eprosima::micrortps::ObjectVariant::participant()
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_PARTICIPANT:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_participant;
}
void eprosima::micrortps::ObjectVariant::qos_profile(
    const eprosima::micrortps::OBJK_QOSPROFILE_Representation& _qos_profile)
{
    m_qos_profile = _qos_profile;
    m__d          = OBJK_QOSPROFILE;
}

void eprosima::micrortps::ObjectVariant::qos_profile(eprosima::micrortps::OBJK_QOSPROFILE_Representation&& _qos_profile)
{
    m_qos_profile = std::move(_qos_profile);
    m__d          = OBJK_QOSPROFILE;
}

const eprosima::micrortps::OBJK_QOSPROFILE_Representation& eprosima::micrortps::ObjectVariant::qos_profile() const
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_QOSPROFILE:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_qos_profile;
}

eprosima::micrortps::OBJK_QOSPROFILE_Representation& eprosima::micrortps::ObjectVariant::qos_profile()
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_QOSPROFILE:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_qos_profile;
}
void eprosima::micrortps::ObjectVariant::type(const eprosima::micrortps::OBJK_TYPE_Representation& _type)
{
    m_type = _type;
    m__d   = OBJK_TYPE;
}

void eprosima::micrortps::ObjectVariant::type(eprosima::micrortps::OBJK_TYPE_Representation&& _type)
{
    m_type = std::move(_type);
    m__d   = OBJK_TYPE;
}

const eprosima::micrortps::OBJK_TYPE_Representation& eprosima::micrortps::ObjectVariant::type() const
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_TYPE:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_type;
}

eprosima::micrortps::OBJK_TYPE_Representation& eprosima::micrortps::ObjectVariant::type()
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_TYPE:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_type;
}
void eprosima::micrortps::ObjectVariant::topic(const eprosima::micrortps::OBJK_TOPIC_Representation& _topic)
{
    m_topic = _topic;
    m__d    = OBJK_TOPIC;
}

void eprosima::micrortps::ObjectVariant::topic(eprosima::micrortps::OBJK_TOPIC_Representation&& _topic)
{
    m_topic = std::move(_topic);
    m__d    = OBJK_TOPIC;
}

const eprosima::micrortps::OBJK_TOPIC_Representation& eprosima::micrortps::ObjectVariant::topic() const
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_TOPIC:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_topic;
}

eprosima::micrortps::OBJK_TOPIC_Representation& eprosima::micrortps::ObjectVariant::topic()
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_TOPIC:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_topic;
}
void eprosima::micrortps::ObjectVariant::publisher(const eprosima::micrortps::OBJK_PUBLISHER_Representation& _publisher)
{
    m_publisher = _publisher;
    m__d        = OBJK_PUBLISHER;
}

void eprosima::micrortps::ObjectVariant::publisher(eprosima::micrortps::OBJK_PUBLISHER_Representation&& _publisher)
{
    m_publisher = std::move(_publisher);
    m__d        = OBJK_PUBLISHER;
}

const eprosima::micrortps::OBJK_PUBLISHER_Representation& eprosima::micrortps::ObjectVariant::publisher() const
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_PUBLISHER:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_publisher;
}

eprosima::micrortps::OBJK_PUBLISHER_Representation& eprosima::micrortps::ObjectVariant::publisher()
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_PUBLISHER:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_publisher;
}
void eprosima::micrortps::ObjectVariant::subscriber(
    const eprosima::micrortps::OBJK_SUBSCRIBER_Representation& _subscriber)
{
    m_subscriber = _subscriber;
    m__d         = OBJK_SUBSCRIBER;
}

void eprosima::micrortps::ObjectVariant::subscriber(eprosima::micrortps::OBJK_SUBSCRIBER_Representation&& _subscriber)
{
    m_subscriber = std::move(_subscriber);
    m__d         = OBJK_SUBSCRIBER;
}

const eprosima::micrortps::OBJK_SUBSCRIBER_Representation& eprosima::micrortps::ObjectVariant::subscriber() const
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_SUBSCRIBER:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_subscriber;
}

eprosima::micrortps::OBJK_SUBSCRIBER_Representation& eprosima::micrortps::ObjectVariant::subscriber()
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_SUBSCRIBER:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_subscriber;
}
void eprosima::micrortps::ObjectVariant::data_writer(
    const eprosima::micrortps::OBJK_DATA_WRITER_Representation& _data_writer)
{
    m_data_writer = _data_writer;
    m__d          = OBJK_DATAWRITER;
}

void eprosima::micrortps::ObjectVariant::data_writer(
    eprosima::micrortps::OBJK_DATA_WRITER_Representation&& _data_writer)
{
    m_data_writer = std::move(_data_writer);
    m__d          = OBJK_DATAWRITER;
}

const eprosima::micrortps::OBJK_DATA_WRITER_Representation& eprosima::micrortps::ObjectVariant::data_writer() const
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_DATAWRITER:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_data_writer;
}

eprosima::micrortps::OBJK_DATA_WRITER_Representation& eprosima::micrortps::ObjectVariant::data_writer()
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_DATAWRITER:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_data_writer;
}
void eprosima::micrortps::ObjectVariant::data_reader(
    const eprosima::micrortps::OBJK_DATA_READER_Representation& _data_reader)
{
    m_data_reader = _data_reader;
    m__d          = OBJK_DATAREADER;
}

void eprosima::micrortps::ObjectVariant::data_reader(
    eprosima::micrortps::OBJK_DATA_READER_Representation&& _data_reader)
{
    m_data_reader = std::move(_data_reader);
    m__d          = OBJK_DATAREADER;
}

const eprosima::micrortps::OBJK_DATA_READER_Representation& eprosima::micrortps::ObjectVariant::data_reader() const
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_DATAREADER:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_data_reader;
}

eprosima::micrortps::OBJK_DATA_READER_Representation& eprosima::micrortps::ObjectVariant::data_reader()
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_DATAREADER:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_data_reader;
}

size_t eprosima::micrortps::ObjectVariant::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment         = current_alignment;
    size_t reset_alignment           = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    reset_alignment = current_alignment;

    reset_alignment += eprosima::micrortps::OBJK_CLIENT_Representation::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += eprosima::micrortps::OBJK_APPLICATION_Representation::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += eprosima::micrortps::OBJK_PARTICIPANT_Representation::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += eprosima::micrortps::OBJK_QOSPROFILE_Representation::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += eprosima::micrortps::OBJK_TYPE_Representation::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += eprosima::micrortps::OBJK_TOPIC_Representation::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += eprosima::micrortps::OBJK_PUBLISHER_Representation::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += eprosima::micrortps::OBJK_SUBSCRIBER_Representation::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += eprosima::micrortps::OBJK_DATA_WRITER_Representation::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += eprosima::micrortps::OBJK_DATA_READER_Representation::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    return union_max_size_serialized - initial_alignment;
}

// TODO(Ricardo) Review
size_t eprosima::micrortps::ObjectVariant::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(m__d)
    {
        case OBJK_CLIENT:
            current_alignment += m_client.getCdrSerializedSize(current_alignment);
            break;
        case OBJK_APPLICATION:
            current_alignment += m_application.getCdrSerializedSize(current_alignment);
            break;
        case OBJK_PARTICIPANT:
            current_alignment += m_participant.getCdrSerializedSize(current_alignment);
            break;
        case OBJK_QOSPROFILE:
            current_alignment += m_qos_profile.getCdrSerializedSize(current_alignment);
            break;
        case OBJK_TYPE:
            current_alignment += m_type.getCdrSerializedSize(current_alignment);
            break;
        case OBJK_TOPIC:
            current_alignment += m_topic.getCdrSerializedSize(current_alignment);
            break;
        case OBJK_PUBLISHER:
            current_alignment += m_publisher.getCdrSerializedSize(current_alignment);
            break;
        case OBJK_SUBSCRIBER:
            current_alignment += m_subscriber.getCdrSerializedSize(current_alignment);
            break;
        case OBJK_DATAWRITER:
            current_alignment += m_data_writer.getCdrSerializedSize(current_alignment);
            break;
        case OBJK_DATAREADER:
            current_alignment += m_data_reader.getCdrSerializedSize(current_alignment);
            break;
        default:
            break;
    }

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::ObjectVariant::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case OBJK_CLIENT:
            scdr << m_client;
            break;
        case OBJK_APPLICATION:
            scdr << m_application;
            break;
        case OBJK_PARTICIPANT:
            scdr << m_participant;
            break;
        case OBJK_QOSPROFILE:
            scdr << m_qos_profile;
            break;
        case OBJK_TYPE:
            scdr << m_type;
            break;
        case OBJK_TOPIC:
            scdr << m_topic;
            break;
        case OBJK_PUBLISHER:
            scdr << m_publisher;
            break;
        case OBJK_SUBSCRIBER:
            scdr << m_subscriber;
            break;
        case OBJK_DATAWRITER:
            scdr << m_data_writer;
            break;
        case OBJK_DATAREADER:
            scdr << m_data_reader;
            break;
        default:
            break;
    }
}

void eprosima::micrortps::ObjectVariant::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case OBJK_CLIENT:
            dcdr >> m_client;
            break;
        case OBJK_APPLICATION:
            dcdr >> m_application;
            break;
        case OBJK_PARTICIPANT:
            dcdr >> m_participant;
            break;
        case OBJK_QOSPROFILE:
            dcdr >> m_qos_profile;
            break;
        case OBJK_TYPE:
            dcdr >> m_type;
            break;
        case OBJK_TOPIC:
            dcdr >> m_topic;
            break;
        case OBJK_PUBLISHER:
            dcdr >> m_publisher;
            break;
        case OBJK_SUBSCRIBER:
            dcdr >> m_subscriber;
            break;
        case OBJK_DATAWRITER:
            dcdr >> m_data_writer;
            break;
        case OBJK_DATAREADER:
            dcdr >> m_data_reader;
            break;
        default:
            break;
    }
}

eprosima::micrortps::CreationMode::CreationMode()
{
    m_reuse   = false;
    m_replace = false;
}

eprosima::micrortps::CreationMode::~CreationMode()
{
}

eprosima::micrortps::CreationMode::CreationMode(const CreationMode& x)
{
    m_reuse   = x.m_reuse;
    m_replace = x.m_replace;
}

eprosima::micrortps::CreationMode::CreationMode(CreationMode&& x)
{
    m_reuse   = x.m_reuse;
    m_replace = x.m_replace;
}

eprosima::micrortps::CreationMode& eprosima::micrortps::CreationMode::operator=(const CreationMode& x)
{
    m_reuse   = x.m_reuse;
    m_replace = x.m_replace;

    return *this;
}

eprosima::micrortps::CreationMode& eprosima::micrortps::CreationMode::operator=(CreationMode&& x)
{
    m_reuse   = x.m_reuse;
    m_replace = x.m_replace;

    return *this;
}

size_t eprosima::micrortps::CreationMode::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::CreationMode::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::CreationMode::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_reuse;
    scdr << m_replace;
}

void eprosima::micrortps::CreationMode::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_reuse;
    dcdr >> m_replace;
}

eprosima::micrortps::ResultStatus::ResultStatus()
{

    m_status                = 0;
    m_implementation_status = 0;
}

eprosima::micrortps::ResultStatus::~ResultStatus()
{
}

eprosima::micrortps::ResultStatus::ResultStatus(const ResultStatus& x)
{
    m_request_id            = x.m_request_id;
    m_status                = x.m_status;
    m_implementation_status = x.m_implementation_status;
}

eprosima::micrortps::ResultStatus::ResultStatus(ResultStatus&& x)
{
    m_request_id            = std::move(x.m_request_id);
    m_status                = x.m_status;
    m_implementation_status = x.m_implementation_status;
}

eprosima::micrortps::ResultStatus& eprosima::micrortps::ResultStatus::operator=(const ResultStatus& x)
{
    m_request_id            = x.m_request_id;
    m_status                = x.m_status;
    m_implementation_status = x.m_implementation_status;

    return *this;
}

eprosima::micrortps::ResultStatus& eprosima::micrortps::ResultStatus::operator=(ResultStatus&& x)
{
    m_request_id            = std::move(x.m_request_id);
    m_status                = x.m_status;
    m_implementation_status = x.m_implementation_status;

    return *this;
}

size_t eprosima::micrortps::ResultStatus::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::ResultStatus::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::ResultStatus::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_request_id;
    scdr << m_status;
    scdr << m_implementation_status;
}

void eprosima::micrortps::ResultStatus::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_request_id;
    dcdr >> m_status;
    dcdr >> m_implementation_status;
}

eprosima::micrortps::OBJK_DATAREADER_ActivityInfo::OBJK_DATAREADER_ActivityInfo()
{
    m_highest_acked_num = 0;
}

eprosima::micrortps::OBJK_DATAREADER_ActivityInfo::~OBJK_DATAREADER_ActivityInfo()
{
}

eprosima::micrortps::OBJK_DATAREADER_ActivityInfo::OBJK_DATAREADER_ActivityInfo(const OBJK_DATAREADER_ActivityInfo& x)
{
    m_highest_acked_num = x.m_highest_acked_num;
}

eprosima::micrortps::OBJK_DATAREADER_ActivityInfo::OBJK_DATAREADER_ActivityInfo(OBJK_DATAREADER_ActivityInfo&& x)
{
    m_highest_acked_num = x.m_highest_acked_num;
}

eprosima::micrortps::OBJK_DATAREADER_ActivityInfo& eprosima::micrortps::OBJK_DATAREADER_ActivityInfo::
operator=(const OBJK_DATAREADER_ActivityInfo& x)
{
    m_highest_acked_num = x.m_highest_acked_num;

    return *this;
}

eprosima::micrortps::OBJK_DATAREADER_ActivityInfo& eprosima::micrortps::OBJK_DATAREADER_ActivityInfo::
operator=(OBJK_DATAREADER_ActivityInfo&& x)
{
    m_highest_acked_num = x.m_highest_acked_num;

    return *this;
}

size_t eprosima::micrortps::OBJK_DATAREADER_ActivityInfo::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::OBJK_DATAREADER_ActivityInfo::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_DATAREADER_ActivityInfo::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_highest_acked_num;
}

void eprosima::micrortps::OBJK_DATAREADER_ActivityInfo::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_highest_acked_num;
}

eprosima::micrortps::OBJK_DATAWRITER_ActivityInfo::OBJK_DATAWRITER_ActivityInfo()
{
    m_stream_seq_num = 0;
    m_sample_seq_num = 0;
}

eprosima::micrortps::OBJK_DATAWRITER_ActivityInfo::~OBJK_DATAWRITER_ActivityInfo()
{
}

eprosima::micrortps::OBJK_DATAWRITER_ActivityInfo::OBJK_DATAWRITER_ActivityInfo(const OBJK_DATAWRITER_ActivityInfo& x)
{
    m_stream_seq_num = x.m_stream_seq_num;
    m_sample_seq_num = x.m_sample_seq_num;
}

eprosima::micrortps::OBJK_DATAWRITER_ActivityInfo::OBJK_DATAWRITER_ActivityInfo(OBJK_DATAWRITER_ActivityInfo&& x)
{
    m_stream_seq_num = x.m_stream_seq_num;
    m_sample_seq_num = x.m_sample_seq_num;
}

eprosima::micrortps::OBJK_DATAWRITER_ActivityInfo& eprosima::micrortps::OBJK_DATAWRITER_ActivityInfo::
operator=(const OBJK_DATAWRITER_ActivityInfo& x)
{
    m_stream_seq_num = x.m_stream_seq_num;
    m_sample_seq_num = x.m_sample_seq_num;

    return *this;
}

eprosima::micrortps::OBJK_DATAWRITER_ActivityInfo& eprosima::micrortps::OBJK_DATAWRITER_ActivityInfo::
operator=(OBJK_DATAWRITER_ActivityInfo&& x)
{
    m_stream_seq_num = x.m_stream_seq_num;
    m_sample_seq_num = x.m_sample_seq_num;

    return *this;
}

size_t eprosima::micrortps::OBJK_DATAWRITER_ActivityInfo::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::OBJK_DATAWRITER_ActivityInfo::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::OBJK_DATAWRITER_ActivityInfo::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_stream_seq_num;
    scdr << m_sample_seq_num;
}

void eprosima::micrortps::OBJK_DATAWRITER_ActivityInfo::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_stream_seq_num;
    dcdr >> m_sample_seq_num;
}

eprosima::micrortps::ActivityInfoVariant::ActivityInfoVariant()
{
    m__d = OBJK_DATAWRITER;
}

eprosima::micrortps::ActivityInfoVariant::~ActivityInfoVariant()
{
}

eprosima::micrortps::ActivityInfoVariant::ActivityInfoVariant(const ActivityInfoVariant& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case OBJK_DATAWRITER:
            m_data_writer = x.m_data_writer;
            break;
        case OBJK_DATAREADER:
            m_data_reader = x.m_data_reader;
            break;
        default:
            break;
    }
}

eprosima::micrortps::ActivityInfoVariant::ActivityInfoVariant(ActivityInfoVariant&& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case OBJK_DATAWRITER:
            m_data_writer = std::move(x.m_data_writer);
            break;
        case OBJK_DATAREADER:
            m_data_reader = std::move(x.m_data_reader);
            break;
        default:
            break;
    }
}

eprosima::micrortps::ActivityInfoVariant& eprosima::micrortps::ActivityInfoVariant::
operator=(const ActivityInfoVariant& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case OBJK_DATAWRITER:
            m_data_writer = x.m_data_writer;
            break;
        case OBJK_DATAREADER:
            m_data_reader = x.m_data_reader;
            break;
        default:
            break;
    }

    return *this;
}

eprosima::micrortps::ActivityInfoVariant& eprosima::micrortps::ActivityInfoVariant::operator=(ActivityInfoVariant&& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case OBJK_DATAWRITER:
            m_data_writer = std::move(x.m_data_writer);
            break;
        case OBJK_DATAREADER:
            m_data_reader = std::move(x.m_data_reader);
            break;
        default:
            break;
    }

    return *this;
}

void eprosima::micrortps::ActivityInfoVariant::_d(eprosima::micrortps::ObjectKind __d)
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_DATAWRITER:
            switch(__d)
            {
                case OBJK_DATAWRITER:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
        case OBJK_DATAREADER:
            switch(__d)
            {
                case OBJK_DATAREADER:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
    }

    if(!b)
        throw BadParamException("Discriminator doesn't correspond with the selected union member");

    m__d = __d;
}

eprosima::micrortps::ObjectKind eprosima::micrortps::ActivityInfoVariant::_d() const
{
    return m__d;
}

eprosima::micrortps::ObjectKind& eprosima::micrortps::ActivityInfoVariant::_d()
{
    return m__d;
}

void eprosima::micrortps::ActivityInfoVariant::data_writer(
    const eprosima::micrortps::OBJK_DATAWRITER_ActivityInfo& _data_writer)
{
    m_data_writer = _data_writer;
    m__d          = OBJK_DATAWRITER;
}

void eprosima::micrortps::ActivityInfoVariant::data_writer(
    eprosima::micrortps::OBJK_DATAWRITER_ActivityInfo&& _data_writer)
{
    m_data_writer = std::move(_data_writer);
    m__d          = OBJK_DATAWRITER;
}

const eprosima::micrortps::OBJK_DATAWRITER_ActivityInfo& eprosima::micrortps::ActivityInfoVariant::data_writer() const
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_DATAWRITER:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_data_writer;
}

eprosima::micrortps::OBJK_DATAWRITER_ActivityInfo& eprosima::micrortps::ActivityInfoVariant::data_writer()
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_DATAWRITER:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_data_writer;
}
void eprosima::micrortps::ActivityInfoVariant::data_reader(
    const eprosima::micrortps::OBJK_DATAREADER_ActivityInfo& _data_reader)
{
    m_data_reader = _data_reader;
    m__d          = OBJK_DATAREADER;
}

void eprosima::micrortps::ActivityInfoVariant::data_reader(
    eprosima::micrortps::OBJK_DATAREADER_ActivityInfo&& _data_reader)
{
    m_data_reader = std::move(_data_reader);
    m__d          = OBJK_DATAREADER;
}

const eprosima::micrortps::OBJK_DATAREADER_ActivityInfo& eprosima::micrortps::ActivityInfoVariant::data_reader() const
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_DATAREADER:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_data_reader;
}

eprosima::micrortps::OBJK_DATAREADER_ActivityInfo& eprosima::micrortps::ActivityInfoVariant::data_reader()
{
    bool b = false;

    switch(m__d)
    {
        case OBJK_DATAREADER:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_data_reader;
}

size_t eprosima::micrortps::ActivityInfoVariant::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment         = current_alignment;
    size_t reset_alignment           = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    reset_alignment = current_alignment;

    reset_alignment += eprosima::micrortps::OBJK_DATAWRITER_ActivityInfo::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += eprosima::micrortps::OBJK_DATAREADER_ActivityInfo::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    return union_max_size_serialized - initial_alignment;
}

// TODO(Ricardo) Review
size_t eprosima::micrortps::ActivityInfoVariant::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(m__d)
    {
        case OBJK_DATAWRITER:
            current_alignment += m_data_writer.getCdrSerializedSize(current_alignment);
            break;
        case OBJK_DATAREADER:
            current_alignment += m_data_reader.getCdrSerializedSize(current_alignment);
            break;
        default:
            break;
    }

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::ActivityInfoVariant::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case OBJK_DATAWRITER:
            scdr << m_data_writer;
            break;
        case OBJK_DATAREADER:
            scdr << m_data_reader;
            break;
        default:
            break;
    }
}

void eprosima::micrortps::ActivityInfoVariant::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case OBJK_DATAWRITER:
            dcdr >> m_data_writer;
            break;
        case OBJK_DATAREADER:
            dcdr >> m_data_reader;
            break;
        default:
            break;
    }
}

eprosima::micrortps::Info::Info()
{
}

eprosima::micrortps::Info::~Info()
{
}

eprosima::micrortps::Info::Info(const Info& x)
{
    m_config   = x.m_config;
    m_activity = x.m_activity;
}

eprosima::micrortps::Info::Info(Info&& x)
{
    m_config   = std::move(x.m_config);
    m_activity = std::move(x.m_activity);
}

eprosima::micrortps::Info& eprosima::micrortps::Info::operator=(const Info& x)
{
    m_config   = x.m_config;
    m_activity = x.m_activity;

    return *this;
}

eprosima::micrortps::Info& eprosima::micrortps::Info::operator=(Info&& x)
{
    m_config   = std::move(x.m_config);
    m_activity = std::move(x.m_activity);

    return *this;
}

size_t eprosima::micrortps::Info::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::ObjectVariant::getMaxCdrSerializedSize(current_alignment);
    current_alignment += eprosima::micrortps::ActivityInfoVariant::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::Info::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += m_config.getCdrSerializedSize(current_alignment);
    current_alignment += m_activity.getCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::Info::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_config;
    scdr << m_activity;
}

void eprosima::micrortps::Info::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_config;
    dcdr >> m_activity;
}

eprosima::micrortps::BaseRequest::BaseRequest()
{
}

eprosima::micrortps::BaseRequest::~BaseRequest()
{
}

eprosima::micrortps::BaseRequest::BaseRequest(const BaseRequest& x)
{
    m_request_id = x.m_request_id;
    m_object_id  = x.m_object_id;
}

eprosima::micrortps::BaseRequest::BaseRequest(BaseRequest&& x)
{
    m_request_id = std::move(x.m_request_id);
    m_object_id  = std::move(x.m_object_id);
}

eprosima::micrortps::BaseRequest& eprosima::micrortps::BaseRequest::operator=(const BaseRequest& x)
{
    m_request_id = x.m_request_id;
    m_object_id  = x.m_object_id;

    return *this;
}

eprosima::micrortps::BaseRequest& eprosima::micrortps::BaseRequest::operator=(BaseRequest&& x)
{
    m_request_id = std::move(x.m_request_id);
    m_object_id  = std::move(x.m_object_id);

    return *this;
}

size_t eprosima::micrortps::BaseRequest::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::BaseRequest::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::BaseRequest::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_request_id;
    scdr << m_object_id;
}

void eprosima::micrortps::BaseRequest::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_request_id;
    dcdr >> m_object_id;
}

eprosima::micrortps::BaseObjectRequest::BaseObjectRequest()
{
}

eprosima::micrortps::BaseObjectRequest::~BaseObjectRequest()
{
}

eprosima::micrortps::BaseObjectRequest::BaseObjectRequest(const BaseObjectRequest& x) : BaseRequest(x)
{
    m_object_id = x.m_object_id;
}

eprosima::micrortps::BaseObjectRequest::BaseObjectRequest(BaseObjectRequest&& x) : BaseRequest(x)
{
    m_object_id = std::move(x.m_object_id);
}

eprosima::micrortps::BaseObjectRequest& eprosima::micrortps::BaseObjectRequest::operator=(const BaseObjectRequest& x)
{
    BaseRequest::operator=(x);
    m_object_id          = x.m_object_id;

    return *this;
}

eprosima::micrortps::BaseObjectRequest& eprosima::micrortps::BaseObjectRequest::operator=(BaseObjectRequest&& x)
{
    BaseRequest::operator=(x);
    m_object_id          = std::move(x.m_object_id);

    return *this;
}

size_t eprosima::micrortps::BaseObjectRequest::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::BaseRequest::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::BaseObjectRequest::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::BaseRequest::getCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::BaseObjectRequest::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    BaseRequest::serialize(scdr);
    scdr << m_object_id;
}

void eprosima::micrortps::BaseObjectRequest::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    BaseRequest::deserialize(dcdr);
    dcdr >> m_object_id;
}

eprosima::micrortps::BaseReply::BaseReply()
{
}

eprosima::micrortps::BaseReply::~BaseReply()
{
}

eprosima::micrortps::BaseReply::BaseReply(const BaseReply& x)
{
    m_result     = x.m_result;
    m_request_id = x.m_request_id;
}

eprosima::micrortps::BaseReply::BaseReply(BaseReply&& x)
{
    m_result     = std::move(x.m_result);
    m_request_id = std::move(x.m_request_id);
}

eprosima::micrortps::BaseReply& eprosima::micrortps::BaseReply::operator=(const BaseReply& x)
{
    m_result     = x.m_result;
    m_request_id = x.m_request_id;

    return *this;
}

eprosima::micrortps::BaseReply& eprosima::micrortps::BaseReply::operator=(BaseReply&& x)
{
    m_result     = std::move(x.m_result);
    m_request_id = std::move(x.m_request_id);

    return *this;
}

size_t eprosima::micrortps::BaseReply::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::ResultStatus::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::BaseReply::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += m_result.getCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::BaseReply::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_result;
    scdr << m_request_id;
}

void eprosima::micrortps::BaseReply::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_result;
    dcdr >> m_request_id;
}

eprosima::micrortps::BaseObjectReply::BaseObjectReply()
{
}

eprosima::micrortps::BaseObjectReply::~BaseObjectReply()
{
}

eprosima::micrortps::BaseObjectReply::BaseObjectReply(const BaseObjectReply& x) : BaseReply(x)
{
    m_object_id = x.m_object_id;
}

eprosima::micrortps::BaseObjectReply::BaseObjectReply(BaseObjectReply&& x) : BaseReply(x)
{
    m_object_id = std::move(x.m_object_id);
}

eprosima::micrortps::BaseObjectReply& eprosima::micrortps::BaseObjectReply::operator=(const BaseObjectReply& x)
{
    BaseReply::operator=(x);
    m_object_id        = x.m_object_id;

    return *this;
}

eprosima::micrortps::BaseObjectReply& eprosima::micrortps::BaseObjectReply::operator=(BaseObjectReply&& x)
{
    BaseReply::operator=(x);
    m_object_id        = std::move(x.m_object_id);

    return *this;
}

size_t eprosima::micrortps::BaseObjectReply::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::BaseReply::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::BaseObjectReply::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::BaseReply::getCdrSerializedSize(current_alignment);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::BaseObjectReply::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    BaseReply::serialize(scdr);
    scdr << m_object_id;
}

void eprosima::micrortps::BaseObjectReply::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    BaseReply::deserialize(dcdr);
    dcdr >> m_object_id;
}

eprosima::micrortps::InfoReply::InfoReply()
{
}

eprosima::micrortps::InfoReply::~InfoReply()
{
}

eprosima::micrortps::InfoReply::InfoReply(const InfoReply& x) : BaseObjectReply(x)
{
    m_info = x.m_info;
}

eprosima::micrortps::InfoReply::InfoReply(InfoReply&& x) : BaseObjectReply(x)
{
    m_info = std::move(x.m_info);
}

eprosima::micrortps::InfoReply& eprosima::micrortps::InfoReply::operator=(const InfoReply& x)
{
    BaseObjectReply::operator=(x);
    m_info                   = x.m_info;

    return *this;
}

eprosima::micrortps::InfoReply& eprosima::micrortps::InfoReply::operator=(InfoReply&& x)
{
    BaseObjectReply::operator=(x);
    m_info                   = std::move(x.m_info);

    return *this;
}

size_t eprosima::micrortps::InfoReply::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::BaseObjectReply::getMaxCdrSerializedSize(current_alignment);
    current_alignment += eprosima::micrortps::ObjectVariant::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::InfoReply::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::BaseObjectReply::getCdrSerializedSize(current_alignment);
    current_alignment += m_info.getCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::InfoReply::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    BaseObjectReply::serialize(scdr);
    scdr << m_info;
}

void eprosima::micrortps::InfoReply::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    BaseObjectReply::deserialize(dcdr);
    dcdr >> m_info;
}

eprosima::micrortps::DataDeliveryControl::DataDeliveryControl()
{
    m_max_samples      = 0;
    m_max_elapsed_time = 0;
    m_max_rate         = 0;
}

eprosima::micrortps::DataDeliveryControl::~DataDeliveryControl()
{
}

eprosima::micrortps::DataDeliveryControl::DataDeliveryControl(const DataDeliveryControl& x)
{
    m_max_samples      = x.m_max_samples;
    m_max_elapsed_time = x.m_max_elapsed_time;
    m_max_rate         = x.m_max_rate;
}

eprosima::micrortps::DataDeliveryControl::DataDeliveryControl(DataDeliveryControl&& x)
{
    m_max_samples      = x.m_max_samples;
    m_max_elapsed_time = x.m_max_elapsed_time;
    m_max_rate         = x.m_max_rate;
}

eprosima::micrortps::DataDeliveryControl& eprosima::micrortps::DataDeliveryControl::
operator=(const DataDeliveryControl& x)
{
    m_max_samples      = x.m_max_samples;
    m_max_elapsed_time = x.m_max_elapsed_time;
    m_max_rate         = x.m_max_rate;

    return *this;
}

eprosima::micrortps::DataDeliveryControl& eprosima::micrortps::DataDeliveryControl::operator=(DataDeliveryControl&& x)
{
    m_max_samples      = x.m_max_samples;
    m_max_elapsed_time = x.m_max_elapsed_time;
    m_max_rate         = x.m_max_rate;

    return *this;
}

size_t eprosima::micrortps::DataDeliveryControl::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::DataDeliveryControl::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::DataDeliveryControl::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_max_samples;
    scdr << m_max_elapsed_time;
    scdr << m_max_rate;
}

void eprosima::micrortps::DataDeliveryControl::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_max_samples;
    dcdr >> m_max_elapsed_time;
    dcdr >> m_max_rate;
}

eprosima::micrortps::DataDeliveryConfig::DataDeliveryConfig()
{
    m__d = FORMAT_DATA_SEQ;
}

eprosima::micrortps::DataDeliveryConfig::~DataDeliveryConfig()
{
}

eprosima::micrortps::DataDeliveryConfig::DataDeliveryConfig(const DataDeliveryConfig& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
        case FORMAT_SAMPLE_SEQ:
        case FORMAT_PACKED_SAMPLES:
            m_delivey_control = x.m_delivey_control;
            break;
        case FORMAT_DATA:
        case FORMAT_SAMPLE:
        default:
            break;
    }
}

eprosima::micrortps::DataDeliveryConfig::DataDeliveryConfig(DataDeliveryConfig&& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
        case FORMAT_SAMPLE_SEQ:
        case FORMAT_PACKED_SAMPLES:
            m_delivey_control = std::move(x.m_delivey_control);
            break;
        case FORMAT_DATA:
        case FORMAT_SAMPLE:
        default:
            break;
    }
}

eprosima::micrortps::DataDeliveryConfig& eprosima::micrortps::DataDeliveryConfig::operator=(const DataDeliveryConfig& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
        case FORMAT_SAMPLE_SEQ:
        case FORMAT_PACKED_SAMPLES:
            m_delivey_control = x.m_delivey_control;
            break;
        case FORMAT_DATA:
        case FORMAT_SAMPLE:
        default:
            break;
    }

    return *this;
}

eprosima::micrortps::DataDeliveryConfig& eprosima::micrortps::DataDeliveryConfig::operator=(DataDeliveryConfig&& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
        case FORMAT_SAMPLE_SEQ:
        case FORMAT_PACKED_SAMPLES:
            m_delivey_control = std::move(x.m_delivey_control);
            break;
        case FORMAT_DATA:
        case FORMAT_SAMPLE:
        default:
            break;
    }

    return *this;
}

void eprosima::micrortps::DataDeliveryConfig::_d(eprosima::micrortps::DataFormat __d)
{
    bool b = false;

    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
            switch(__d)
            {
                case FORMAT_DATA_SEQ:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
        case FORMAT_SAMPLE_SEQ:
            switch(__d)
            {
                case FORMAT_SAMPLE_SEQ:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
        case FORMAT_PACKED_SAMPLES:
            switch(__d)
            {
                case FORMAT_PACKED_SAMPLES:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
        case FORMAT_DATA:
            switch(__d)
            {
                case FORMAT_DATA:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
        case FORMAT_SAMPLE:
            switch(__d)
            {
                case FORMAT_SAMPLE:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
    }

    if(!b)
        throw BadParamException("Discriminator doesn't correspond with the selected union member");

    m__d = __d;
}

eprosima::micrortps::DataFormat eprosima::micrortps::DataDeliveryConfig::_d() const
{
    return m__d;
}

eprosima::micrortps::DataFormat& eprosima::micrortps::DataDeliveryConfig::_d()
{
    return m__d;
}

void eprosima::micrortps::DataDeliveryConfig::delivey_control(
    const eprosima::micrortps::DataDeliveryControl& _delivey_control, const DataFormat& format)
{
    m_delivey_control = _delivey_control;
    m__d              = format;
}

void eprosima::micrortps::DataDeliveryConfig::delivey_control(
    eprosima::micrortps::DataDeliveryControl&& _delivey_control, const DataFormat& format)
{
    m_delivey_control = std::move(_delivey_control);
    m__d              = format;
}

const eprosima::micrortps::DataDeliveryControl& eprosima::micrortps::DataDeliveryConfig::delivey_control() const
{
    bool b = false;

    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
        case FORMAT_SAMPLE_SEQ:
        case FORMAT_PACKED_SAMPLES:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_delivey_control;
}

eprosima::micrortps::DataDeliveryControl& eprosima::micrortps::DataDeliveryConfig::delivey_control()
{
    bool b = false;

    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
        case FORMAT_SAMPLE_SEQ:
        case FORMAT_PACKED_SAMPLES:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_delivey_control;
}

size_t eprosima::micrortps::DataDeliveryConfig::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment         = current_alignment;
    size_t reset_alignment           = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    reset_alignment = current_alignment;

    reset_alignment += eprosima::micrortps::DataDeliveryControl::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += 1 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 1);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    return union_max_size_serialized - initial_alignment;
}

// TODO(Ricardo) Review
size_t eprosima::micrortps::DataDeliveryConfig::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
        case FORMAT_SAMPLE_SEQ:
        case FORMAT_PACKED_SAMPLES:
            current_alignment += m_delivey_control.getCdrSerializedSize(current_alignment);
            break;
        case FORMAT_DATA:
        case FORMAT_SAMPLE:
        default:
            break;
    }

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::DataDeliveryConfig::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
        case FORMAT_SAMPLE_SEQ:
        case FORMAT_PACKED_SAMPLES:
            scdr << m_delivey_control;
            break;
        case FORMAT_DATA:
        case FORMAT_SAMPLE:
        default:
            break;
    }
}

void eprosima::micrortps::DataDeliveryConfig::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
        case FORMAT_SAMPLE_SEQ:
        case FORMAT_PACKED_SAMPLES:
            dcdr >> m_delivey_control;
            break;
        case FORMAT_DATA:
        case FORMAT_SAMPLE:
        default:
            break;
    }
}

eprosima::micrortps::ReadSpecification::ReadSpecification()
{
}

eprosima::micrortps::ReadSpecification::~ReadSpecification()
{
}

eprosima::micrortps::ReadSpecification::ReadSpecification(const ReadSpecification& x)
{
    m_content_filter_expression = x.m_content_filter_expression;
    m_delivery_config           = x.m_delivery_config;
}

eprosima::micrortps::ReadSpecification::ReadSpecification(ReadSpecification&& x)
{
    m_content_filter_expression = std::move(x.m_content_filter_expression);
    m_delivery_config           = std::move(x.m_delivery_config);
}

eprosima::micrortps::ReadSpecification& eprosima::micrortps::ReadSpecification::operator=(const ReadSpecification& x)
{
    m_content_filter_expression = x.m_content_filter_expression;
    m_delivery_config           = x.m_delivery_config;

    return *this;
}

eprosima::micrortps::ReadSpecification& eprosima::micrortps::ReadSpecification::operator=(ReadSpecification&& x)
{
    m_content_filter_expression = std::move(x.m_content_filter_expression);
    m_delivery_config           = std::move(x.m_delivery_config);

    return *this;
}

const std::string& eprosima::micrortps::ReadSpecification::content_filter_expression() const
{
    if(!m_content_filter_expression)
    {
        throw BadParamException("Optional member is not been selected");
    }
    return *m_content_filter_expression;
}

std::string& eprosima::micrortps::ReadSpecification::content_filter_expression()
{
    if(!m_content_filter_expression)
    {
        throw BadParamException("Optional member is not been selected");
    }
    return *m_content_filter_expression;
}

size_t eprosima::micrortps::ReadSpecification::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;
    current_alignment += eprosima::micrortps::DataDeliveryConfig::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::ReadSpecification::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    if(m_content_filter_expression)
    {
        current_alignment +=
            4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + m_content_filter_expression->size() + 1;
    }

    current_alignment += m_delivery_config.getCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::ReadSpecification::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << static_cast<bool>(m_content_filter_expression);
    if(m_content_filter_expression)
    {
        scdr << *m_content_filter_expression;
    }

    scdr << m_delivery_config;
}

void eprosima::micrortps::ReadSpecification::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    bool optional_present = false;
    dcdr >> optional_present;
    if(optional_present)
    {
        // Workaround Optional interface flaw with operator*. Using operator* to set a value does not change the
        // presence flag.
        std::string temp_content_filter;
        dcdr >> temp_content_filter;
        m_content_filter_expression = temp_content_filter;
    }
    dcdr >> m_delivery_config;
}

eprosima::micrortps::SampleInfo::SampleInfo()
{
    m_state               = 0;
    m_sequence_number     = 0;
    m_session_time_offset = 0;
}

eprosima::micrortps::SampleInfo::~SampleInfo()
{
}

eprosima::micrortps::SampleInfo::SampleInfo(const SampleInfo& x)
{
    m_state               = x.m_state;
    m_sequence_number     = x.m_sequence_number;
    m_session_time_offset = x.m_session_time_offset;
}

eprosima::micrortps::SampleInfo::SampleInfo(SampleInfo&& x)
{
    m_state               = x.m_state;
    m_sequence_number     = x.m_sequence_number;
    m_session_time_offset = x.m_session_time_offset;
}

eprosima::micrortps::SampleInfo& eprosima::micrortps::SampleInfo::operator=(const SampleInfo& x)
{
    m_state               = x.m_state;
    m_sequence_number     = x.m_sequence_number;
    m_session_time_offset = x.m_session_time_offset;

    return *this;
}

eprosima::micrortps::SampleInfo& eprosima::micrortps::SampleInfo::operator=(SampleInfo&& x)
{
    m_state               = x.m_state;
    m_sequence_number     = x.m_sequence_number;
    m_session_time_offset = x.m_session_time_offset;

    return *this;
}

size_t eprosima::micrortps::SampleInfo::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::SampleInfo::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::SampleInfo::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_state;
    scdr << m_sequence_number;
    scdr << m_session_time_offset;
}

void eprosima::micrortps::SampleInfo::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_state;
    dcdr >> m_sequence_number;
    dcdr >> m_session_time_offset;
}

eprosima::micrortps::SampleInfoDelta::SampleInfoDelta()
{
    m_state            = 0;
    m_seq_number_delta = 0;
    m_timestamp_delta  = 0;
}

eprosima::micrortps::SampleInfoDelta::~SampleInfoDelta()
{
}

eprosima::micrortps::SampleInfoDelta::SampleInfoDelta(const SampleInfoDelta& x)
{
    m_state            = x.m_state;
    m_seq_number_delta = x.m_seq_number_delta;
    m_timestamp_delta  = x.m_timestamp_delta;
}

eprosima::micrortps::SampleInfoDelta::SampleInfoDelta(SampleInfoDelta&& x)
{
    m_state            = x.m_state;
    m_seq_number_delta = x.m_seq_number_delta;
    m_timestamp_delta  = x.m_timestamp_delta;
}

eprosima::micrortps::SampleInfoDelta& eprosima::micrortps::SampleInfoDelta::operator=(const SampleInfoDelta& x)
{
    m_state            = x.m_state;
    m_seq_number_delta = x.m_seq_number_delta;
    m_timestamp_delta  = x.m_timestamp_delta;

    return *this;
}

eprosima::micrortps::SampleInfoDelta& eprosima::micrortps::SampleInfoDelta::operator=(SampleInfoDelta&& x)
{
    m_state            = x.m_state;
    m_seq_number_delta = x.m_seq_number_delta;
    m_timestamp_delta  = x.m_timestamp_delta;

    return *this;
}

size_t eprosima::micrortps::SampleInfoDelta::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::SampleInfoDelta::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::SampleInfoDelta::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_state;
    scdr << m_seq_number_delta;
    scdr << m_timestamp_delta;
}

void eprosima::micrortps::SampleInfoDelta::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_state;
    dcdr >> m_seq_number_delta;
    dcdr >> m_timestamp_delta;
}

eprosima::micrortps::SampleData::SampleData()
{
}

eprosima::micrortps::SampleData::~SampleData()
{
}

eprosima::micrortps::SampleData::SampleData(const SampleData& x)
{
    m_serialized_data = x.m_serialized_data;
}

eprosima::micrortps::SampleData::SampleData(SampleData&& x)
{
    m_serialized_data = std::move(x.m_serialized_data);
}

eprosima::micrortps::SampleData& eprosima::micrortps::SampleData::operator=(const SampleData& x)
{
    m_serialized_data = x.m_serialized_data;

    return *this;
}

eprosima::micrortps::SampleData& eprosima::micrortps::SampleData::operator=(SampleData&& x)
{
    m_serialized_data = std::move(x.m_serialized_data);

    return *this;
}

size_t eprosima::micrortps::SampleData::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::SampleData::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (m_serialized_data.size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::SampleData::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_serialized_data;
}

void eprosima::micrortps::SampleData::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_serialized_data;
}

eprosima::micrortps::Sample::Sample()
{
}

eprosima::micrortps::Sample::~Sample()
{
}

eprosima::micrortps::Sample::Sample(const Sample& x)
{
    m_info = x.m_info;
    m_data = x.m_data;
}

eprosima::micrortps::Sample::Sample(Sample&& x)
{
    m_info = std::move(x.m_info);
    m_data = std::move(x.m_data);
}

eprosima::micrortps::Sample& eprosima::micrortps::Sample::operator=(const Sample& x)
{
    m_info = x.m_info;
    m_data = x.m_data;

    return *this;
}

eprosima::micrortps::Sample& eprosima::micrortps::Sample::operator=(Sample&& x)
{
    m_info = std::move(x.m_info);
    m_data = std::move(x.m_data);

    return *this;
}

size_t eprosima::micrortps::Sample::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::SampleInfo::getMaxCdrSerializedSize(current_alignment);
    current_alignment += eprosima::micrortps::SampleData::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::Sample::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += m_info.getCdrSerializedSize(current_alignment);
    current_alignment += m_data.getCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::Sample::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_info;
    scdr << m_data;
}

void eprosima::micrortps::Sample::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_info;
    dcdr >> m_data;
}

eprosima::micrortps::SampleDelta::SampleDelta()
{
}

eprosima::micrortps::SampleDelta::~SampleDelta()
{
}

eprosima::micrortps::SampleDelta::SampleDelta(const SampleDelta& x)
{
    m_info_delta = x.m_info_delta;
    m_data       = x.m_data;
}

eprosima::micrortps::SampleDelta::SampleDelta(SampleDelta&& x)
{
    m_info_delta = std::move(x.m_info_delta);
    m_data       = std::move(x.m_data);
}

eprosima::micrortps::SampleDelta& eprosima::micrortps::SampleDelta::operator=(const SampleDelta& x)
{
    m_info_delta = x.m_info_delta;
    m_data       = x.m_data;

    return *this;
}

eprosima::micrortps::SampleDelta& eprosima::micrortps::SampleDelta::operator=(SampleDelta&& x)
{
    m_info_delta = std::move(x.m_info_delta);
    m_data       = std::move(x.m_data);

    return *this;
}

size_t eprosima::micrortps::SampleDelta::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::SampleInfoDelta::getMaxCdrSerializedSize(current_alignment);
    current_alignment += eprosima::micrortps::SampleData::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::SampleDelta::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += m_info_delta.getCdrSerializedSize(current_alignment);
    current_alignment += m_data.getCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::SampleDelta::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_info_delta;
    scdr << m_data;
}

void eprosima::micrortps::SampleDelta::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_info_delta;
    dcdr >> m_data;
}

eprosima::micrortps::PackedSamples::PackedSamples()
{
}

eprosima::micrortps::PackedSamples::~PackedSamples()
{
}

eprosima::micrortps::PackedSamples::PackedSamples(const PackedSamples& x)
{
    m_info_base        = x.m_info_base;
    m_sample_delta_seq = x.m_sample_delta_seq;
}

eprosima::micrortps::PackedSamples::PackedSamples(PackedSamples&& x)
{
    m_info_base        = std::move(x.m_info_base);
    m_sample_delta_seq = std::move(x.m_sample_delta_seq);
}

eprosima::micrortps::PackedSamples& eprosima::micrortps::PackedSamples::operator=(const PackedSamples& x)
{
    m_info_base        = x.m_info_base;
    m_sample_delta_seq = x.m_sample_delta_seq;

    return *this;
}

eprosima::micrortps::PackedSamples& eprosima::micrortps::PackedSamples::operator=(PackedSamples&& x)
{
    m_info_base        = std::move(x.m_info_base);
    m_sample_delta_seq = std::move(x.m_sample_delta_seq);

    return *this;
}

size_t eprosima::micrortps::PackedSamples::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += eprosima::micrortps::SampleInfo::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += eprosima::micrortps::SampleDelta::getMaxCdrSerializedSize(current_alignment);
    }

    return current_alignment - initial_alignment;
}

size_t eprosima::micrortps::PackedSamples::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += m_info_base.getCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < m_sample_delta_seq.size(); ++a)
    {
        current_alignment += m_sample_delta_seq.at(a).getCdrSerializedSize(current_alignment);
    }

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::PackedSamples::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m_info_base;
    scdr << m_sample_delta_seq;
}

void eprosima::micrortps::PackedSamples::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m_info_base;
    dcdr >> m_sample_delta_seq;
}

eprosima::micrortps::DataRepresentation::DataRepresentation()
{
    m__d = FORMAT_DATA;
}

eprosima::micrortps::DataRepresentation::~DataRepresentation()
{
}

eprosima::micrortps::DataRepresentation::DataRepresentation(const DataRepresentation& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case FORMAT_DATA:
            m_data = x.m_data;
            break;
        case FORMAT_DATA_SEQ:
            m_data_seq = x.m_data_seq;
            break;
        case FORMAT_SAMPLE:
            m_sample = x.m_sample;
            break;
        case FORMAT_SAMPLE_SEQ:
            m_sample_seq = x.m_sample_seq;
            break;
        case FORMAT_PACKED_SAMPLES:
            m_packed_samples = x.m_packed_samples;
            break;
        default:
            break;
    }
}

eprosima::micrortps::DataRepresentation::DataRepresentation(DataRepresentation&& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case FORMAT_DATA:
            m_data = std::move(x.m_data);
            break;
        case FORMAT_DATA_SEQ:
            m_data_seq = std::move(x.m_data_seq);
            break;
        case FORMAT_SAMPLE:
            m_sample = std::move(x.m_sample);
            break;
        case FORMAT_SAMPLE_SEQ:
            m_sample_seq = std::move(x.m_sample_seq);
            break;
        case FORMAT_PACKED_SAMPLES:
            m_packed_samples = std::move(x.m_packed_samples);
            break;
        default:
            break;
    }
}

eprosima::micrortps::DataRepresentation& eprosima::micrortps::DataRepresentation::operator=(const DataRepresentation& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case FORMAT_DATA:
            m_data = x.m_data;
            break;
        case FORMAT_DATA_SEQ:
            m_data_seq = x.m_data_seq;
            break;
        case FORMAT_SAMPLE:
            m_sample = x.m_sample;
            break;
        case FORMAT_SAMPLE_SEQ:
            m_sample_seq = x.m_sample_seq;
            break;
        case FORMAT_PACKED_SAMPLES:
            m_packed_samples = x.m_packed_samples;
            break;
        default:
            break;
    }

    return *this;
}

eprosima::micrortps::DataRepresentation& eprosima::micrortps::DataRepresentation::operator=(DataRepresentation&& x)
{
    m__d = x.m__d;

    switch(m__d)
    {
        case FORMAT_DATA:
            m_data = std::move(x.m_data);
            break;
        case FORMAT_DATA_SEQ:
            m_data_seq = std::move(x.m_data_seq);
            break;
        case FORMAT_SAMPLE:
            m_sample = std::move(x.m_sample);
            break;
        case FORMAT_SAMPLE_SEQ:
            m_sample_seq = std::move(x.m_sample_seq);
            break;
        case FORMAT_PACKED_SAMPLES:
            m_packed_samples = std::move(x.m_packed_samples);
            break;
        default:
            break;
    }

    return *this;
}

void eprosima::micrortps::DataRepresentation::_d(eprosima::micrortps::DataFormat __d)
{
    bool b = false;

    switch(m__d)
    {
        case FORMAT_DATA:
            switch(__d)
            {
                case FORMAT_DATA:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
        case FORMAT_DATA_SEQ:
            switch(__d)
            {
                case FORMAT_DATA_SEQ:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
        case FORMAT_SAMPLE:
            switch(__d)
            {
                case FORMAT_SAMPLE:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
        case FORMAT_SAMPLE_SEQ:
            switch(__d)
            {
                case FORMAT_SAMPLE_SEQ:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
        case FORMAT_PACKED_SAMPLES:
            switch(__d)
            {
                case FORMAT_PACKED_SAMPLES:
                    b = true;
                    break;
                default:
                    break;
            }
            break;
    }

    if(!b)
        throw BadParamException("Discriminator doesn't correspond with the selected union member");

    m__d = __d;
}

eprosima::micrortps::DataFormat eprosima::micrortps::DataRepresentation::_d() const
{
    return m__d;
}

eprosima::micrortps::DataFormat& eprosima::micrortps::DataRepresentation::_d()
{
    return m__d;
}

void eprosima::micrortps::DataRepresentation::data(const eprosima::micrortps::SampleData& _data)
{
    m_data = _data;
    m__d   = FORMAT_DATA;
}

void eprosima::micrortps::DataRepresentation::data(eprosima::micrortps::SampleData&& _data)
{
    m_data = std::move(_data);
    m__d   = FORMAT_DATA;
}

const eprosima::micrortps::SampleData& eprosima::micrortps::DataRepresentation::data() const
{
    bool b = false;

    switch(m__d)
    {
        case FORMAT_DATA:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_data;
}

eprosima::micrortps::SampleData& eprosima::micrortps::DataRepresentation::data()
{
    bool b = false;

    switch(m__d)
    {
        case FORMAT_DATA:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_data;
}
void eprosima::micrortps::DataRepresentation::data_seq(const eprosima::micrortps::SampleDataSeq& _data_seq)
{
    m_data_seq = _data_seq;
    m__d       = FORMAT_DATA_SEQ;
}

void eprosima::micrortps::DataRepresentation::data_seq(eprosima::micrortps::SampleDataSeq&& _data_seq)
{
    m_data_seq = std::move(_data_seq);
    m__d       = FORMAT_DATA_SEQ;
}

const eprosima::micrortps::SampleDataSeq& eprosima::micrortps::DataRepresentation::data_seq() const
{
    bool b = false;

    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_data_seq;
}

eprosima::micrortps::SampleDataSeq& eprosima::micrortps::DataRepresentation::data_seq()
{
    bool b = false;

    switch(m__d)
    {
        case FORMAT_DATA_SEQ:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_data_seq;
}
void eprosima::micrortps::DataRepresentation::sample(const eprosima::micrortps::Sample& _sample)
{
    m_sample = _sample;
    m__d     = FORMAT_SAMPLE;
}

void eprosima::micrortps::DataRepresentation::sample(eprosima::micrortps::Sample&& _sample)
{
    m_sample = std::move(_sample);
    m__d     = FORMAT_SAMPLE;
}

const eprosima::micrortps::Sample& eprosima::micrortps::DataRepresentation::sample() const
{
    bool b = false;

    switch(m__d)
    {
        case FORMAT_SAMPLE:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_sample;
}

eprosima::micrortps::Sample& eprosima::micrortps::DataRepresentation::sample()
{
    bool b = false;

    switch(m__d)
    {
        case FORMAT_SAMPLE:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_sample;
}
void eprosima::micrortps::DataRepresentation::sample_seq(const eprosima::micrortps::SampleSeq& _sample_seq)
{
    m_sample_seq = _sample_seq;
    m__d         = FORMAT_SAMPLE_SEQ;
}

void eprosima::micrortps::DataRepresentation::sample_seq(eprosima::micrortps::SampleSeq&& _sample_seq)
{
    m_sample_seq = std::move(_sample_seq);
    m__d         = FORMAT_SAMPLE_SEQ;
}

const eprosima::micrortps::SampleSeq& eprosima::micrortps::DataRepresentation::sample_seq() const
{
    bool b = false;

    switch(m__d)
    {
        case FORMAT_SAMPLE_SEQ:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_sample_seq;
}

eprosima::micrortps::SampleSeq& eprosima::micrortps::DataRepresentation::sample_seq()
{
    bool b = false;

    switch(m__d)
    {
        case FORMAT_SAMPLE_SEQ:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_sample_seq;
}
void eprosima::micrortps::DataRepresentation::packed_samples(const eprosima::micrortps::PackedSamples& _packed_samples)
{
    m_packed_samples = _packed_samples;
    m__d             = FORMAT_PACKED_SAMPLES;
}

void eprosima::micrortps::DataRepresentation::packed_samples(eprosima::micrortps::PackedSamples&& _packed_samples)
{
    m_packed_samples = std::move(_packed_samples);
    m__d             = FORMAT_PACKED_SAMPLES;
}

const eprosima::micrortps::PackedSamples& eprosima::micrortps::DataRepresentation::packed_samples() const
{
    bool b = false;

    switch(m__d)
    {
        case FORMAT_PACKED_SAMPLES:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_packed_samples;
}

eprosima::micrortps::PackedSamples& eprosima::micrortps::DataRepresentation::packed_samples()
{
    bool b = false;

    switch(m__d)
    {
        case FORMAT_PACKED_SAMPLES:
            b = true;
            break;
        default:
            break;
    }
    if(!b)
        throw BadParamException("This member is not been selected");

    return m_packed_samples;
}

size_t eprosima::micrortps::DataRepresentation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment         = current_alignment;
    size_t reset_alignment           = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    reset_alignment = current_alignment;

    reset_alignment += eprosima::micrortps::SampleData::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        reset_alignment += eprosima::micrortps::SampleData::getMaxCdrSerializedSize(reset_alignment);
    }

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += eprosima::micrortps::Sample::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        reset_alignment += eprosima::micrortps::Sample::getMaxCdrSerializedSize(reset_alignment);
    }

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    reset_alignment = current_alignment;

    reset_alignment += eprosima::micrortps::PackedSamples::getMaxCdrSerializedSize(reset_alignment);

    if(union_max_size_serialized < reset_alignment)
        union_max_size_serialized = reset_alignment;

    return union_max_size_serialized - initial_alignment;
}

// TODO(Ricardo) Review
size_t eprosima::micrortps::DataRepresentation::getCdrSerializedSize(size_t current_alignment) const
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(m__d)
    {
        case FORMAT_DATA:
            current_alignment += m_data.getCdrSerializedSize(current_alignment);
            break;
        case FORMAT_DATA_SEQ:
            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
            for(size_t a = 0; a < m_data_seq.size(); ++a)
            {
                current_alignment += m_data_seq.at(a).getCdrSerializedSize(current_alignment);
            }
            break;
        case FORMAT_SAMPLE:
            current_alignment += m_sample.getCdrSerializedSize(current_alignment);
            break;
        case FORMAT_SAMPLE_SEQ:
            current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
            for(size_t a = 0; a < m_sample_seq.size(); ++a)
            {
                current_alignment += m_sample_seq.at(a).getCdrSerializedSize(current_alignment);
            }
            break;
        case FORMAT_PACKED_SAMPLES:
            current_alignment += m_packed_samples.getCdrSerializedSize(current_alignment);
            break;
        default:
            break;
    }

    return current_alignment - initial_alignment;
}

void eprosima::micrortps::DataRepresentation::serialize(eprosima::fastcdr::Cdr& scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case FORMAT_DATA:
            scdr << m_data;
            break;
        case FORMAT_DATA_SEQ:
            scdr << m_data_seq;
            break;
        case FORMAT_SAMPLE:
            scdr << m_sample;
            break;
        case FORMAT_SAMPLE_SEQ:
            scdr << m_sample_seq;
            break;
        case FORMAT_PACKED_SAMPLES:
            scdr << m_packed_samples;
            break;
        default:
            break;
    }
}

void eprosima::micrortps::DataRepresentation::deserialize(eprosima::fastcdr::Cdr& dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case FORMAT_DATA:
            dcdr >> m_data;
            break;
        case FORMAT_DATA_SEQ:
            dcdr >> m_data_seq;
            break;
        case FORMAT_SAMPLE:
            dcdr >> m_sample;
            break;
        case FORMAT_SAMPLE_SEQ:
            dcdr >> m_sample_seq;
            break;
        case FORMAT_PACKED_SAMPLES:
            dcdr >> m_packed_samples;
            break;
        default:
            break;
    }
}