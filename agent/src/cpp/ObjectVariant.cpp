// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file ObjectVariant.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "agent/ObjectVariant.h"

#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>




Time_t::Time_t()
{
    seconds_ = 0;
    nanoseconds_ = 0;
}

Time_t::~Time_t()
{
}

Time_t::Time_t(const Time_t &x)
{
    seconds_ = x.seconds_;
    nanoseconds_ = x.nanoseconds_;
}

Time_t::Time_t(Time_t &&x)
{
    seconds_ = x.seconds_;
    nanoseconds_ = x.nanoseconds_;
}

Time_t& Time_t::operator=(const Time_t &x)
{
    seconds_ = x.seconds_;
    nanoseconds_ = x.nanoseconds_;
    
    return *this;
}

Time_t& Time_t::operator=(Time_t &&x)
{
    seconds_ = x.seconds_;
    nanoseconds_ = x.nanoseconds_;
    
    return *this;
}

size_t Time_t::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t Time_t::getCdrSerializedSize(const Time_t& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void Time_t::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << seconds_;
    scdr << nanoseconds_;
}

void Time_t::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> seconds_;
    dcdr >> nanoseconds_;
}

OBJK_CLIENT_Representation::OBJK_CLIENT_Representation()
{




    session_id_ = 0;
}

OBJK_CLIENT_Representation::~OBJK_CLIENT_Representation()
{
}

OBJK_CLIENT_Representation::OBJK_CLIENT_Representation(const OBJK_CLIENT_Representation &x)
{
    xrce_cookie_ = x.xrce_cookie_;
    xrce_version_ = x.xrce_version_;
    xrce_vendor_id_ = x.xrce_vendor_id_;
    client_timestamp_ = x.client_timestamp_;
    session_id_ = x.session_id_;
}

OBJK_CLIENT_Representation::OBJK_CLIENT_Representation(OBJK_CLIENT_Representation &&x)
{
    xrce_cookie_ = std::move(x.xrce_cookie_);
    xrce_version_ = std::move(x.xrce_version_);
    xrce_vendor_id_ = std::move(x.xrce_vendor_id_);
    client_timestamp_ = std::move(x.client_timestamp_);
    session_id_ = x.session_id_;
}

OBJK_CLIENT_Representation& OBJK_CLIENT_Representation::operator=(const OBJK_CLIENT_Representation &x)
{
    xrce_cookie_ = x.xrce_cookie_;
    xrce_version_ = x.xrce_version_;
    xrce_vendor_id_ = x.xrce_vendor_id_;
    client_timestamp_ = x.client_timestamp_;
    session_id_ = x.session_id_;
    
    return *this;
}

OBJK_CLIENT_Representation& OBJK_CLIENT_Representation::operator=(OBJK_CLIENT_Representation &&x)
{
    xrce_cookie_ = std::move(x.xrce_cookie_);
    xrce_version_ = std::move(x.xrce_version_);
    xrce_vendor_id_ = std::move(x.xrce_vendor_id_);
    client_timestamp_ = std::move(x.client_timestamp_);
    session_id_ = x.session_id_;
    
    return *this;
}

size_t OBJK_CLIENT_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((4) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += Time_t::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t OBJK_CLIENT_Representation::getCdrSerializedSize(const OBJK_CLIENT_Representation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((4) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += Time_t::getCdrSerializedSize(data.client_timestamp(), current_alignment);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void OBJK_CLIENT_Representation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << xrce_cookie_;
    scdr << xrce_version_;
    scdr << xrce_vendor_id_;
    scdr << client_timestamp_;
    scdr << session_id_;
}

void OBJK_CLIENT_Representation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> xrce_cookie_;
    dcdr >> xrce_version_;
    dcdr >> xrce_vendor_id_;
    dcdr >> client_timestamp_;
    dcdr >> session_id_;
}

OBJK_CommonString_Representation::OBJK_CommonString_Representation()
{
}

OBJK_CommonString_Representation::~OBJK_CommonString_Representation()
{
}

OBJK_CommonString_Representation::OBJK_CommonString_Representation(const OBJK_CommonString_Representation &x)
{
    as_string_ = x.as_string_;
}

OBJK_CommonString_Representation::OBJK_CommonString_Representation(OBJK_CommonString_Representation &&x)
{
    as_string_ = std::move(x.as_string_);
}

OBJK_CommonString_Representation& OBJK_CommonString_Representation::operator=(const OBJK_CommonString_Representation &x)
{
    as_string_ = x.as_string_;
    
    return *this;
}

OBJK_CommonString_Representation& OBJK_CommonString_Representation::operator=(OBJK_CommonString_Representation &&x)
{
    as_string_ = std::move(x.as_string_);
    
    return *this;
}

size_t OBJK_CommonString_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;

    return current_alignment - initial_alignment;
}

size_t OBJK_CommonString_Representation::getCdrSerializedSize(const OBJK_CommonString_Representation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.as_string().size() + 1;

    return current_alignment - initial_alignment;
}

void OBJK_CommonString_Representation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << as_string_;
}

void OBJK_CommonString_Representation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> as_string_;
}

OBJK_QOSPROFILE_Representation::OBJK_QOSPROFILE_Representation()
{
}

OBJK_QOSPROFILE_Representation::~OBJK_QOSPROFILE_Representation()
{
}

OBJK_QOSPROFILE_Representation::OBJK_QOSPROFILE_Representation(const OBJK_QOSPROFILE_Representation &x)
    : OBJK_CommonString_Representation(x)
{

}

OBJK_QOSPROFILE_Representation::OBJK_QOSPROFILE_Representation(OBJK_QOSPROFILE_Representation &&x)
    : OBJK_CommonString_Representation(x)
{
}

OBJK_QOSPROFILE_Representation& OBJK_QOSPROFILE_Representation::operator=(const OBJK_QOSPROFILE_Representation &x)	
{  
    OBJK_CommonString_Representation::operator=(x);
    return *this;
}

OBJK_QOSPROFILE_Representation& OBJK_QOSPROFILE_Representation::operator=(OBJK_QOSPROFILE_Representation &&x)
{
    OBJK_CommonString_Representation::operator=(x);    
    return *this;
}

size_t OBJK_QOSPROFILE_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += OBJK_CommonString_Representation::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t OBJK_QOSPROFILE_Representation::getCdrSerializedSize(const OBJK_QOSPROFILE_Representation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += OBJK_CommonString_Representation::getCdrSerializedSize(data, current_alignment);

    return current_alignment - initial_alignment;
}

void OBJK_QOSPROFILE_Representation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    OBJK_CommonString_Representation::serialize(scdr);
}

void OBJK_QOSPROFILE_Representation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    OBJK_CommonString_Representation::deserialize(dcdr);
}

OBJK_APPLICATION_Representation::OBJK_APPLICATION_Representation()
{
}

OBJK_APPLICATION_Representation::~OBJK_APPLICATION_Representation()
{
}

OBJK_APPLICATION_Representation::OBJK_APPLICATION_Representation(const OBJK_APPLICATION_Representation &x)
    : OBJK_CommonString_Representation(x)
{
}

OBJK_APPLICATION_Representation::OBJK_APPLICATION_Representation(OBJK_APPLICATION_Representation &&x)
    : OBJK_CommonString_Representation(x)
{
}

OBJK_APPLICATION_Representation& OBJK_APPLICATION_Representation::operator=(const OBJK_APPLICATION_Representation &x)
{
    OBJK_CommonString_Representation::operator=(x);    
    return *this;
}

OBJK_APPLICATION_Representation& OBJK_APPLICATION_Representation::operator=(OBJK_APPLICATION_Representation &&x)
{
    OBJK_CommonString_Representation::operator=(x);    
    return *this;
}

size_t OBJK_APPLICATION_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += OBJK_CommonString_Representation::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t OBJK_APPLICATION_Representation::getCdrSerializedSize(const OBJK_APPLICATION_Representation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += OBJK_CommonString_Representation::getCdrSerializedSize(data, current_alignment);

    return current_alignment - initial_alignment;
}

void OBJK_APPLICATION_Representation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    OBJK_CommonString_Representation::serialize(scdr);
}

void OBJK_APPLICATION_Representation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    OBJK_CommonString_Representation::deserialize(dcdr);
}

OBJK_PARTICIPANT_Representation::OBJK_PARTICIPANT_Representation()
{
}

OBJK_PARTICIPANT_Representation::~OBJK_PARTICIPANT_Representation()
{
}

OBJK_PARTICIPANT_Representation::OBJK_PARTICIPANT_Representation(const OBJK_PARTICIPANT_Representation &x)
    : OBJK_CommonString_Representation(x)
{
}

OBJK_PARTICIPANT_Representation::OBJK_PARTICIPANT_Representation(OBJK_PARTICIPANT_Representation &&x)
    : OBJK_CommonString_Representation(x)
{
}

OBJK_PARTICIPANT_Representation& OBJK_PARTICIPANT_Representation::operator=(const OBJK_PARTICIPANT_Representation &x)
{
    OBJK_CommonString_Representation::operator=(x);    
    return *this;
}

OBJK_PARTICIPANT_Representation& OBJK_PARTICIPANT_Representation::operator=(OBJK_PARTICIPANT_Representation &&x)
{
    OBJK_CommonString_Representation::operator=(x);    
    return *this;
}

size_t OBJK_PARTICIPANT_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += OBJK_CommonString_Representation::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t OBJK_PARTICIPANT_Representation::getCdrSerializedSize(const OBJK_PARTICIPANT_Representation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += OBJK_CommonString_Representation::getCdrSerializedSize(data, current_alignment);

    return current_alignment - initial_alignment;
}

void OBJK_PARTICIPANT_Representation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    OBJK_CommonString_Representation::serialize(scdr);
}

void OBJK_PARTICIPANT_Representation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    OBJK_CommonString_Representation::deserialize(dcdr);
}

OBJK_TYPE_Representation::OBJK_TYPE_Representation()
{


}

OBJK_TYPE_Representation::~OBJK_TYPE_Representation()
{
}

OBJK_TYPE_Representation::OBJK_TYPE_Representation(const OBJK_TYPE_Representation &x)
    : OBJK_CommonString_Representation(x)
{
    participant_id_ = x.participant_id_;
    registered_type_name_ = x.registered_type_name_;
}

OBJK_TYPE_Representation::OBJK_TYPE_Representation(OBJK_TYPE_Representation &&x)
    : OBJK_CommonString_Representation(x)
{
    participant_id_ = std::move(x.participant_id_);
    registered_type_name_ = std::move(x.registered_type_name_);
}

OBJK_TYPE_Representation& OBJK_TYPE_Representation::operator=(const OBJK_TYPE_Representation &x)
{
    OBJK_CommonString_Representation::operator=(x);
    participant_id_ = x.participant_id_;
    registered_type_name_ = x.registered_type_name_;
    
    return *this;
}

OBJK_TYPE_Representation& OBJK_TYPE_Representation::operator=(OBJK_TYPE_Representation &&x)
{
    OBJK_CommonString_Representation::operator=(x);
    participant_id_ = std::move(x.participant_id_);
    registered_type_name_ = std::move(x.registered_type_name_);
    
    return *this;
}

size_t OBJK_TYPE_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += OBJK_CommonString_Representation::getMaxCdrSerializedSize(current_alignment);

    current_alignment += ((3) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t OBJK_TYPE_Representation::getCdrSerializedSize(const OBJK_TYPE_Representation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += OBJK_CommonString_Representation::getCdrSerializedSize(data, current_alignment);
    current_alignment += ((3) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.registered_type_name().size() + 1;


    return current_alignment - initial_alignment;
}

void OBJK_TYPE_Representation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    OBJK_CommonString_Representation::serialize(scdr);
    scdr << participant_id_;
    scdr << registered_type_name_;
}

void OBJK_TYPE_Representation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    OBJK_CommonString_Representation::deserialize(dcdr);
    dcdr >> participant_id_;
    dcdr >> registered_type_name_;
}

OBJK_TOPIC_Representation::OBJK_TOPIC_Representation()
{
}

OBJK_TOPIC_Representation::~OBJK_TOPIC_Representation()
{
}

OBJK_TOPIC_Representation::OBJK_TOPIC_Representation(const OBJK_TOPIC_Representation &x)
    : OBJK_CommonString_Representation(x)
{
    participant_id_ = x.participant_id_;
}

OBJK_TOPIC_Representation::OBJK_TOPIC_Representation(OBJK_TOPIC_Representation &&x)
    : OBJK_CommonString_Representation(x)
{
    participant_id_ = std::move(x.participant_id_);
}

OBJK_TOPIC_Representation& OBJK_TOPIC_Representation::operator=(const OBJK_TOPIC_Representation &x)
{
    OBJK_CommonString_Representation::operator=(x);
    participant_id_ = x.participant_id_;
    
    return *this;
}

OBJK_TOPIC_Representation& OBJK_TOPIC_Representation::operator=(OBJK_TOPIC_Representation &&x)
{
    OBJK_CommonString_Representation::operator=(x);
    participant_id_ = std::move(x.participant_id_);
    
    return *this;
}

size_t OBJK_TOPIC_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += OBJK_CommonString_Representation::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((3) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

size_t OBJK_TOPIC_Representation::getCdrSerializedSize(const OBJK_TOPIC_Representation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += OBJK_CommonString_Representation::getCdrSerializedSize(data, current_alignment);
    current_alignment += ((3) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    return current_alignment - initial_alignment;
}

void OBJK_TOPIC_Representation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    OBJK_CommonString_Representation::serialize(scdr);
    scdr << participant_id_;
}

void OBJK_TOPIC_Representation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    OBJK_CommonString_Representation::deserialize(dcdr);
    dcdr >> participant_id_;
}

OBJK_PUBLISHER_Representation::OBJK_PUBLISHER_Representation()
{
}

OBJK_PUBLISHER_Representation::~OBJK_PUBLISHER_Representation()
{
}

OBJK_PUBLISHER_Representation::OBJK_PUBLISHER_Representation(const OBJK_PUBLISHER_Representation &x)
    : OBJK_CommonString_Representation(x)
{
    participant_id_ = x.participant_id_;
}

OBJK_PUBLISHER_Representation::OBJK_PUBLISHER_Representation(OBJK_PUBLISHER_Representation &&x)
    : OBJK_CommonString_Representation(x)
{
    participant_id_ = std::move(x.participant_id_);
}

OBJK_PUBLISHER_Representation& OBJK_PUBLISHER_Representation::operator=(const OBJK_PUBLISHER_Representation &x)
{
    OBJK_CommonString_Representation::operator=(x);
    participant_id_ = x.participant_id_;
    
    return *this;
}

OBJK_PUBLISHER_Representation& OBJK_PUBLISHER_Representation::operator=(OBJK_PUBLISHER_Representation &&x)
{
    OBJK_CommonString_Representation::operator=(x);
    participant_id_ = std::move(x.participant_id_);
    
    return *this;
}

size_t OBJK_PUBLISHER_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += OBJK_CommonString_Representation::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((3) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

size_t OBJK_PUBLISHER_Representation::getCdrSerializedSize(const OBJK_PUBLISHER_Representation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += OBJK_CommonString_Representation::getCdrSerializedSize(data, current_alignment);
    current_alignment += ((3) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    return current_alignment - initial_alignment;
}

void OBJK_PUBLISHER_Representation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    OBJK_CommonString_Representation::serialize(scdr);
    scdr << participant_id_;
}

void OBJK_PUBLISHER_Representation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    OBJK_CommonString_Representation::deserialize(dcdr);
    dcdr >> participant_id_;
}

OBJK_SUBSCRIBER_Representation::OBJK_SUBSCRIBER_Representation()
{
}

OBJK_SUBSCRIBER_Representation::~OBJK_SUBSCRIBER_Representation()
{
}

OBJK_SUBSCRIBER_Representation::OBJK_SUBSCRIBER_Representation(const OBJK_SUBSCRIBER_Representation &x)
    : OBJK_CommonString_Representation(x)
{
    participant_id_ = x.participant_id_;
}

OBJK_SUBSCRIBER_Representation::OBJK_SUBSCRIBER_Representation(OBJK_SUBSCRIBER_Representation &&x)
    : OBJK_CommonString_Representation(x)
{
    participant_id_ = std::move(x.participant_id_);
}

OBJK_SUBSCRIBER_Representation& OBJK_SUBSCRIBER_Representation::operator=(const OBJK_SUBSCRIBER_Representation &x)
{
    OBJK_CommonString_Representation::operator=(x);
    participant_id_ = x.participant_id_;
    
    return *this;
}

OBJK_SUBSCRIBER_Representation& OBJK_SUBSCRIBER_Representation::operator=(OBJK_SUBSCRIBER_Representation &&x)
{
    OBJK_CommonString_Representation::operator=(x);
    participant_id_ = std::move(x.participant_id_);
    
    return *this;
}

size_t OBJK_SUBSCRIBER_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += OBJK_CommonString_Representation::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((3) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

size_t OBJK_SUBSCRIBER_Representation::getCdrSerializedSize(const OBJK_SUBSCRIBER_Representation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += OBJK_CommonString_Representation::getCdrSerializedSize(data, current_alignment);
    current_alignment += ((3) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    return current_alignment - initial_alignment;
}

void OBJK_SUBSCRIBER_Representation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    OBJK_CommonString_Representation::serialize(scdr);
    scdr << participant_id_;
}

void OBJK_SUBSCRIBER_Representation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    OBJK_CommonString_Representation::deserialize(dcdr);
    dcdr >> participant_id_;
}

OBJK_DATAWRITER_Representation::OBJK_DATAWRITER_Representation()
{


}

OBJK_DATAWRITER_Representation::~OBJK_DATAWRITER_Representation()
{
}

OBJK_DATAWRITER_Representation::OBJK_DATAWRITER_Representation(const OBJK_DATAWRITER_Representation &x)
    : OBJK_CommonString_Representation(x)
{
    participant_id_ = x.participant_id_;
    publisher_id_ = x.publisher_id_;
}

OBJK_DATAWRITER_Representation::OBJK_DATAWRITER_Representation(OBJK_DATAWRITER_Representation &&x)
    : OBJK_CommonString_Representation(x)
{
    participant_id_ = std::move(x.participant_id_);
    publisher_id_ = std::move(x.publisher_id_);
}

OBJK_DATAWRITER_Representation& OBJK_DATAWRITER_Representation::operator=(const OBJK_DATAWRITER_Representation &x)
{
    OBJK_CommonString_Representation::operator=(x);
    participant_id_ = x.participant_id_;
    publisher_id_ = x.publisher_id_;
    
    return *this;
}

OBJK_DATAWRITER_Representation& OBJK_DATAWRITER_Representation::operator=(OBJK_DATAWRITER_Representation &&x)
{
    OBJK_CommonString_Representation::operator=(x);
    participant_id_ = std::move(x.participant_id_);
    publisher_id_ = std::move(x.publisher_id_);
    
    return *this;
}

size_t OBJK_DATAWRITER_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += OBJK_CommonString_Representation::getMaxCdrSerializedSize(current_alignment);
            
    current_alignment += ((3) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += ((3) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t OBJK_DATAWRITER_Representation::getCdrSerializedSize(const OBJK_DATAWRITER_Representation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += OBJK_CommonString_Representation::getCdrSerializedSize(data, current_alignment);
    current_alignment += ((3) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += ((3) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void OBJK_DATAWRITER_Representation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    OBJK_CommonString_Representation::serialize(scdr);
    scdr << participant_id_;
    scdr << publisher_id_;
}

void OBJK_DATAWRITER_Representation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    OBJK_CommonString_Representation::deserialize(dcdr);
    dcdr >> participant_id_;
    dcdr >> publisher_id_;
}

OBJK_DATAREADER_Representation::OBJK_DATAREADER_Representation()
{


}

OBJK_DATAREADER_Representation::~OBJK_DATAREADER_Representation()
{
}

OBJK_DATAREADER_Representation::OBJK_DATAREADER_Representation(const OBJK_DATAREADER_Representation &x)
    : OBJK_CommonString_Representation(x)
{
    participant_id_ = x.participant_id_;
    subscriber_id_ = x.subscriber_id_;
}

OBJK_DATAREADER_Representation::OBJK_DATAREADER_Representation(OBJK_DATAREADER_Representation &&x)
    : OBJK_CommonString_Representation(x)
{
    participant_id_ = std::move(x.participant_id_);
    subscriber_id_ = std::move(x.subscriber_id_);
}

OBJK_DATAREADER_Representation& OBJK_DATAREADER_Representation::operator=(const OBJK_DATAREADER_Representation &x)
{
    OBJK_CommonString_Representation::operator=(x);
    participant_id_ = x.participant_id_;
    subscriber_id_ = x.subscriber_id_;
    
    return *this;
}

OBJK_DATAREADER_Representation& OBJK_DATAREADER_Representation::operator=(OBJK_DATAREADER_Representation &&x)
{
    OBJK_CommonString_Representation::operator=(x);
    participant_id_ = std::move(x.participant_id_);
    subscriber_id_ = std::move(x.subscriber_id_);
    
    return *this;
}

size_t OBJK_DATAREADER_Representation::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += OBJK_CommonString_Representation::getMaxCdrSerializedSize(current_alignment);

    current_alignment += ((3) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += ((3) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t OBJK_DATAREADER_Representation::getCdrSerializedSize(const OBJK_DATAREADER_Representation& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += OBJK_CommonString_Representation::getCdrSerializedSize(data, current_alignment);
    current_alignment += ((3) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += ((3) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    return current_alignment - initial_alignment;
}

void OBJK_DATAREADER_Representation::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    OBJK_CommonString_Representation::serialize(scdr);
    scdr << participant_id_;
    scdr << subscriber_id_;
}

void OBJK_DATAREADER_Representation::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    OBJK_CommonString_Representation::deserialize(dcdr);
    dcdr >> participant_id_;
    dcdr >> subscriber_id_;
}

ObjectVariant::ObjectVariant()
{
    discriminator_ = OBJK_INVALID;
}

ObjectVariant::~ObjectVariant()
{
}

ObjectVariant::ObjectVariant(const ObjectVariant &x)
{
    discriminator_ = x.discriminator_;
    
    switch(discriminator_)
    {
        case OBJK_CLIENT:
        client_ = x.client_;
        break;
        case OBJK_APPLICATION:
        application_ = x.application_;
        break;
        case OBJK_PARTICIPANT:
        participant_ = x.participant_;
        break;
        case OBJK_QOSPROFILE:
        qos_profile_ = x.qos_profile_;
        break;
        case OBJK_TYPE:
        type_ = x.type_;
        break;
        case OBJK_TOPIC:
        topic_ = x.topic_;
        break;
        case OBJK_PUBLISHER:
        publisher_ = x.publisher_;
        break;
        case OBJK_SUBSCRIBER:
        subscriber_ = x.subscriber_;
        break;
        case OBJK_DATAWRITER:
        data_writer_ = x.data_writer_;
        break;
        case OBJK_DATAREADER:
        data_reader_ = x.data_reader_;
        break;
        default:
        break;
    }
}

ObjectVariant::ObjectVariant(ObjectVariant &&x)
{
    discriminator_ = x.discriminator_;
    
    switch(discriminator_)
    {
        case OBJK_CLIENT:
        client_ = std::move(x.client_);
        break;
        case OBJK_APPLICATION:
        application_ = std::move(x.application_);
        break;
        case OBJK_PARTICIPANT:
        participant_ = std::move(x.participant_);
        break;
        case OBJK_QOSPROFILE:
        qos_profile_ = std::move(x.qos_profile_);
        break;
        case OBJK_TYPE:
        type_ = std::move(x.type_);
        break;
        case OBJK_TOPIC:
        topic_ = std::move(x.topic_);
        break;
        case OBJK_PUBLISHER:
        publisher_ = std::move(x.publisher_);
        break;
        case OBJK_SUBSCRIBER:
        subscriber_ = std::move(x.subscriber_);
        break;
        case OBJK_DATAWRITER:
        data_writer_ = std::move(x.data_writer_);
        break;
        case OBJK_DATAREADER:
        data_reader_ = std::move(x.data_reader_);
        break;
        default:
        break;
    }
}

ObjectVariant& ObjectVariant::operator=(const ObjectVariant &x)
{
    discriminator_ = x.discriminator_;
    
    switch(discriminator_)
    {
        case OBJK_CLIENT:
        client_ = x.client_;
        break;
        case OBJK_APPLICATION:
        application_ = x.application_;
        break;
        case OBJK_PARTICIPANT:
        participant_ = x.participant_;
        break;
        case OBJK_QOSPROFILE:
        qos_profile_ = x.qos_profile_;
        break;
        case OBJK_TYPE:
        type_ = x.type_;
        break;
        case OBJK_TOPIC:
        topic_ = x.topic_;
        break;
        case OBJK_PUBLISHER:
        publisher_ = x.publisher_;
        break;
        case OBJK_SUBSCRIBER:
        subscriber_ = x.subscriber_;
        break;
        case OBJK_DATAWRITER:
        data_writer_ = x.data_writer_;
        break;
        case OBJK_DATAREADER:
        data_reader_ = x.data_reader_;
        break;
        default:
        break;
    }
    
    return *this;
}

ObjectVariant& ObjectVariant::operator=(ObjectVariant &&x)
{
    discriminator_ = x.discriminator_;
    
    switch(discriminator_)
    {
        case OBJK_CLIENT:
        client_ = std::move(x.client_);
        break;
        case OBJK_APPLICATION:
        application_ = std::move(x.application_);
        break;
        case OBJK_PARTICIPANT:
        participant_ = std::move(x.participant_);
        break;
        case OBJK_QOSPROFILE:
        qos_profile_ = std::move(x.qos_profile_);
        break;
        case OBJK_TYPE:
        type_ = std::move(x.type_);
        break;
        case OBJK_TOPIC:
        topic_ = std::move(x.topic_);
        break;
        case OBJK_PUBLISHER:
        publisher_ = std::move(x.publisher_);
        break;
        case OBJK_SUBSCRIBER:
        subscriber_ = std::move(x.subscriber_);
        break;
        case OBJK_DATAWRITER:
        data_writer_ = std::move(x.data_writer_);
        break;
        case OBJK_DATAREADER:
        data_reader_ = std::move(x.data_reader_);
        break;
        default:
        break;
    }
    
    return *this;
}

void ObjectVariant::discriminator(ObjectKind _discriminator)
{
    bool b = false;
    
    switch(discriminator_)
    {
        case OBJK_CLIENT:
        switch(_discriminator)
        {
            case OBJK_CLIENT:
            b = true;
            break;
            default:
            break;
        }
        break;
        case OBJK_APPLICATION:
        switch(_discriminator)
        {
            case OBJK_APPLICATION:
            b = true;
            break;
            default:
            break;
        }
        break;
        case OBJK_PARTICIPANT:
        switch(_discriminator)
        {
            case OBJK_PARTICIPANT:
            b = true;
            break;
            default:
            break;
        }
        break;
        case OBJK_QOSPROFILE:
        switch(_discriminator)
        {
            case OBJK_QOSPROFILE:
            b = true;
            break;
            default:
            break;
        }
        break;
        case OBJK_TYPE:
        switch(_discriminator)
        {
            case OBJK_TYPE:
            b = true;
            break;
            default:
            break;
        }
        break;
        case OBJK_TOPIC:
        switch(_discriminator)
        {
            case OBJK_TOPIC:
            b = true;
            break;
            default:
            break;
        }
        break;
        case OBJK_PUBLISHER:
        switch(_discriminator)
        {
            case OBJK_PUBLISHER:
            b = true;
            break;
            default:
            break;
        }
        break;
        case OBJK_SUBSCRIBER:
        switch(_discriminator)
        {
            case OBJK_SUBSCRIBER:
            b = true;
            break;
            default:
            break;
        }
        break;
        case OBJK_DATAWRITER:
        switch(_discriminator)
        {
            case OBJK_DATAWRITER:
            b = true;
            break;
            default:
            break;
        }
        break;
        case OBJK_DATAREADER:
        switch(_discriminator)
        {
            case OBJK_DATAREADER:
            b = true;
            break;
            default:
            break;
        }
        break;
    }
    
    if(!b) throw BadParamException("Discriminator doesn't correspond with the selected union member");
    
    discriminator_ = _discriminator;
}

ObjectKind ObjectVariant::discriminator() const
{
    return discriminator_;
}

ObjectKind& ObjectVariant::discriminator()
{
    return discriminator_;
}

void ObjectVariant::client(const OBJK_CLIENT_Representation &_client)
{
    client_ = _client;
    discriminator_ = OBJK_CLIENT;
}

void ObjectVariant::client(OBJK_CLIENT_Representation &&_client)
{
    client_ = std::move(_client);
    discriminator_ = OBJK_CLIENT;
}

const OBJK_CLIENT_Representation& ObjectVariant::client() const
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_CLIENT:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return client_;
}

OBJK_CLIENT_Representation& ObjectVariant::client()
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_CLIENT:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return client_;
}
void ObjectVariant::application(const OBJK_APPLICATION_Representation &_application)
{
    application_ = _application;
    discriminator_ = OBJK_APPLICATION;
}

void ObjectVariant::application(OBJK_APPLICATION_Representation &&_application)
{
    application_ = std::move(_application);
    discriminator_ = OBJK_APPLICATION;
}

const OBJK_APPLICATION_Representation& ObjectVariant::application() const
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_APPLICATION:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return application_;
}

OBJK_APPLICATION_Representation& ObjectVariant::application()
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_APPLICATION:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return application_;
}
void ObjectVariant::participant(const OBJK_PARTICIPANT_Representation &_participant)
{
    participant_ = _participant;
    discriminator_ = OBJK_PARTICIPANT;
}

void ObjectVariant::participant(OBJK_PARTICIPANT_Representation &&_participant)
{
    participant_ = std::move(_participant);
    discriminator_ = OBJK_PARTICIPANT;
}

const OBJK_PARTICIPANT_Representation& ObjectVariant::participant() const
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_PARTICIPANT:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return participant_;
}

OBJK_PARTICIPANT_Representation& ObjectVariant::participant()
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_PARTICIPANT:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return participant_;
}
void ObjectVariant::qos_profile(const OBJK_QOSPROFILE_Representation &_qos_profile)
{
    qos_profile_ = _qos_profile;
    discriminator_ = OBJK_QOSPROFILE;
}

void ObjectVariant::qos_profile(OBJK_QOSPROFILE_Representation &&_qos_profile)
{
    qos_profile_ = std::move(_qos_profile);
    discriminator_ = OBJK_QOSPROFILE;
}

const OBJK_QOSPROFILE_Representation& ObjectVariant::qos_profile() const
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_QOSPROFILE:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return qos_profile_;
}

OBJK_QOSPROFILE_Representation& ObjectVariant::qos_profile()
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_QOSPROFILE:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return qos_profile_;
}
void ObjectVariant::type(const OBJK_TYPE_Representation &_type)
{
    type_ = _type;
    discriminator_ = OBJK_TYPE;
}

void ObjectVariant::type(OBJK_TYPE_Representation &&_type)
{
    type_ = std::move(_type);
    discriminator_ = OBJK_TYPE;
}

const OBJK_TYPE_Representation& ObjectVariant::type() const
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_TYPE:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return type_;
}

OBJK_TYPE_Representation& ObjectVariant::type()
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_TYPE:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return type_;
}
void ObjectVariant::topic(const OBJK_TOPIC_Representation &_topic)
{
    topic_ = _topic;
    discriminator_ = OBJK_TOPIC;
}

void ObjectVariant::topic(OBJK_TOPIC_Representation &&_topic)
{
    topic_ = std::move(_topic);
    discriminator_ = OBJK_TOPIC;
}

const OBJK_TOPIC_Representation& ObjectVariant::topic() const
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_TOPIC:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return topic_;
}

OBJK_TOPIC_Representation& ObjectVariant::topic()
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_TOPIC:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return topic_;
}
void ObjectVariant::publisher(const OBJK_PUBLISHER_Representation &_publisher)
{
    publisher_ = _publisher;
    discriminator_ = OBJK_PUBLISHER;
}

void ObjectVariant::publisher(OBJK_PUBLISHER_Representation &&_publisher)
{
    publisher_ = std::move(_publisher);
    discriminator_ = OBJK_PUBLISHER;
}

const OBJK_PUBLISHER_Representation& ObjectVariant::publisher() const
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_PUBLISHER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return publisher_;
}

OBJK_PUBLISHER_Representation& ObjectVariant::publisher()
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_PUBLISHER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return publisher_;
}
void ObjectVariant::subscriber(const OBJK_SUBSCRIBER_Representation &_subscriber)
{
    subscriber_ = _subscriber;
    discriminator_ = OBJK_SUBSCRIBER;
}

void ObjectVariant::subscriber(OBJK_SUBSCRIBER_Representation &&_subscriber)
{
    subscriber_ = std::move(_subscriber);
    discriminator_ = OBJK_SUBSCRIBER;
}

const OBJK_SUBSCRIBER_Representation& ObjectVariant::subscriber() const
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_SUBSCRIBER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return subscriber_;
}

OBJK_SUBSCRIBER_Representation& ObjectVariant::subscriber()
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_SUBSCRIBER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return subscriber_;
}
void ObjectVariant::data_writer(const OBJK_DATAWRITER_Representation &_data_writer)
{
    data_writer_ = _data_writer;
    discriminator_ = OBJK_DATAWRITER;
}

void ObjectVariant::data_writer(OBJK_DATAWRITER_Representation &&_data_writer)
{
    data_writer_ = std::move(_data_writer);
    discriminator_ = OBJK_DATAWRITER;
}

const OBJK_DATAWRITER_Representation& ObjectVariant::data_writer() const
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_DATAWRITER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return data_writer_;
}

OBJK_DATAWRITER_Representation& ObjectVariant::data_writer()
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_DATAWRITER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return data_writer_;
}
void ObjectVariant::data_reader(const OBJK_DATAREADER_Representation &_data_reader)
{
    data_reader_ = _data_reader;
    discriminator_ = OBJK_DATAREADER;
}

void ObjectVariant::data_reader(OBJK_DATAREADER_Representation &&_data_reader)
{
    data_reader_ = std::move(_data_reader);
    discriminator_ = OBJK_DATAREADER;
}

const OBJK_DATAREADER_Representation& ObjectVariant::data_reader() const
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_DATAREADER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return data_reader_;
}

OBJK_DATAREADER_Representation& ObjectVariant::data_reader()
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_DATAREADER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return data_reader_;
}

size_t ObjectVariant::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


        reset_alignment = current_alignment;

        reset_alignment += OBJK_CLIENT_Representation::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += OBJK_APPLICATION_Representation::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += OBJK_PARTICIPANT_Representation::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += OBJK_QOSPROFILE_Representation::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += OBJK_TYPE_Representation::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += OBJK_TOPIC_Representation::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += OBJK_PUBLISHER_Representation::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += OBJK_SUBSCRIBER_Representation::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += OBJK_DATAWRITER_Representation::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += OBJK_DATAREADER_Representation::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        

    return union_max_size_serialized - initial_alignment;
}

// TODO(Ricardo) Review
size_t ObjectVariant::getCdrSerializedSize(const ObjectVariant& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(data.discriminator_)
    {
        case OBJK_CLIENT:
        current_alignment += OBJK_CLIENT_Representation::getCdrSerializedSize(data.client(), current_alignment);
        break;
        case OBJK_APPLICATION:
        current_alignment += OBJK_APPLICATION_Representation::getCdrSerializedSize(data.application(), current_alignment);
        break;
        case OBJK_PARTICIPANT:
        current_alignment += OBJK_PARTICIPANT_Representation::getCdrSerializedSize(data.participant(), current_alignment);
        break;
        case OBJK_QOSPROFILE:
        current_alignment += OBJK_QOSPROFILE_Representation::getCdrSerializedSize(data.qos_profile(), current_alignment);
        break;
        case OBJK_TYPE:
        current_alignment += OBJK_TYPE_Representation::getCdrSerializedSize(data.type(), current_alignment);
        break;
        case OBJK_TOPIC:
        current_alignment += OBJK_TOPIC_Representation::getCdrSerializedSize(data.topic(), current_alignment);
        break;
        case OBJK_PUBLISHER:
        current_alignment += OBJK_PUBLISHER_Representation::getCdrSerializedSize(data.publisher(), current_alignment);
        break;
        case OBJK_SUBSCRIBER:
        current_alignment += OBJK_SUBSCRIBER_Representation::getCdrSerializedSize(data.subscriber(), current_alignment);
        break;
        case OBJK_DATAWRITER:
        current_alignment += OBJK_DATAWRITER_Representation::getCdrSerializedSize(data.data_writer(), current_alignment);
        break;
        case OBJK_DATAREADER:
        current_alignment += OBJK_DATAREADER_Representation::getCdrSerializedSize(data.data_reader(), current_alignment);
        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void ObjectVariant::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << discriminator_;

    switch(discriminator_)
    {
        case OBJK_CLIENT:
        scdr << client_;
        break;
        case OBJK_APPLICATION:
        scdr << application_;
        break;
        case OBJK_PARTICIPANT:
        scdr << participant_;
        break;
        case OBJK_QOSPROFILE:
        scdr << qos_profile_;
        break;
        case OBJK_TYPE:
        scdr << type_;
        break;
        case OBJK_TOPIC:
        scdr << topic_;
        break;
        case OBJK_PUBLISHER:
        scdr << publisher_;
        break;
        case OBJK_SUBSCRIBER:
        scdr << subscriber_;
        break;
        case OBJK_DATAWRITER:
        scdr << data_writer_;
        break;
        case OBJK_DATAREADER:
        scdr << data_reader_;
        break;
        default:
        break;
    }
}

void ObjectVariant::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> discriminator_;

    switch(discriminator_)
    {
        case OBJK_CLIENT:
        dcdr >> client_;
        break;
        case OBJK_APPLICATION:
        dcdr >> application_;
        break;
        case OBJK_PARTICIPANT:
        dcdr >> participant_;
        break;
        case OBJK_QOSPROFILE:
        dcdr >> qos_profile_;
        break;
        case OBJK_TYPE:
        dcdr >> type_;
        break;
        case OBJK_TOPIC:
        dcdr >> topic_;
        break;
        case OBJK_PUBLISHER:
        dcdr >> publisher_;
        break;
        case OBJK_SUBSCRIBER:
        dcdr >> subscriber_;
        break;
        case OBJK_DATAWRITER:
        dcdr >> data_writer_;
        break;
        case OBJK_DATAREADER:
        dcdr >> data_reader_;
        break;
        default:
        break;
    }
}


CreationMode::CreationMode()
{
    reuse_ = false;
    replace_ = false;
}

CreationMode::~CreationMode()
{
}

CreationMode::CreationMode(const CreationMode &x)
{
    reuse_ = x.reuse_;
    replace_ = x.replace_;
}

CreationMode::CreationMode(CreationMode &&x)
{
    reuse_ = x.reuse_;
    replace_ = x.replace_;
}

CreationMode& CreationMode::operator=(const CreationMode &x)
{
    reuse_ = x.reuse_;
    replace_ = x.replace_;
    
    return *this;
}

CreationMode& CreationMode::operator=(CreationMode &&x)
{
    reuse_ = x.reuse_;
    replace_ = x.replace_;
    
    return *this;
}

size_t CreationMode::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t CreationMode::getCdrSerializedSize(const CreationMode& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void CreationMode::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << reuse_;
    scdr << replace_;
}

void CreationMode::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> reuse_;
    dcdr >> replace_;
}

ResultStatus::ResultStatus()
{
    status_ = 0;
    implementation_status_ = 0;
}

ResultStatus::~ResultStatus()
{
}

ResultStatus::ResultStatus(const ResultStatus &x)
{
    request_id_ = x.request_id_;
    status_ = x.status_;
    implementation_status_ = x.implementation_status_;
}

ResultStatus::ResultStatus(ResultStatus &&x)
{
    request_id_ = std::move(x.request_id_);
    status_ = x.status_;
    implementation_status_ = x.implementation_status_;
}

ResultStatus& ResultStatus::operator=(const ResultStatus &x)
{
    request_id_ = x.request_id_;
    status_ = x.status_;
    implementation_status_ = x.implementation_status_;
    
    return *this;
}

ResultStatus& ResultStatus::operator=(ResultStatus &&x)
{
    request_id_ = std::move(x.request_id_);
    status_ = x.status_;
    implementation_status_ = x.implementation_status_;
    
    return *this;
}

size_t ResultStatus::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((4) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t ResultStatus::getCdrSerializedSize(const ResultStatus& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((4) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void ResultStatus::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << request_id_;
    scdr << status_;
    scdr << implementation_status_;
}

void ResultStatus::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> request_id_;
    dcdr >> status_;
    dcdr >> implementation_status_;
}

OBJK_DATAREADER_Status::OBJK_DATAREADER_Status()
{
    highest_acked_num_ = 0;
}

OBJK_DATAREADER_Status::~OBJK_DATAREADER_Status()
{
}

OBJK_DATAREADER_Status::OBJK_DATAREADER_Status(const OBJK_DATAREADER_Status &x)
{
    highest_acked_num_ = x.highest_acked_num_;
}

OBJK_DATAREADER_Status::OBJK_DATAREADER_Status(OBJK_DATAREADER_Status &&x)
{
    highest_acked_num_ = x.highest_acked_num_;
}

OBJK_DATAREADER_Status& OBJK_DATAREADER_Status::operator=(const OBJK_DATAREADER_Status &x)
{
    highest_acked_num_ = x.highest_acked_num_;
    
    return *this;
}

OBJK_DATAREADER_Status& OBJK_DATAREADER_Status::operator=(OBJK_DATAREADER_Status &&x)
{
    highest_acked_num_ = x.highest_acked_num_;
    
    return *this;
}

size_t OBJK_DATAREADER_Status::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

size_t OBJK_DATAREADER_Status::getCdrSerializedSize(const OBJK_DATAREADER_Status& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void OBJK_DATAREADER_Status::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << highest_acked_num_;
}

void OBJK_DATAREADER_Status::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> highest_acked_num_;
}

OBJK_DATAWRITER_Status::OBJK_DATAWRITER_Status()
{
    stream_seq_num_ = 0;
    sample_seq_num_ = 0;
}

OBJK_DATAWRITER_Status::~OBJK_DATAWRITER_Status()
{
}

OBJK_DATAWRITER_Status::OBJK_DATAWRITER_Status(const OBJK_DATAWRITER_Status &x)
{
    stream_seq_num_ = x.stream_seq_num_;
    sample_seq_num_ = x.sample_seq_num_;
}

OBJK_DATAWRITER_Status::OBJK_DATAWRITER_Status(OBJK_DATAWRITER_Status &&x)
{
    stream_seq_num_ = x.stream_seq_num_;
    sample_seq_num_ = x.sample_seq_num_;
}

OBJK_DATAWRITER_Status& OBJK_DATAWRITER_Status::operator=(const OBJK_DATAWRITER_Status &x)
{
    stream_seq_num_ = x.stream_seq_num_;
    sample_seq_num_ = x.sample_seq_num_;
    
    return *this;
}

OBJK_DATAWRITER_Status& OBJK_DATAWRITER_Status::operator=(OBJK_DATAWRITER_Status &&x)
{
    stream_seq_num_ = x.stream_seq_num_;
    sample_seq_num_ = x.sample_seq_num_;
    
    return *this;
}

size_t OBJK_DATAWRITER_Status::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t OBJK_DATAWRITER_Status::getCdrSerializedSize(const OBJK_DATAWRITER_Status& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void OBJK_DATAWRITER_Status::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << stream_seq_num_;
    scdr << sample_seq_num_;
}

void OBJK_DATAWRITER_Status::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> stream_seq_num_;
    dcdr >> sample_seq_num_;
}

StatusVariant::StatusVariant()
{
    discriminator_ = OBJK_DATAWRITER;


}

StatusVariant::~StatusVariant()
{
}

StatusVariant::StatusVariant(const StatusVariant &x)
{
    discriminator_ = x.discriminator_;
    
    switch(discriminator_)
    {
        case OBJK_DATAWRITER:
        data_writer_ = x.data_writer_;
        break;
        case OBJK_DATAREADER:
        data_reader_ = x.data_reader_;
        break;
        default:
        break;
    }
}

StatusVariant::StatusVariant(StatusVariant &&x)
{
    discriminator_ = x.discriminator_;
    
    switch(discriminator_)
    {
        case OBJK_DATAWRITER:
        data_writer_ = std::move(x.data_writer_);
        break;
        case OBJK_DATAREADER:
        data_reader_ = std::move(x.data_reader_);
        break;
        default:
        break;
    }
}

StatusVariant& StatusVariant::operator=(const StatusVariant &x)
{
    discriminator_ = x.discriminator_;
    
    switch(discriminator_)
    {
        case OBJK_DATAWRITER:
        data_writer_ = x.data_writer_;
        break;
        case OBJK_DATAREADER:
        data_reader_ = x.data_reader_;
        break;
        default:
        break;
    }
    
    return *this;
}

StatusVariant& StatusVariant::operator=(StatusVariant &&x)
{
    discriminator_ = x.discriminator_;
    
    switch(discriminator_)
    {
        case OBJK_DATAWRITER:
        data_writer_ = std::move(x.data_writer_);
        break;
        case OBJK_DATAREADER:
        data_reader_ = std::move(x.data_reader_);
        break;
        default:
        break;
    }
    
    return *this;
}

void StatusVariant::discriminator(ObjectKind _discriminator)
{
    bool b = false;
    
    switch(discriminator_)
    {
        case OBJK_DATAWRITER:
        switch(_discriminator)
        {
            case OBJK_DATAWRITER:
            b = true;
            break;
            default:
            break;
        }
        break;
        case OBJK_DATAREADER:
        switch(_discriminator)
        {
            case OBJK_DATAREADER:
            b = true;
            break;
            default:
            break;
        }
        break;
    }
    
    if(!b) throw BadParamException("Discriminator doesn't correspond with the selected union member");
    
    discriminator_ = _discriminator;
}

ObjectKind StatusVariant::discriminator() const
{
    return discriminator_;
}

ObjectKind& StatusVariant::discriminator()
{
    return discriminator_;
}

void StatusVariant::data_writer(const OBJK_DATAWRITER_Status &_data_writer)
{
    data_writer_ = _data_writer;
    discriminator_ = OBJK_DATAWRITER;
}

void StatusVariant::data_writer(OBJK_DATAWRITER_Status &&_data_writer)
{
    data_writer_ = std::move(_data_writer);
    discriminator_ = OBJK_DATAWRITER;
}

const OBJK_DATAWRITER_Status& StatusVariant::data_writer() const
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_DATAWRITER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return data_writer_;
}

OBJK_DATAWRITER_Status& StatusVariant::data_writer()
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_DATAWRITER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return data_writer_;
}
void StatusVariant::data_reader(const OBJK_DATAREADER_Status &_data_reader)
{
    data_reader_ = _data_reader;
    discriminator_ = OBJK_DATAREADER;
}

void StatusVariant::data_reader(OBJK_DATAREADER_Status &&_data_reader)
{
    data_reader_ = std::move(_data_reader);
    discriminator_ = OBJK_DATAREADER;
}

const OBJK_DATAREADER_Status& StatusVariant::data_reader() const
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_DATAREADER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return data_reader_;
}

OBJK_DATAREADER_Status& StatusVariant::data_reader()
{
    bool b = false;
        
    switch(discriminator_)
    {
        case OBJK_DATAREADER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return data_reader_;
}

size_t StatusVariant::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


        reset_alignment = current_alignment;

        reset_alignment += OBJK_DATAWRITER_Status::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += OBJK_DATAREADER_Status::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        

    return union_max_size_serialized - initial_alignment;
}

// TODO(Ricardo) Review
size_t StatusVariant::getCdrSerializedSize(const StatusVariant& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(data.discriminator_)
    {
        case OBJK_DATAWRITER:
        current_alignment += OBJK_DATAWRITER_Status::getCdrSerializedSize(data.data_writer(), current_alignment);
        break;
        case OBJK_DATAREADER:
        current_alignment += OBJK_DATAREADER_Status::getCdrSerializedSize(data.data_reader(), current_alignment);
        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void StatusVariant::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << discriminator_;

    switch(discriminator_)
    {
        case OBJK_DATAWRITER:
        scdr << data_writer_;
        break;
        case OBJK_DATAREADER:
        scdr << data_reader_;
        break;
        default:
        break;
    }
}

void StatusVariant::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> discriminator_;

    switch(discriminator_)
    {
        case OBJK_DATAWRITER:
        dcdr >> data_writer_;
        break;
        case OBJK_DATAREADER:
        dcdr >> data_reader_;
        break;
        default:
        break;
    }
}


Status::Status()
{



}

Status::~Status()
{
}

Status::Status(const Status &x)
{
    result_ = x.result_;
    object_id_ = x.object_id_;
    status_ = x.status_;
}

Status::Status(Status &&x)
{
    result_ = std::move(x.result_);
    object_id_ = std::move(x.object_id_);
    status_ = std::move(x.status_);
}

Status& Status::operator=(const Status &x)
{
    result_ = x.result_;
    object_id_ = x.object_id_;
    status_ = x.status_;
    
    return *this;
}

Status& Status::operator=(Status &&x)
{
    result_ = std::move(x.result_);
    object_id_ = std::move(x.object_id_);
    status_ = std::move(x.status_);
    
    return *this;
}

size_t Status::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ResultStatus::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((3) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += StatusVariant::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t Status::getCdrSerializedSize(const Status& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ResultStatus::getCdrSerializedSize(data.result(), current_alignment);
    current_alignment += ((3) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += StatusVariant::getCdrSerializedSize(data.status(), current_alignment);

    return current_alignment - initial_alignment;
}

void Status::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << result_;
    scdr << object_id_;
    scdr << status_;
}

void Status::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> result_;
    dcdr >> object_id_;
    dcdr >> status_;
}

Info::Info()
{



}

Info::~Info()
{
}

Info::Info(const Info &x)
{
    result_ = x.result_;
    object_id_ = x.object_id_;
    info_ = x.info_;
}

Info::Info(Info &&x)
{
    result_ = std::move(x.result_);
    object_id_ = std::move(x.object_id_);
    info_ = std::move(x.info_);
}

Info& Info::operator=(const Info &x)
{
    result_ = x.result_;
    object_id_ = x.object_id_;
    info_ = x.info_;
    
    return *this;
}

Info& Info::operator=(Info &&x)
{
    result_ = std::move(x.result_);
    object_id_ = std::move(x.object_id_);
    info_ = std::move(x.info_);
    
    return *this;
}

size_t Info::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ResultStatus::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((3) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += ObjectVariant::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t Info::getCdrSerializedSize(const Info& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ResultStatus::getCdrSerializedSize(data.result(), current_alignment);
    current_alignment += ((3) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += ObjectVariant::getCdrSerializedSize(data.info(), current_alignment);

    return current_alignment - initial_alignment;
}

void Info::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << result_;
    scdr << object_id_;
    scdr << info_;
}

void Info::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> result_;
    dcdr >> object_id_;
    dcdr >> info_;
}
DataReaderReadeSpec::DataReaderReadeSpec()
{
    max_samples_ = 0;
    include_info_ = false;

}

DataReaderReadeSpec::~DataReaderReadeSpec()
{
}

DataReaderReadeSpec::DataReaderReadeSpec(const DataReaderReadeSpec &x)
{
    max_samples_ = x.max_samples_;
    include_info_ = x.include_info_;
    content_filter_ = x.content_filter_;
}

DataReaderReadeSpec::DataReaderReadeSpec(DataReaderReadeSpec &&x)
{
    max_samples_ = x.max_samples_;
    include_info_ = x.include_info_;
    content_filter_ = std::move(x.content_filter_);
}

DataReaderReadeSpec& DataReaderReadeSpec::operator=(const DataReaderReadeSpec &x)
{
    max_samples_ = x.max_samples_;
    include_info_ = x.include_info_;
    content_filter_ = x.content_filter_;
    
    return *this;
}

DataReaderReadeSpec& DataReaderReadeSpec::operator=(DataReaderReadeSpec &&x)
{
    max_samples_ = x.max_samples_;
    include_info_ = x.include_info_;
    content_filter_ = std::move(x.content_filter_);
    
    return *this;
}

size_t DataReaderReadeSpec::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + 255 + 1;


    return current_alignment - initial_alignment;
}

size_t DataReaderReadeSpec::getCdrSerializedSize(const DataReaderReadeSpec& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4) + data.content_filter().size() + 1;


    return current_alignment - initial_alignment;
}

void DataReaderReadeSpec::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << max_samples_;
    scdr << include_info_;
    scdr << content_filter_;
}

void DataReaderReadeSpec::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> max_samples_;
    dcdr >> include_info_;
    dcdr >> content_filter_;
}

SampleInfo::SampleInfo()
{
    state_ = 0;
    sequence_number_ = 0;
    session_time_offset_ = 0;
}

SampleInfo::~SampleInfo()
{
}

SampleInfo::SampleInfo(const SampleInfo &x)
{
    state_ = x.state_;
    sequence_number_ = x.sequence_number_;
    session_time_offset_ = x.session_time_offset_;
}

SampleInfo::SampleInfo(SampleInfo &&x)
{
    state_ = x.state_;
    sequence_number_ = x.sequence_number_;
    session_time_offset_ = x.session_time_offset_;
}

SampleInfo& SampleInfo::operator=(const SampleInfo &x)
{
    state_ = x.state_;
    sequence_number_ = x.sequence_number_;
    session_time_offset_ = x.session_time_offset_;
    
    return *this;
}

SampleInfo& SampleInfo::operator=(SampleInfo &&x)
{
    state_ = x.state_;
    sequence_number_ = x.sequence_number_;
    session_time_offset_ = x.session_time_offset_;
    
    return *this;
}

size_t SampleInfo::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

size_t SampleInfo::getCdrSerializedSize(const SampleInfo& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);

    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);


    return current_alignment - initial_alignment;
}

void SampleInfo::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << state_;
    scdr << sequence_number_;
    scdr << session_time_offset_;
}

void SampleInfo::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> state_;
    dcdr >> sequence_number_;
    dcdr >> session_time_offset_;
}

SampleInfoDelta::SampleInfoDelta()
{
    state_ = 0;
    info_seq_number_delta_ = 0;
    info_timestamp_delta_ = 0;
}

SampleInfoDelta::~SampleInfoDelta()
{
}

SampleInfoDelta::SampleInfoDelta(const SampleInfoDelta &x)
{
    state_ = x.state_;
    info_seq_number_delta_ = x.info_seq_number_delta_;
    info_timestamp_delta_ = x.info_timestamp_delta_;
}

SampleInfoDelta::SampleInfoDelta(SampleInfoDelta &&x)
{
    state_ = x.state_;
    info_seq_number_delta_ = x.info_seq_number_delta_;
    info_timestamp_delta_ = x.info_timestamp_delta_;
}

SampleInfoDelta& SampleInfoDelta::operator=(const SampleInfoDelta &x)
{
    state_ = x.state_;
    info_seq_number_delta_ = x.info_seq_number_delta_;
    info_timestamp_delta_ = x.info_timestamp_delta_;
    
    return *this;
}

SampleInfoDelta& SampleInfoDelta::operator=(SampleInfoDelta &&x)
{
    state_ = x.state_;
    info_seq_number_delta_ = x.info_seq_number_delta_;
    info_timestamp_delta_ = x.info_timestamp_delta_;
    
    return *this;
}

size_t SampleInfoDelta::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

size_t SampleInfoDelta::getCdrSerializedSize(const SampleInfoDelta& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void SampleInfoDelta::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << state_;
    scdr << info_seq_number_delta_;
    scdr << info_timestamp_delta_;
}

void SampleInfoDelta::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> state_;
    dcdr >> info_seq_number_delta_;
    dcdr >> info_timestamp_delta_;
}

SampleData::SampleData()
{
}

SampleData::~SampleData()
{
}

SampleData::SampleData(const SampleData &x)
{
    serialized_data_ = x.serialized_data_;
}

SampleData::SampleData(SampleData &&x)
{
    serialized_data_ = std::move(x.serialized_data_);
}

SampleData& SampleData::operator=(const SampleData &x)
{
    serialized_data_ = x.serialized_data_;
    
    return *this;
}

SampleData& SampleData::operator=(SampleData &&x)
{
    serialized_data_ = std::move(x.serialized_data_);
    
    return *this;
}

size_t SampleData::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (100 * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t SampleData::getCdrSerializedSize(const SampleData& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    current_alignment += (data.serialized_data().size() * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void SampleData::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << serialized_data_;
}

void SampleData::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> serialized_data_;
}

Sample::Sample()
{


}

Sample::~Sample()
{
}

Sample::Sample(const Sample &x)
{
    info_ = x.info_;
    data_ = x.data_;
}

Sample::Sample(Sample &&x)
{
    info_ = std::move(x.info_);
    data_ = std::move(x.data_);
}

Sample& Sample::operator=(const Sample &x)
{
    info_ = x.info_;
    data_ = x.data_;
    
    return *this;
}

Sample& Sample::operator=(Sample &&x)
{
    info_ = std::move(x.info_);
    data_ = std::move(x.data_);
    
    return *this;
}

size_t Sample::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += SampleInfo::getMaxCdrSerializedSize(current_alignment);
    current_alignment += SampleData::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t Sample::getCdrSerializedSize(const Sample& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += SampleInfo::getCdrSerializedSize(data.info(), current_alignment);
    current_alignment += SampleData::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void Sample::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << info_;
    scdr << data_;
}

void Sample::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> info_;
    dcdr >> data_;
}

SampleDelta::SampleDelta()
{


}

SampleDelta::~SampleDelta()
{
}

SampleDelta::SampleDelta(const SampleDelta &x)
{
    info_delta_ = x.info_delta_;
    data_ = x.data_;
}

SampleDelta::SampleDelta(SampleDelta &&x)
{
    info_delta_ = std::move(x.info_delta_);
    data_ = std::move(x.data_);
}

SampleDelta& SampleDelta::operator=(const SampleDelta &x)
{
    info_delta_ = x.info_delta_;
    data_ = x.data_;
    
    return *this;
}

SampleDelta& SampleDelta::operator=(SampleDelta &&x)
{
    info_delta_ = std::move(x.info_delta_);
    data_ = std::move(x.data_);
    
    return *this;
}

size_t SampleDelta::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += SampleInfoDelta::getMaxCdrSerializedSize(current_alignment);
    current_alignment += SampleData::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t SampleDelta::getCdrSerializedSize(const SampleDelta& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += SampleInfoDelta::getCdrSerializedSize(data.info_delta(), current_alignment);
    current_alignment += SampleData::getCdrSerializedSize(data.data(), current_alignment);

    return current_alignment - initial_alignment;
}

void SampleDelta::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << info_delta_;
    scdr << data_;
}

void SampleDelta::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> info_delta_;
    dcdr >> data_;
}

SamplePacked::SamplePacked()
{


}

SamplePacked::~SamplePacked()
{
}

SamplePacked::SamplePacked(const SamplePacked &x)
{
    info_base_ = x.info_base_;
    sample_ = x.sample_;
}

SamplePacked::SamplePacked(SamplePacked &&x)
{
    info_base_ = std::move(x.info_base_);
    sample_ = std::move(x.sample_);
}

SamplePacked& SamplePacked::operator=(const SamplePacked &x)
{
    info_base_ = x.info_base_;
    sample_ = x.sample_;
    
    return *this;
}

SamplePacked& SamplePacked::operator=(SamplePacked &&x)
{
    info_base_ = std::move(x.info_base_);
    sample_ = std::move(x.sample_);
    
    return *this;
}

size_t SamplePacked::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += SampleInfo::getMaxCdrSerializedSize(current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < 100; ++a)
    {
        current_alignment += SampleDelta::getMaxCdrSerializedSize(current_alignment);}


    return current_alignment - initial_alignment;
}

size_t SamplePacked::getCdrSerializedSize(const SamplePacked& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += SampleInfo::getCdrSerializedSize(data.info_base(), current_alignment);
    current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
    for(size_t a = 0; a < data.sample().size(); ++a)
    {
        current_alignment += SampleDelta::getCdrSerializedSize(data.sample().at(a), current_alignment);}


    return current_alignment - initial_alignment;
}

void SamplePacked::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << info_base_;
    scdr << sample_;
}

void SamplePacked::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> info_base_;
    dcdr >> sample_;
}

RT_Data::RT_Data()
{
    discriminator_ = READM_DATA;





}

RT_Data::~RT_Data()
{
}

RT_Data::RT_Data(const RT_Data &x)
{
    discriminator_ = x.discriminator_;
    
    switch(discriminator_)
    {
        case READM_DATA:
        data_ = x.data_;
        break;
        case READM_DATA_SEQ:
        data_seq_ = x.data_seq_;
        break;
        case READM_SAMPLE:
        sample_ = x.sample_;
        break;
        case READM_SAMPLE_SEQ:
        sample_seq_ = x.sample_seq_;
        break;
        case READM_PACKED_SAMPLE_SEQ:
        sample_packed_seq_ = x.sample_packed_seq_;
        break;
        default:
        break;
    }
}

RT_Data::RT_Data(RT_Data &&x)
{
    discriminator_ = x.discriminator_;
    
    switch(discriminator_)
    {
        case READM_DATA:
        data_ = std::move(x.data_);
        break;
        case READM_DATA_SEQ:
        data_seq_ = std::move(x.data_seq_);
        break;
        case READM_SAMPLE:
        sample_ = std::move(x.sample_);
        break;
        case READM_SAMPLE_SEQ:
        sample_seq_ = std::move(x.sample_seq_);
        break;
        case READM_PACKED_SAMPLE_SEQ:
        sample_packed_seq_ = std::move(x.sample_packed_seq_);
        break;
        default:
        break;
    }
}

RT_Data& RT_Data::operator=(const RT_Data &x)
{
    discriminator_ = x.discriminator_;
    
    switch(discriminator_)
    {
        case READM_DATA:
        data_ = x.data_;
        break;
        case READM_DATA_SEQ:
        data_seq_ = x.data_seq_;
        break;
        case READM_SAMPLE:
        sample_ = x.sample_;
        break;
        case READM_SAMPLE_SEQ:
        sample_seq_ = x.sample_seq_;
        break;
        case READM_PACKED_SAMPLE_SEQ:
        sample_packed_seq_ = x.sample_packed_seq_;
        break;
        default:
        break;
    }
    
    return *this;
}

RT_Data& RT_Data::operator=(RT_Data &&x)
{
    discriminator_ = x.discriminator_;
    
    switch(discriminator_)
    {
        case READM_DATA:
        data_ = std::move(x.data_);
        break;
        case READM_DATA_SEQ:
        data_seq_ = std::move(x.data_seq_);
        break;
        case READM_SAMPLE:
        sample_ = std::move(x.sample_);
        break;
        case READM_SAMPLE_SEQ:
        sample_seq_ = std::move(x.sample_seq_);
        break;
        case READM_PACKED_SAMPLE_SEQ:
        sample_packed_seq_ = std::move(x.sample_packed_seq_);
        break;
        default:
        break;
    }
    
    return *this;
}

void RT_Data::_d(ReadMode __d)
{
    bool b = false;
    
    switch(discriminator_)
    {
        case READM_DATA:
        switch(__d)
        {
            case READM_DATA:
            b = true;
            break;
            default:
            break;
        }
        break;
        case READM_DATA_SEQ:
        switch(__d)
        {
            case READM_DATA_SEQ:
            b = true;
            break;
            default:
            break;
        }
        break;
        case READM_SAMPLE:
        switch(__d)
        {
            case READM_SAMPLE:
            b = true;
            break;
            default:
            break;
        }
        break;
        case READM_SAMPLE_SEQ:
        switch(__d)
        {
            case READM_SAMPLE_SEQ:
            b = true;
            break;
            default:
            break;
        }
        break;
        case READM_PACKED_SAMPLE_SEQ:
        switch(__d)
        {
            case READM_PACKED_SAMPLE_SEQ:
            b = true;
            break;
            default:
            break;
        }
        break;
    }
    
    if(!b) throw BadParamException("Discriminator doesn't correspond with the selected union member");
    
    discriminator_ = __d;
}

ReadMode RT_Data::_d() const
{
    return discriminator_;
}

ReadMode& RT_Data::_d()
{
    return discriminator_;
}

void RT_Data::data(const SampleData &_data)
{
    data_ = _data;
    discriminator_ = READM_DATA;
}

void RT_Data::data(SampleData &&_data)
{
    data_ = std::move(_data);
    discriminator_ = READM_DATA;
}

const SampleData& RT_Data::data() const
{
    bool b = false;
        
    switch(discriminator_)
    {
        case READM_DATA:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return data_;
}

SampleData& RT_Data::data()
{
    bool b = false;
        
    switch(discriminator_)
    {
        case READM_DATA:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return data_;
}
void RT_Data::data_seq(const SampleDataSeq &_data_seq)
{
    data_seq_ = _data_seq;
    discriminator_ = READM_DATA_SEQ;
}

void RT_Data::data_seq(SampleDataSeq &&_data_seq)
{
    data_seq_ = std::move(_data_seq);
    discriminator_ = READM_DATA_SEQ;
}

const SampleDataSeq& RT_Data::data_seq() const
{
    bool b = false;
        
    switch(discriminator_)
    {
        case READM_DATA_SEQ:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return data_seq_;
}

SampleDataSeq& RT_Data::data_seq()
{
    bool b = false;
        
    switch(discriminator_)
    {
        case READM_DATA_SEQ:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return data_seq_;
}
void RT_Data::sample(const Sample &_sample)
{
    sample_ = _sample;
    discriminator_ = READM_SAMPLE;
}

void RT_Data::sample(Sample &&_sample)
{
    sample_ = std::move(_sample);
    discriminator_ = READM_SAMPLE;
}

const Sample& RT_Data::sample() const
{
    bool b = false;
        
    switch(discriminator_)
    {
        case READM_SAMPLE:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return sample_;
}

Sample& RT_Data::sample()
{
    bool b = false;
        
    switch(discriminator_)
    {
        case READM_SAMPLE:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return sample_;
}
void RT_Data::sample_seq(const SampleSeq &_sample_seq)
{
    sample_seq_ = _sample_seq;
    discriminator_ = READM_SAMPLE_SEQ;
}

void RT_Data::sample_seq(SampleSeq &&_sample_seq)
{
    sample_seq_ = std::move(_sample_seq);
    discriminator_ = READM_SAMPLE_SEQ;
}

const SampleSeq& RT_Data::sample_seq() const
{
    bool b = false;
        
    switch(discriminator_)
    {
        case READM_SAMPLE_SEQ:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return sample_seq_;
}

SampleSeq& RT_Data::sample_seq()
{
    bool b = false;
        
    switch(discriminator_)
    {
        case READM_SAMPLE_SEQ:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return sample_seq_;
}
void RT_Data::sample_packed_seq(const SamplePackedSeq &_sample_packed_seq)
{
    sample_packed_seq_ = _sample_packed_seq;
    discriminator_ = READM_PACKED_SAMPLE_SEQ;
}

void RT_Data::sample_packed_seq(SamplePackedSeq &&_sample_packed_seq)
{
    sample_packed_seq_ = std::move(_sample_packed_seq);
    discriminator_ = READM_PACKED_SAMPLE_SEQ;
}

const SamplePackedSeq& RT_Data::sample_packed_seq() const
{
    bool b = false;
        
    switch(discriminator_)
    {
        case READM_PACKED_SAMPLE_SEQ:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return sample_packed_seq_;
}

SamplePackedSeq& RT_Data::sample_packed_seq()
{
    bool b = false;
        
    switch(discriminator_)
    {
        case READM_PACKED_SAMPLE_SEQ:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return sample_packed_seq_;
}

size_t RT_Data::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


        reset_alignment = current_alignment;

        reset_alignment += SampleData::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);
        for(size_t a = 0; a < 100; ++a)
        {
            reset_alignment += SampleData::getMaxCdrSerializedSize(reset_alignment);}

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += Sample::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);
        for(size_t a = 0; a < 100; ++a)
        {
            reset_alignment += Sample::getMaxCdrSerializedSize(reset_alignment);}

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += 4 + eprosima::fastcdr::Cdr::alignment(reset_alignment, 4);
        for(size_t a = 0; a < 100; ++a)
        {
            reset_alignment += SamplePacked::getMaxCdrSerializedSize(reset_alignment);}

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        

    return union_max_size_serialized - initial_alignment;
}

// TODO(Ricardo) Review
size_t RT_Data::getCdrSerializedSize(const RT_Data& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(data.discriminator_)
    {
        case READM_DATA:
        current_alignment += SampleData::getCdrSerializedSize(data.data(), current_alignment);
        break;
        case READM_DATA_SEQ:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
        for(size_t a = 0; a < data.data_seq().size(); ++a)
        {
            current_alignment += SampleData::getCdrSerializedSize(data.data_seq().at(a), current_alignment);}
        break;
        case READM_SAMPLE:
        current_alignment += Sample::getCdrSerializedSize(data.sample(), current_alignment);
        break;
        case READM_SAMPLE_SEQ:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
        for(size_t a = 0; a < data.sample_seq().size(); ++a)
        {
            current_alignment += Sample::getCdrSerializedSize(data.sample_seq().at(a), current_alignment);}
        break;
        case READM_PACKED_SAMPLE_SEQ:
        current_alignment += 4 + eprosima::fastcdr::Cdr::alignment(current_alignment, 4);
        for(size_t a = 0; a < data.sample_packed_seq().size(); ++a)
        {
            current_alignment += SamplePacked::getCdrSerializedSize(data.sample_packed_seq().at(a), current_alignment);}
        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void RT_Data::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << discriminator_;

    switch(discriminator_)
    {
        case READM_DATA:
        scdr << data_;
        break;
        case READM_DATA_SEQ:
        scdr << data_seq_;
        break;
        case READM_SAMPLE:
        scdr << sample_;
        break;
        case READM_SAMPLE_SEQ:
        scdr << sample_seq_;
        break;
        case READM_PACKED_SAMPLE_SEQ:
        scdr << sample_packed_seq_;
        break;
        default:
        break;
    }
}

void RT_Data::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> discriminator_;

    switch(discriminator_)
    {
        case READM_DATA:
        dcdr >> data_;
        break;
        case READM_DATA_SEQ:
        dcdr >> data_seq_;
        break;
        case READM_SAMPLE:
        dcdr >> sample_;
        break;
        case READM_SAMPLE_SEQ:
        dcdr >> sample_seq_;
        break;
        case READM_PACKED_SAMPLE_SEQ:
        dcdr >> sample_packed_seq_;
        break;
        default:
        break;
    }
}

