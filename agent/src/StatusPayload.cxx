// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/*! 
 * @file StatusPayload.cpp
 * This source file contains the definition of the described types in the IDL file.
 *
 * This file was generated by the tool gen.
 */

#ifdef _WIN32
// Remove linker warning LNK4221 on Visual Studio
namespace { char dummy; }
#endif

#include "StatusPayload.h"

#include <fastcdr/Cdr.h>

#include <fastcdr/exceptions/BadParamException.h>
using namespace eprosima::fastcdr::exception;

#include <utility>

OBJK_DATAREADER_Status::OBJK_DATAREADER_Status()
{
    m_highest_acked_num = 0;
}

OBJK_DATAREADER_Status::~OBJK_DATAREADER_Status()
{
}

OBJK_DATAREADER_Status::OBJK_DATAREADER_Status(const OBJK_DATAREADER_Status &x)
{
    m_highest_acked_num = x.m_highest_acked_num;
}

OBJK_DATAREADER_Status::OBJK_DATAREADER_Status(OBJK_DATAREADER_Status &&x)
{
    m_highest_acked_num = x.m_highest_acked_num;
}

OBJK_DATAREADER_Status& OBJK_DATAREADER_Status::operator=(const OBJK_DATAREADER_Status &x)
{
    m_highest_acked_num = x.m_highest_acked_num;
    
    return *this;
}

OBJK_DATAREADER_Status& OBJK_DATAREADER_Status::operator=(OBJK_DATAREADER_Status &&x)
{
    m_highest_acked_num = x.m_highest_acked_num;
    
    return *this;
}

size_t OBJK_DATAREADER_Status::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

size_t OBJK_DATAREADER_Status::getCdrSerializedSize(const OBJK_DATAREADER_Status& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);


    return current_alignment - initial_alignment;
}

void OBJK_DATAREADER_Status::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_highest_acked_num;
}

void OBJK_DATAREADER_Status::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_highest_acked_num;
}

size_t OBJK_DATAREADER_Status::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            

    return current_align;
}

bool OBJK_DATAREADER_Status::isKeyDefined()
{
    return false;
}

void OBJK_DATAREADER_Status::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
}
OBJK_DATAWRITER_Status::OBJK_DATAWRITER_Status()
{
    m_stream_seq_num = 0;
    m_sample_seq_num = 0;
}

OBJK_DATAWRITER_Status::~OBJK_DATAWRITER_Status()
{
}

OBJK_DATAWRITER_Status::OBJK_DATAWRITER_Status(const OBJK_DATAWRITER_Status &x)
{
    m_stream_seq_num = x.m_stream_seq_num;
    m_sample_seq_num = x.m_sample_seq_num;
}

OBJK_DATAWRITER_Status::OBJK_DATAWRITER_Status(OBJK_DATAWRITER_Status &&x)
{
    m_stream_seq_num = x.m_stream_seq_num;
    m_sample_seq_num = x.m_sample_seq_num;
}

OBJK_DATAWRITER_Status& OBJK_DATAWRITER_Status::operator=(const OBJK_DATAWRITER_Status &x)
{
    m_stream_seq_num = x.m_stream_seq_num;
    m_sample_seq_num = x.m_sample_seq_num;
    
    return *this;
}

OBJK_DATAWRITER_Status& OBJK_DATAWRITER_Status::operator=(OBJK_DATAWRITER_Status &&x)
{
    m_stream_seq_num = x.m_stream_seq_num;
    m_sample_seq_num = x.m_sample_seq_num;
    
    return *this;
}

size_t OBJK_DATAWRITER_Status::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

size_t OBJK_DATAWRITER_Status::getCdrSerializedSize(const OBJK_DATAWRITER_Status& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += 2 + eprosima::fastcdr::Cdr::alignment(current_alignment, 2);

    current_alignment += 8 + eprosima::fastcdr::Cdr::alignment(current_alignment, 8);


    return current_alignment - initial_alignment;
}

void OBJK_DATAWRITER_Status::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_stream_seq_num;
    scdr << m_sample_seq_num;
}

void OBJK_DATAWRITER_Status::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_stream_seq_num;
    dcdr >> m_sample_seq_num;
}

size_t OBJK_DATAWRITER_Status::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            



    return current_align;
}

bool OBJK_DATAWRITER_Status::isKeyDefined()
{
    return false;
}

void OBJK_DATAWRITER_Status::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
}
StatusVariant::StatusVariant()
{
    m__d = OBJK_DATAWRITER;


}

StatusVariant::~StatusVariant()
{
}

StatusVariant::StatusVariant(const StatusVariant &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case OBJK_DATAWRITER:
        m_data_writer = x.m_data_writer;
        break;
        case OBJK_DATAREADER:
        m_data_reader = x.m_data_reader;
        break;
        default:
        break;
    }
}

StatusVariant::StatusVariant(StatusVariant &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case OBJK_DATAWRITER:
        m_data_writer = std::move(x.m_data_writer);
        break;
        case OBJK_DATAREADER:
        m_data_reader = std::move(x.m_data_reader);
        break;
        default:
        break;
    }
}

StatusVariant& StatusVariant::operator=(const StatusVariant &x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case OBJK_DATAWRITER:
        m_data_writer = x.m_data_writer;
        break;
        case OBJK_DATAREADER:
        m_data_reader = x.m_data_reader;
        break;
        default:
        break;
    }
    
    return *this;
}

StatusVariant& StatusVariant::operator=(StatusVariant &&x)
{
    m__d = x.m__d;
    
    switch(m__d)
    {
        case OBJK_DATAWRITER:
        m_data_writer = std::move(x.m_data_writer);
        break;
        case OBJK_DATAREADER:
        m_data_reader = std::move(x.m_data_reader);
        break;
        default:
        break;
    }
    
    return *this;
}

void StatusVariant::_d(ObjectKind __d)
{
    bool b = false;
    
    switch(m__d)
    {
        case OBJK_DATAWRITER:
        switch(__d)
        {
            case OBJK_DATAWRITER:
            b = true;
            break;
            default:
            break;
        }
        break;
        case OBJK_DATAREADER:
        switch(__d)
        {
            case OBJK_DATAREADER:
            b = true;
            break;
            default:
            break;
        }
        break;
    }
    
    if(!b) throw BadParamException("Discriminator doesn't correspond with the selected union member");
    
    m__d = __d;
}

ObjectKind StatusVariant::_d() const
{
    return m__d;
}

ObjectKind& StatusVariant::_d()
{
    return m__d;
}

void StatusVariant::data_writer(const OBJK_DATAWRITER_Status &_data_writer)
{
    m_data_writer = _data_writer;
    m__d = OBJK_DATAWRITER;
}

void StatusVariant::data_writer(OBJK_DATAWRITER_Status &&_data_writer)
{
    m_data_writer = std::move(_data_writer);
    m__d = OBJK_DATAWRITER;
}

const OBJK_DATAWRITER_Status& StatusVariant::data_writer() const
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_DATAWRITER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_data_writer;
}

OBJK_DATAWRITER_Status& StatusVariant::data_writer()
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_DATAWRITER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_data_writer;
}
void StatusVariant::data_reader(const OBJK_DATAREADER_Status &_data_reader)
{
    m_data_reader = _data_reader;
    m__d = OBJK_DATAREADER;
}

void StatusVariant::data_reader(OBJK_DATAREADER_Status &&_data_reader)
{
    m_data_reader = std::move(_data_reader);
    m__d = OBJK_DATAREADER;
}

const OBJK_DATAREADER_Status& StatusVariant::data_reader() const
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_DATAREADER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_data_reader;
}

OBJK_DATAREADER_Status& StatusVariant::data_reader()
{
    bool b = false;
        
    switch(m__d)
    {
        case OBJK_DATAREADER:
        b = true;
        break;
        default:
        break;
    }    
    if(!b) throw BadParamException("This member is not been selected");
    
    return m_data_reader;
}

size_t StatusVariant::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
    size_t reset_alignment = 0;
    size_t union_max_size_serialized = 0;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


        reset_alignment = current_alignment;

        reset_alignment += OBJK_DATAWRITER_Status::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        
        reset_alignment = current_alignment;

        reset_alignment += OBJK_DATAREADER_Status::getMaxCdrSerializedSize(reset_alignment);

        if(union_max_size_serialized < reset_alignment)
            union_max_size_serialized = reset_alignment;

        

    return union_max_size_serialized - initial_alignment;
}

// TODO(Ricardo) Review
size_t StatusVariant::getCdrSerializedSize(const StatusVariant& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    switch(data.m__d)
    {
        case OBJK_DATAWRITER:
        current_alignment += OBJK_DATAWRITER_Status::getCdrSerializedSize(data.data_writer(), current_alignment);
        break;
        case OBJK_DATAREADER:
        current_alignment += OBJK_DATAREADER_Status::getCdrSerializedSize(data.data_reader(), current_alignment);
        break;
        default:
        break;
    }

    return current_alignment - initial_alignment;
}

void StatusVariant::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m__d;

    switch(m__d)
    {
        case OBJK_DATAWRITER:
        scdr << m_data_writer;
        break;
        case OBJK_DATAREADER:
        scdr << m_data_reader;
        break;
        default:
        break;
    }
}

void StatusVariant::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m__d;

    switch(m__d)
    {
        case OBJK_DATAWRITER:
        dcdr >> m_data_writer;
        break;
        case OBJK_DATAREADER:
        dcdr >> m_data_reader;
        break;
        default:
        break;
    }
}


ResultStatus::ResultStatus()
{

    m_status = 0;
    m_implementation_status = 0;
}

ResultStatus::~ResultStatus()
{
}

ResultStatus::ResultStatus(const ResultStatus &x)
{
    m_request_id = x.m_request_id;
    m_status = x.m_status;
    m_implementation_status = x.m_implementation_status;
}

ResultStatus::ResultStatus(ResultStatus &&x)
{
    m_request_id = std::move(x.m_request_id);
    m_status = x.m_status;
    m_implementation_status = x.m_implementation_status;
}

ResultStatus& ResultStatus::operator=(const ResultStatus &x)
{
    m_request_id = x.m_request_id;
    m_status = x.m_status;
    m_implementation_status = x.m_implementation_status;
    
    return *this;
}

ResultStatus& ResultStatus::operator=(ResultStatus &&x)
{
    m_request_id = std::move(x.m_request_id);
    m_status = x.m_status;
    m_implementation_status = x.m_implementation_status;
    
    return *this;
}

size_t ResultStatus::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

size_t ResultStatus::getCdrSerializedSize(const ResultStatus& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ((2) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += 1 + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);


    return current_alignment - initial_alignment;
}

void ResultStatus::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_request_id;
    scdr << m_status;
    scdr << m_implementation_status;
}

void ResultStatus::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_request_id;
    dcdr >> m_status;
    dcdr >> m_implementation_status;
}

size_t ResultStatus::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool ResultStatus::isKeyDefined()
{
    return false;
}

void ResultStatus::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
	 
}
Status::Status()
{



}

Status::~Status()
{
}

Status::Status(const Status &x)
{
    m_result = x.m_result;
    m_object_id = x.m_object_id;
    m_status = x.m_status;
}

Status::Status(Status &&x)
{
    m_result = std::move(x.m_result);
    m_object_id = std::move(x.m_object_id);
    m_status = std::move(x.m_status);
}

Status& Status::operator=(const Status &x)
{
    m_result = x.m_result;
    m_object_id = x.m_object_id;
    m_status = x.m_status;
    
    return *this;
}

Status& Status::operator=(Status &&x)
{
    m_result = std::move(x.m_result);
    m_object_id = std::move(x.m_object_id);
    m_status = std::move(x.m_status);
    
    return *this;
}

size_t Status::getMaxCdrSerializedSize(size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ResultStatus::getMaxCdrSerializedSize(current_alignment);
    current_alignment += ((3) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);

    current_alignment += StatusVariant::getMaxCdrSerializedSize(current_alignment);

    return current_alignment - initial_alignment;
}

size_t Status::getCdrSerializedSize(const Status& data, size_t current_alignment)
{
    size_t initial_alignment = current_alignment;
            
    current_alignment += ResultStatus::getCdrSerializedSize(data.result(), current_alignment);
    current_alignment += ((3) * 1) + eprosima::fastcdr::Cdr::alignment(current_alignment, 1);
    current_alignment += StatusVariant::getCdrSerializedSize(data.status(), current_alignment);

    return current_alignment - initial_alignment;
}

void Status::serialize(eprosima::fastcdr::Cdr &scdr) const
{
    scdr << m_result;
    scdr << m_object_id;
    scdr << m_status;
}

void Status::deserialize(eprosima::fastcdr::Cdr &dcdr)
{
    dcdr >> m_result;
    dcdr >> m_object_id;
    dcdr >> m_status;
}

size_t Status::getKeyMaxCdrSerializedSize(size_t current_alignment)
{
	size_t current_align = current_alignment;
            




    return current_align;
}

bool Status::isKeyDefined()
{
    return false;
}

void Status::serializeKey(eprosima::fastcdr::Cdr &scdr) const
{
	 
	 
	 
}